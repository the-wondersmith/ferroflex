#REM  DataFlex standard MACROs
#REM  Copyright 1987-2001 Data Access Corporation, Miami FL, USA
#REM  All Rights reserved.
#REM  THIS IS THE FILE THAT DEFINES THE COMMANDS IN DATAFLEX VERSION 3.1
#REM  IT MUST BE PACKed INTO FLEX.CFL WITH THE COMMAND "DFPACK FMAC"
#REM  THIS SUPPORTS FMACS FOR BOTH 3.1 AND 4.0 (WINDOWS). THE COMPILER
#REM  VARIABLE IS$WINDOWS DETERMINES IF THIS IS CHARACTER MODE OR GUI.

#REM 3/10/2001 mg - Using VDF7 service pack 1 fmac. Converted to allow character mode.
#REM  To set for windows define IS$WINDOWS.Separated messages by purpose (VDF, WAS, XML)
#REM so that they can be turned on or off depending on a compiler variable. This has
#REM not yet been implemented, so everything is on.
#REM This FMAC needs to be checked against the FMAC that John sent in Feb 2001 for
#REM changes.

#REM Changes 5/20/98 -JJT
#REM    Changes in many commands to make this friendlier for VDF5.1
#REM       Changed syntax/Better error checking. Most commands are
#REM       added to the end. Note we now use !Zk, !Zl, !Zm, !Zn, !Zo
#REM       1. All changes marked JJT-5.1


#REM  GENERAL FORMAT OF AN ICODE LINE:

#REM  !A [] $000 ARG1 ARG2
#REM  !A Generates the next line number
#REM  [] is a place holder for the indicators
#REM  $000 is a hex number that calls the appropriate 'C' routine
#REM  arg1, arg2 - two arguments of any type/class
#REM           can be passed to the routine.

#REM  THE FOLLOWING ARE THE COMPILE-TIME VARIABLES USED
#REM  UPPERCASE WILL AUTO-INCREMENT (FIRST);
#REM  LOWER CASE WILL NOT.  THEN SUBSTITUTE TO AN INTEGER VALUE.

#REM  !A - Next line number
#REM  !B - Reserved
#REM  !C - Next indicator number
#REM  !D - Next integer number
#REM  !E - Autopage, window #
#REM  !F - Autopage, page #
#REM  G,H,I,J,K,L,M - You may use these
#REM  !N - Static nesting level
#REM  !O - Used by ?ET*ATTRIBUTE
#REM  !P - Used by report
#REM  !Q - Low level temporary
#REM  !R - Static structure number (Begin/End)
#REM  !S - Temporary used by end/loop/until
#REM  !T,!U - Reserved
#REM  !V - Next variable number.
#REM  !W - Reserved
#REM  !X - Temporary for enter & report - file numbers.
#REM  !Y - Temporary for keyproc
#REM  !Z - Reserved

#REM Type checking in command args use negative logic and
#REM conform to the following:

#REM C - Constant          V - Memory variable
#REM F - File element      G - Group
#REM W - Window
#REM S - String            E - Expression
#REM N - Number            L - Label
#REM D - Date              O - Group options
#REM I - Integer           B - Group indicators
#REM # - Indicator         . - No more arguments
#REM X - Not an indicator  R - Argument required
#REM T - Error if typed    $ - Changes window to string
#REM U - Error if untyped  "constant" - Must be constant

#REM
#REM  Types from Runtime.           Command
#REM   ARGSTR = 0,           S      String
#REM   ARGNUM = 1,           N      Number
#REM   ARGDATE = 2,          D      Date
#REM   ARGINT = 3,           I      Integer
#REM   ARGBIGINT = 4,        H      BigInt
#REM   ARGREAL = 5,          R      Real
#REM   ARGBOOL = 6,          B      Logical - this is actually only used for indicators
#REM   ARGMEM = 7,           X      Binary
#REM   ARGTIME = 8,          T      Time
#REM   ARGTIMESTAMP = 9,     M      DateTime
#REM   ARGFLOAT = 10,        F      Float
#REM   ARGBYTE = 11,         Y      Char
#REM   ARGUBYTE = 12         C      UChar
#REM   ARGSHORT = 13,        W      Short
#REM   ARGUSHORT = 14,       U      UShort
#REM   ARGULONG = 15,        V      UInteger
#REM   ARGBIT = 16,          Z      Boolean (This is what you use for boolean)
#REM   ARGBIGUINT = 17,      G      UBigInt
#REM   ARGSQLNUMERIC =  18,  O      Currency  (Visual Basic Decimal)
#REM   ARGCSTRING = 19,      K      Struct
#REM   ARGTIMESPAN = 20,     P      Timepsan (PERIOD)
#REM   ARGUNICODE = 21,      A      Array
#REM   ARGSUPERBCD = 22,     Q      Decimal (Very large decimal)
#REM                         J      Variant
#REM   ARG_UNUSED
#REM
#REM Classes from Runtime.
#REM   ARGNOTHING,
#REM   ARGFLDSTR,   Field (string)                F
#REM   ARGFLDNUM,   Field (BCD, Integer or Date)  F
#REM   ARGWNDSTR,   Window (string)               W
#REM   ARGWNDNUM,   Window (BCD, Integer or Date) W
#REM   ARGDATSTR,   String or Expression          CV
#REM   ARGDATNUM,   BCD or Numeric                CV
#REM   ARGCONINT,   Int or Long                   CV
#REM   ARGSYSINT,   System Integers
#REM   ARGSYSDATE,  System Date
#REM   ARGSYSTIME,  System Time
#REM   ARGDATREAL,  Reals                         CV
#REM   ARGEXP,      Expression                    E
#REM   ARGWNDRL,    Window Real                   W
#REM   ARGSTACK,    Stack                         S
#REM   ARGHEAP,     Global Heap Address           H
#REM   ARGPROC      Pointer into shared memory    P (for process)
#REM

#REM Method Overloading
#REM NOTE: As of 15.0 we are deprecating the use of Overloaded messages. The existing technology will
#REM       continue to be supported as-is and it will not be extended
#REM
#REM         Function Foo Overloaded Integer i Integer j Returns Integer
#REM         Function Foo Overloaded Integer i
#REM
#REM         Set Entry_Msg To (Get_Foo(Integer, Integer))
#REM         Move (Foo(self,10)) To windowindex
#REM
#REM Overloaded types create mangled symbol:
#REM
#REM         Get_Foo@2
#REM         Get_Foo@1
#REM         Also defines symbol Get_Foo_Overloaded
#REM
#REM Non-Overloaded types create non-mangled symbol:
#REM
#REM         Get_Foo
#REM
#REM Rules
#REM 1. Overloaded and non-overloaded messages may not have the same name (compiler error)
#REM 2. Global procedures and functions cannot be overloaded (compiler error)...only class methods
#REM 3. Class methods (regular and overloaded), global proc/funcs, and object name (when function) cannot
#REM    have the same name. The first "type" to use the name locks it for that type.
#REM
#REM Fixups:
#REM
#REM         When compiling, FREFs are created for code fixups. At that point, it
#REM is unclear how the method name will be declared (overloaded or non-overloaded),
#REM so a mangled name is created. When fixups are processed, method identifiers
#REM are resolved in this order:
#REM
#REM         1. Non-overloaded method (class or global)
#REM         2. Object overloaded Method
#REM    Since there can be no overlap of naming across types, the order or resolution does not matter
#REM
#REM
#REM Object names:
#REM
#REM         Object access methods are not overloaded.
#REM
#REM Properties:
#REM
#REM         Properties are not overloaded.
#REM

#REM Example: #COMMAND EXAMPLE SND means arg1 cannot be string,number,or date

#COMMAND ABORT &.
  !A [] $040
#ENDCOMMAND

#COMMAND ACCEPT #L #L #LUC #LUWFC .
  #SET Q$ !0
  #IF !q=0
    AUTO2$ ACCEPT PAGE!f
  #ELSE
    #IF !q=1
      #IFCLASS !1 "G"
        AUTO2$ ACCEPT PAGE!f !1
      #ELSE
        #CHECK !1 _CVFG#L
        !A [] $1C1 !1 |CI0
      #ENDIF
    #ELSE
      #IF !q=2
        #IFCLASS !2 "G"
          #FORMAT !1 !2
          #CHECK !1 _CVFG#L
          !A [] $1C1 !1 |CI0
        #ELSE
          AUTO2$ ACCEPT PAGE!f TO !2
        #ENDIF
      #ELSE
        #IF !q>2
          #IFCLASS !3 "G"
            #CHECK !1 "TO"
            AUTO2$ ACCEPT PAGE!f TO !2 !3
          #ELSE
            #IFCLASS !4 "G"
              #FORMAT !1 !4
            #ENDIF
            #CHECK !1 _CVFG#L
            #CHECK !2 "TO"
            #CHECK !3 _CG#LE
            !A [] $1C1 !1 !3
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND APPEND #LGULCE$ #LGULR$
  !A [] $243 !1 !2
  #IF !0>2
    APPEND !1 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

#COMMAND ASCII &#GRLU "TO" #UGRLCE .
  !A [] $247 !1 !3
#ENDCOMMAND

#REM  The AUTO commands are used internally to generate the
#REM  next AUTOPAGE window number at compile time.

#COMMAND AUTO2$
  !1 !2.!E !3 !4 !5
  #CHECK !2.!e _RUCVF#L
#ENDCOMMAND

#COMMAND AUTO3$
  !1 !2 !3.!E !4 !5
  #CHECK !3.!e _RUCVF#L
#ENDCOMMAND

#COMMAND AUTO4$
  !1 !2 !3 !4.!E !5
  #CHECK !4.!e _RUCVF#L
#ENDCOMMAND

#COMMAND AUTOPAGE &T %USNVLE# .
  #CHECK !1.N _WFVSG#LU
  #SET F$ !1.N
  #SET E$ !2
  #IF !e>0
    #SET E$ !e-1
  #ENDIF
#ENDCOMMAND

#REM BACKFIELD can only be used in a KEY PROCedure. It returns to the
#REM window (COMMAND) PRIOR to the one that called it.

#COMMAND BACKFIELD &.
  !A [] $288
#ENDCOMMAND

#COMMAND BEGIN &.
  #SET N$ !N
  #PUSH !R
  #XPUSH !n $INIT  // Init IF/ELSE stack at this nesting level.
  #IFIND //INCLUDE JUMPS IF INDICATORS ON LINE.
    // GOTO BEGIN$!r
    !A [] $041 |CI0
    #FREF BEGIN$!r !a
    #$ !A 0 0 0 $041 |CL0
    #FREF END$!r !a
  #ENDIF
  #$ BEGIN$!r:
#ENDCOMMAND

#COMMAND BLANKFORM &%CVFG#EL  "THRU""THROUGH""" %CVFG#LUE .
  #IF !0>0
    #IFDEF !1
      !A [] $1C4 !1 !3
    #ELSE
      #CHECK !1.N _#RLGVU
      !A [] $1C4 !1.N
    #ENDIF
  #ELSE
    !A [] $1C4 |CI0
  #ENDIF
#ENDCOMMAND

#COMMAND BREAK$             // does breakpoint for all
  #IF (!0>0)
    #IFCLASS !1 _F
      BREAKPOINT |CI!P !1
    #ELSE
      #CHECK !1 _LGBCVWIEOU#
    #ENDIF
  #ENDIF
  #IF (!0>1)
    BREAK$ !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

#COMMAND BREAK$DOWN R           // does gosub to break
  #IF !x>0                // sections from N to 0
    #IF !0>1
      // GOSUB !1!x
      !A [] $42 |CL0
      #FREF !1!x !a
    #ELSE
      //[!x] GOSUB !1!x
      !A [!x] $42 |CL0
      #FREF !1!x !a
    #ENDIF
  #ENDIF
  #SET X$ !x-1
  #IF !x>0
    BREAK$DOWN !1 !2
  #ENDIF
#ENDCOMMAND

#COMMAND BREAK$PRT          // prints all SUBHEADERs
  #IF !x<!p               // for page
    #IFDEF !1!X.N
      !A [~ !x] $202 !1!x.N  // OUTPUT
    #ENDIF
    BREAK$PRT !1 !2
  #ENDIF
#ENDCOMMAND

#COMMAND BREAK$T3
  #IF !x<!p               // makes unused sections defined
    MAKEDEF$ RPT.SUBHEADER!X RPT.SUBTOTAL!x
    BREAK$T3
  #ENDIF
#ENDCOMMAND

#COMMAND BREAK$UP           // does GOSUB to break
  #IF !x<!p               // sections from 0 to N
    #IF !0=1
      //[!X] GOSUB !1!x
      !A [!X] $42 |CL0
      #FREF !1!x !a
    #ELSE
      // GOSUB !1!X
      !A [] $42 |CL0
      #FREF !1!X !a
    #ENDIF
    BREAK$UP !1 !2
  #ENDIF
#ENDCOMMAND

#COMMAND BREAKINIT  &.  // set up breakpoints for REPORT
  !A [] $207
#ENDCOMMAND

#COMMAND BREAKPOINT &UVFW UCI   // test breakpoint and set indicators
  !A [] $204 !1 !2
#ENDCOMMAND

#COMMAND CALCULATE &#ULG "TO" #UCLGER .
  #IFTYPE !3 "R"
    !A [] $085 !1 !3 //MOVE REAL
  #ELSE
    !A [] $081 !1 !3 //MOVE NUM
  #ENDIF
#ENDCOMMAND

#COMMAND CHAIN RNDIG#L  NDG#L
  #SET Q$ 0
  #IFSAME !1 WAIT
    CHAIN$HELP !3 !4 !5 !6 !7 !8 !9
    !A [] $049 !2 |CI!q
  #ELSE
    #CHECK !1 _U
    CHAIN$HELP !2 !3 !4 !5 !6 !7 !8 !9
    !A [] $045 !1 |CI!q
  #ENDIF
#ENDCOMMAND

#COMMAND CHAIN$HELP UVNDEG#L
  #IF (!0>0)
    #SET Q$ (!q+!1)
    CHAIN$HELP !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

#COMMAND CHARACTER &#%GULD "TO" #GRULCE .
  !A [] $248 !1 !3
#ENDCOMMAND

#COMMAND CLEAR_OPTION #LGRE . // Clears window options which
  #IFCLASS !1 _C           // have been set ON by set option
    #SET Q$ !1           // or by dfsetup.
    !A [] $04B |CI!q |CI0       // CLEAR_OPTION AUTORETURN
  #ELSE
    !A [] $04B !1 |CI0      // THIS COMMAND IS FOR INTERNAL USE.
  #ENDIF
#ENDCOMMAND

#COMMAND CLEARFORM &%CVFG#LE  "THRU""THROUGH""" %CVFG#LUE .
  #IF !0>0
    #IFDEF !1
      !A [] $1C3 !1 !3 |CI0
    #ELSE
      #CHECK !1.N _R#LGVU
      !A [] $1C3 !1.N |CI0
    #ENDIF
  #ELSE
    !A [] $1C3 |CI0
  #ENDIF
#ENDCOMMAND

#COMMAND CLEARSCREEN & .
  !A [] $144 !1
#ENDCOMMAND

#COMMAND CLEARWARNING &.
  !A [] $048
#ENDCOMMAND

#COMMAND CLEARXY &%#USGL %#USGLR .
  !A [] $146 !1 !2
#ENDCOMMAND

#COMMAND CLOSE_INPUT
  #IFSAME !1 CHANNEL
    !A [] $10A |CI0 !2
  #ENDIF
  !A [] $100 |CS'CON:'
#ENDCOMMAND

#COMMAND CLOSE_OUTPUT
  #IFSAME !1 CHANNEL
    !A [] $10A |CI1 !2
  #ENDIF
  !A [] $101 |CS'LST:'
#ENDCOMMAND

#COMMAND CMDLINE &#RLUGE .
  !A [] $24A !1 |CS''
#ENDCOMMAND

// With the name mangling code, we need a way to define external C messages.
// The CMSG command does just that. It uses the #FGEN command to parse over a special syntax
// that defines a prototype in this form:
//
// Example:  CMSG I GET_AUX_VALUE |CI$31 I
//
//      This generates in !? a name GET_AUX_VALUE@I if we mangle on the parameter list types
//      This generates in !? a name GET_AUX_VALUE@I@I if we mangle on the parameter list and return type
//      This generates in !? a name GET_AUX_VALUE@1 if we mangle on the number of the parameters
//
//           CMSG V GET_FOO       |CI$099   V
//
//      Returns GET_FOO_# and receives a variable argument list.
//

//#IFDEF MANGLE_NAMES
  #COMMAND CMSG RIND RIND RSND
    #IFNDEF !2
      #REPLACE !2 !3
    #ENDIF
  #ENDCOMMAND
//#ENDIF

#COMMAND COPYFILE &#LGU "TO" R#LGU .
  !A [] $2C5 !1 !3
#ENDCOMMAND

#COMMAND CONSTRAINT_SAVE_INIT .
  !A [] $0DE
#ENDCOMMAND

#COMMAND CONSTRAINT_SET R#LG """DELETE""CLEAR"
  #IFSAME !2 DELETE
    !A [] $0DA !1    // DELETE
  #ELSE
    #IFSAME !2 CLEAR
      !A [] $0DA !1    // DELETE FIRST
    #ENDIF
    !A [] $0D0 !1   // QUERY ID
  #ENDIF
#ENDCOMMAND

#COMMAND CONSTRAINT_VALIDATE .
  !A [] $0DF
#ENDCOMMAND

#COMMAND CONSTRAINT_INIT r r "BY" r // mode file by index
  #IFSAME !1 $0 $1 $2 $3 $4 $5
    #SET Q$ !1
    MOVE |CI!q TO INDEX_NUMBER
  #ELSE
    MOVE !1 TO INDEX_NUMBER
  #ENDIF
  #IFDEF !2
    !A [] $0D6 !2 !4    // VARIABLE FILE NUMBER
  #ELSE
    #SET Q$ !2.FILE_NUMBER   // FILE NAME ONLY
    !A [] $0D6 |CI!q !4
  #ENDIF
#ENDCOMMAND

#COMMAND CONSTRAINED_CLEAR
  #IF !0>0
    CONSTRAINT_INIT !1 !2 !3 !4
  #ENDIF
  !A [] $DC   // Find clear
#ENDCOMMAND

#COMMAND CONSTRAINED_FIND // MODE FILE by INDEX
  #IFSAME !1 NEXT
    #IF !0>1
      !A [] $0D0 !2   // QUERY ID
    #ENDIF
    !A [] $D8       // find NEXT
  #ELSE
    #IFSAME !1 FIRST
      CONSTRAINED_CLEAR GE !2 !3 !4
    #ELSE
      #IFSAME !1 LAST
        CONSTRAINED_CLEAR LE !2 !3 !4
      #ELSE
        #IF !0>0
          CONSTRAINT_INIT !1 !2 !3 !4
        #ENDIF
        // THIS USES RB DATA ,IT DOES NOT CLEAR THE rb.
      #ENDIF
    #ENDIF
    !A [] $D7  |CI0 // find init, sets found on status of constrained relates.
    !A [FOUND] $D8  // find NEXT (first)
  #ENDIF
#ENDCOMMAND

// JJT-5.1
//#COMMAND DATE TR
//  #NUM V$
//  #REPLACE !1 |VD!v
//  #IF (!0>1)
//    DATE !2 !3 !4 !5 !6 !7 !8 !9
//  #ENDIF
//#ENDCOMMAND

#COMMAND DEBUG &.
  !A [] $044
#ENDCOMMAND

#COMMAND DECREMENT #ELCRUG .
  #IFTYPE !1 "IV"
     !A [] $087 !1 |CI0
  #ELSE
     Move (!1 - 1) to !1
   #ENDIF
#ENDCOMMAND

#COMMAND DESPOOL &.  // O/S dependent function
  !A [] $2C6
#ENDCOMMAND

#COMMAND DIRECTORY &R#LGU .
  !A [] $2C4 !1
#ENDCOMMAND

#COMMAND DIRECT_INPUT
  #IFSAME !1 CHANNEL
    !A [] $10A |CI0 !2
    #IF !0>2
      DIRECT_INPUT !3 !4
    #ENDIF
  #ELSE
    #IFSAME !1 RESOURCE
      #IFDEF !2 // allow variable string for resource name/id
        DIRECT_INPUT ('!1:' + string(!2)) !3 !4 !5 !6 !7 !8 !9
      #ELSE
        #SET Q$ !2.RSC
        !A [] $100 |CS"!1:!q"
      #ENDIF
    #ELSE
      #IFSAME !1 DBMS IMAGE
        #IFSAME !1 IMAGE
          #IFDEF !2 // allow variable for image number
            DIRECT_INPUT ('!1:' + string(!2)) !3 !4 !5 !6 !7 !8 !9
          #ELSE
            #SET Q$ !2.N
            !A [] $100 |CS"!1:!q"
          #ENDIF
        #ELSE
          #IFCLASS !2 "F" // if field ref, use as is
            !A [] $100 |CS"!1:!2"
          #ELSE
            #IFDEF !2 // for all classes/types, assume variable string for field ref
              DIRECT_INPUT ('!1:' + string(!2)) !3 !4 !5 !6 !7 !8 !9
            #ELSE
              #CHECK !2 _U // force cannot be untyped error.
            #ENDIF
          #ENDIF
        #ENDIF
      #ELSE
        #CHECK !2 .
        !A [] $100 !1
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND DIRECT_OUTPUT
  #IFSAME !1 CHANNEL
    !A [] $10A |CI1 !2
    #IF !0>2
      DIRECT_OUTPUT !3 !4
    #ENDIF
  #ELSE
    #IFSAME !1 DBMS IMAGE
      #IFSAME !1 IMAGE
        #IFDEF !2 // allow variable for image number
          DIRECT_OUTPUT ('!1:' + string(!2)) !3 !4 !5 !6 !7 !8 !9
        #ELSE
          #SET Q$ !2.N
          !A [] $101 |CS"!1:!q"
        #ENDIF
      #ELSE
        #IFCLASS !2 "F" // if field ref, use as is
          !A [] $101 |CS"!1:!2"
        #ELSE
          #IFDEF !2 // for all classes/types, assume variable string for field ref
            DIRECT_OUTPUT ('!1:' + string(!2)) !3 !4 !5 !6 !7 !8 !9
          #ELSE
            #CHECK !2 _U // force cannot be untyped error.
          #ENDIF
        #ENDIF
      #ENDIF
    #ELSE
      #CHECK !2 .
      !A [] $101 !1
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND APPEND_OUTPUT
  #IFSAME !1 CHANNEL
    !A [] $10A |CI1 !2
    #IF !0>2
      APPEND_OUTPUT !3 !4
    #ENDIF
  #ELSE
    #IFSAME !1 DBMS IMAGE
      #IFSAME !1 IMAGE
        #IFDEF !2 // allow variable for image number
          APPEND_OUTPUT ('!1:' + string(!2)) !3 !4 !5 !6 !7 !8 !9
        #ELSE
          #SET Q$ !2.N
          !A [] $101 |CS"!1:!q" |CI2
        #ENDIF
      #ELSE
        #IFCLASS !2 "F" // if field ref, use as is
          !A [] $101 |CS"!1:!2" |CI2
        #ELSE
          #IFDEF !2 // for all classes/types, assume variable string for field ref
            APPEND_OUTPUT ('!1:' + string(!2)) !3 !4 !5 !6 !7 !8 !9
          #ELSE
            #CHECK !2 _U // force cannot be untyped error.
          #ENDIF
        #ENDIF
      #ENDIF
    #ELSE
      #CHECK !2 .
      !A [] $101 !1 |CI2
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND DISKFREE #LIDNRUG "TO" #LDRCUGE .
  !A [] $2d5 !3 !1
#ENDCOMMAND

#COMMAND DISPLAY RUG#L
  #IF !0>2
    #CHECK !2 "TO"
    #CHECK !3 _RGC#LE
    !A [] $1C2 !1 !3
    #IF !0>3
      #CHECK !4 _#LWFCV
      #FORMAT !3 !4
    #ENDIF
  #ELSE
    AUTO4$ DISPLAY !1 TO PAGE!f !2
  #ENDIF
#ENDCOMMAND

#COMMAND ELSE
  #$ !A [] $41 |CI0 //jump over else code.
  #XPOP !n S$ // GET GOTO LINE NUMBER FROM LAST IF.
  #XPUSH 1 !a // Save line number of ELSE jump.
  #XPUSH 0 !n // Save static nest level.
  #FREF (!a+1) !s // Modify goto line number with ELSE command
  !1 !2 !3 !4 !5 !6 !7 !8 !9
  #XPOP 0 Q$  // Restore static nest level to Q.
  #XPOP 1 S$  // Restore line number of else jump.
  #IF (!n>!q)
    #FREF END$!r !s // Modify ELSE jump to after BEGIN block.
  #ELSE
    #FREF (!a+1) !s // Modify ELSE jump to after the ELSE command.
  #ENDIF
#ENDCOMMAND

#COMMAND END &.
  #POP S$
  #IFDEF WHILE$!s
    !A [] $041 WHILE$!s
  #ENDIF
  END$!s:
  #SET N$ !n-1
#ENDCOMMAND

#COMMAND ENDGROUP &.
  //ENTUPDATE         // update record buffer
  !A [] $280 |CI0
  //GOTO ENT$END!x
  !A [] $41 |CL0
  #FREF ENT$END!x !a
  //RETURN            // RETURN stops entry command list
  !A [] $43 |CI0
  ENT$END!x:
#ENDCOMMAND

#COMMAND ENT$KEY
  ENT$DISP:
  IF ENTER$DISPLAY NE 0 BEGIN
    !A [FOUND] $042 ENTER$DISPLAY
  END
  ELSE BEGIN
    [FOUND] ENTDISPLAY // JUST DO AN ENTDISPLAY
  END
  //              ENTAGAIN
  !A [] $287
  //              RETURN
  !A [] $43 |CL0

  //<<<<<<< STANDARD KEY PROCEDURES FOR ENTER GROUP >>>>>>>>>>
  //KEYPROC KEY.FIND
  ENTER$.FIND:
  //              ENTFIND GE          // no, FIND
  !A [] $281 |CI3
  #KEYPROC 7 !a
  //              GOTO ENT$DISP
  !A [] $41 ENT$DISP

  //KEYPROC KEY.NEXT                  // FIND next record
  ENTER$.NEXT:
  //              ENTFIND GT
  !A [] $281 |CI4
  #KEYPROC 15 !a
  //              GOTO ENT$DISP
  !A [] $41 ENT$DISP

  //KEYPROC KEY.PREVIOUS              // FIND prv record
  ENTER$.PREVIOUS:
  //              ENTFIND LT
  !A [] $281 |CI0
  #KEYPROC 14 !a
  //              GOTO ENT$DISP
  !A [] $41 ENT$DISP
  //KEYPROC KEY.UP
  //KEYPROC KEY.FIELD                 // BACK FIELD
  ENTER$.FIELD:
  //              BACKFIELD
  !A [] $288
  #KEYPROC 16 !a
  #KEYPROC 6 !a
  //              RETURN
  !A [] $43 |CI0
  //KEYPROC KEY.CLEAR                 // CLEAR SCREEN
  ENTER$.CLEAR:
  //              INDICATE ERR FALSE
  !A [] $4028 |CI0 |CI0 |127
  #KEYPROC 13 !a
  !A []           $284 // ENTCLEAR
  //              RETURN
  !A [] $43 |CI0
  //KEYPROC KEY.SAVE
  ENTER$.SAVE:
  !A []           $285 // ENTSKIP
  #KEYPROC 9 !a
  //              RETURN
  !A [] $43 |CI0
  //KEYPROC KEY.HELP
  ENTER$.HELP:
  //HELP
  !A [] $1C5 |CI0
  #KEYPROC 18 !a
  //ENTAGAIN
  !A [] $287
  //RETURN
  !A [] $43 |CI0

  // KEYPROC KEY.PRINT
  ENTER$.PRINT:
  // output current page
  !A [] $202 |VI9
  #KEYPROC 2 !a
  //ENTAGAIN and RETURN
  !A [] $287
  !A [] $43 |CI0
#ENDCOMMAND

#REM ENTAGAIN can only be used in a KEY PROCedure. It returns to the
#REM same window (COMMAND) that called the KEY PROCedure.

#COMMAND ENTAGAIN &.
  !A [] $287
#ENDCOMMAND

// only works with recnum tables. Command not used in VDF
#COMMAND ENTDISPLAY &TVWG#LE .  // Display all entries for a file
  #IF (!0>0)
    //RELATE !1
    !A [] $C4 !1.RECNUM   // only works with recnum (obsolete)
  #ENDIF
  //display from entry section
  !A [] $283
#ENDCOMMAND

// This command has Not been changed to support file_number instead of recnum. This is not a VDF command and I
// cannot imagine how it could be used. However, if someone is using this, they can only use recnum tables. Updating this
// command would somehow imply that this command is supported in vdf -- it's not.
#COMMAND ENTER CVWSRL#E
  //              INDICATE CONTINUE TRUE
  #REPLACE CONTINUE |!C
  !A [] $4028 |CI0 |CI0 CONTINUE~
  //              INDICATE ENT$QUERY FALSE
  #REPLACE ENT$QUERY |9
  !A [] $4028 |CI0 |CI0 |9
  #IF !0>0            // ENT$QUERY tells us if
    #SET X$ !1.RECNUM           // we are in QUERY(SUPERFIND) mode
  #ELSE
    #SET X$ 0
  #ENDIF
  //MOVEINT |CI!x TO |VI8     // set ENTMFILE (ENTER's main file variable)
  !A [] $82 |CI!x |VI8        // to main file for ENTSFIND
  ENT$LP:             // start of enter loop
  //              GOSUB ENTRYSEC      // do ENTRY section
  !A [] $042 |CL0
  #FREF ENTRYSEC !a
  //[KEY.ESCAPE]      GOTO END_ENTER      // dropped thru
  !A [|103] $041 |CL0
  #FREF END_ENTER !a
  //              INDICATE ERR FALSE      // set error false
  !A [] $4028 |CI0 |CI0 |127
  // temp disable ON ERROR
  !A [] $82 |VI31 |VI32
  !A [] $82 |CI0 |VI31
  // REREAD command
  !A [] $0C9
  //[ENT$QUERY]       GOSUB ENTER.EDIT    // user procedure
  !A [|9] $042 |CL0
  #FREF ENTER.EDIT !a
  //[NOT ERR]         ENTUPDATE       // update files from ENTRY
  !A [~|127] $280 |CI0
  //[NOT ERR]         GOSUB ENTER.SAVE    // user procedure
  !A [~|127] $042 |CL0
  #FREF ENTER.SAVE !a
  [NOT ERR]       MULTIBACK$ SAVE !1 !2 !3 !4 !5 !6 !7 !8 !9  // save
  // UNLOCK command
  !A [] $0C8
  //[NOT ERR]         GOSUB ENT$CLEAR     // clear screen
  !A [~ |127] $042 |CL0
  #FREF ENT$CLEAR !a
  // RE ENABLE ON ERROR
  !A [] $82 |VI32 |VI31
  //[CONTINUE]        GOTO ENT$LP         // loop
  !A [CONTINUE] $041 ENT$LP
  //              GOTO END_ENTER      // end if NOT CONTINUE
  !A [] $041 |CL0
  #FREF END_ENTER !a
  // this clears the screen and all data files
  ENT$CLEAR:          MULTIBACK$ CLEAR !1 !2 !3 !4 !5 !6 !7 !8 !9
  //              INDICATE ENT$QUERY FALSE
  !A [] $4028 |CI0 |CI0 |9
  //              ENTCLEAR - clear ENTRY section
  !A [] $284
  //              RETURN
  !A [] $043 |CI0
  //<<<<<<< STANDARD KEY PROCEDURES FOR ENTER >>>>>>>>>>
  //KEYPROC KEY.SAVE
  ENTER$.SAVE:
  !A []           $285 //ENTSKIP (skip rest of entries)
  #KEYPROC 9 !a
  //              RETURN
  !A [] $043 |CI0
  //KEYPROC KEY.DELETE
  //              INDICATE ERR FALSE      //default
  ENTER$.DELETE:
  !A [] $4028 |CI0 |CI0 |127
  #KEYPROC 10 !a
  // DISABLE ON ERROR
  !A [] $82 |VI31 |VI32
  !A [] $82 |CI0 |VI31
  //              REREAD
  !A [] $C9
  //[NOT ENT$QUERY]   ERROR 71    // check for active record
  !A [~|9] $47 |CI71
  //[NOT ERR]         GOSUB ENTER.DELETE      // user procedure
  !A [~|127] $042 |CL0
  #FREF ENTER.DELETE !a
  //[NOT ERR]         GOSUB ENTER.EDIT    // user procedure
  !A [~|127] $042 |CL0
  #FREF ENTER.EDIT !a
  //[NOT ERR]         DELETE !1       // delete records
  !A [~|127] $C3 !1.RECNUM
  [NOT ERR]       MULTIBACK$ SAVE !2 !3 !4 !5 !6 !7 !8 !9 // related
  //              UNLOCK
  !A [] $C8
  //[NOT ERR]         GOSUB ENT$CLEAR       // clear systems
  !A [~|127] $042 ENT$CLEAR
  // enable ON ERROR
  !A [] $82 |VI32 |VI31
  //              RETURN ENTRYSEC
  !A [] $43
  #FREF ENTRYSEC !a
  // will GOSUB here for all find keys //
  //              INDICATE WAS$QUERY GROUP ANY [ENT$QUERY]
  ENTER$.FIND:
  #REPLACE WAS$QUERY |!C
  !A [] $4020 |GB[|9] |GB[0] WAS$QUERY IN$GLANY |3
  #KEYPROC 8 !a // SUPERFIND
  #KEYPROC 7 !a // FIND
  #KEYPROC 15 !a // NEXT
  #KEYPROC 14 !a // PREVIOUS
  //[KEY.SFIND]       INDICATE ENT$QUERY TRUE
  !A [|108] $4028 |CI0 |CI0 |9~
  //[NOT ENT$QUERY]   INDICATE ENT$QUERY AS |CI!x EQ |VI15    // query mode?
  !A [~ |9] $4008 |CI!x |VI15 |9 |2
  //[KEY.SFIND]         ENTSFIND GE
  !A [|108] $282 |CI3
  //[KEY.FIND][ENT$QUERY][ENT$PERMISSIVE] ENTFIND GE
  !A [|107 |9 |10] $281 |CI3
  //[KEY.FIND][ENT$QUERY][NOT ENT$PERMISSIVE] ENTSFIND GE   // yes, SUPERFIND
  !A [|107 |9 ~ |10] $282 |CI3
  //[KEY.FIND][NOT ENT$QUERY]     ENTFIND GE        // no, FIND
  !A [|107 ~ |9] $281 |CI3
  //[KEY.NEXT][ENT$QUERY]   ENTSFIND GT     // yes, SUPERFIND
  !A [|115 |9] $282 |CI4
  //[KEY.NEXT][NOT ENT$QUERY]     ENTFIND GT        // no, FIND
  !A [|115 ~ |9] $281 |CI4
  //[KEY.PREVIOUS][ENT$QUERY]     ENTSFIND LT       // yes, SUPERFIND
  !A [|114 |9] $282 |CI0
  //[KEY.PREVIOUS][NOT ENT$QUERY] ENTFIND LT        // no, FIND
  !A [|114 ~ |9] $281 |CI0
  [FINDERR]       INDCT$GROUP ENT$QUERY GROUP ANY [WAS$QUERY]
  //!A [FOUND]        $283            // display records
  !A [FOUND] $042 ENTER$DISPLAY
  //              ENTAGAIN        // same window
  !A [] $287
  //              RETURN
  !A [] $43 |CI0
  ////// define ENTER's KEY PROCedures ////////////
  // KEYPROC BACKFIELD
  //              BACKFIELD
  ENTER$.FIELD:
  !A [] $288
  #KEYPROC 16 !a
  #KEYPROC 6 !a
  ENTXRET://          RETURN
  !A [] $43 |CL0
  // KEYPROC CLEARSCREEN
  ENTER$.CLEAR:
  //              INDICATE ERR FALSE
  !A [] $4028 |CI0 |CI0 |127
  #KEYPROC 13 !a
  //              GOSUB ENTER.CLEAR
  !A [] $042 |CL0
  #FREF ENTER.CLEAR !a
  //[NOT ERR]         GOSUB ENT$CLEAR
  !A [~ |127] $042 ENT$CLEAR
  //              RETURN ENTRYSEC
  !A [] $043
  #FREF ENTRYSEC !a
  // KEYPROC ESCAPE key
  ENTER$.ESCAPE:
  //              INDICATE ERR FALSE
  !A [] $4028 |CI0 |CI0 |127
  #KEYPROC 3 !a
  //              GOSUB ENTER.EXIT
  !A [] $42 |CL0
  #FREF ENTER.EXIT !a
  //[NOT ERR]         RETURN ENTXRET
  !A [~ |127] $43 ENTXRET
  //              RETURN
  !A [] $43 |CI0
  //KEYPROC KEY.HELP
  //HELP
  ENTER$.HELP:
  !A [] $1C5 |CI0
  #KEYPROC 18 !a
  //ENTAGAIN
  !A [] $287
  //RETURN
  !A [] $43 |CI0
  //KEYPROC KEY.PRINT
  //output current page
  ENTER$.PRINT:
  !A [] $202 |VI9
  #KEYPROC 2 !a
  //ENTAGAIN and RETURN
  !A [] $287
  !A [] $43 |CI0

  ENTRYSEC://         ENTERMODE       // start entry section
  !A [] $82 |CI!a |VI14
  !A [] $286
#ENDCOMMAND

#COMMAND ENTEREND               // end of ENTER
  MAKEDEF$ ENTER.SAVE ENTER.EDIT ENTER.DELETE ENTER.CLEAR ENTER.EXIT
  //RETURN
  !A [] $43 |CI0
  #IFDEF ENTER.DISPLAY
  #ELSE
    ENTER.DISPLAY:
    ENTDISPLAY
    !A [] $43 |CI0
  #ENDIF
  END_ENTER:
  // CLEARSCREEN
  !A [] $144
#ENDCOMMAND

#COMMAND ENTERGROUP .   // independent entry section
  #IFDEF ENT$DISP
  #ELSE
    //INTEGER ENT$START
    INTEGER ENT$END
    //#$ GOTO ENTK$END
    #$ !A [] $41 |CL0
    #FREF ENTK$END !a
    #$ ENT$KEY
    #SET X$ 0
    ENTK$END:
  #ENDIF

  ENTRYSEC!X://       ENTERMODE       // start entry section
  !A [] $82 |CI!a |VI14
  !A [] $286
  //              INDICATE ENT$QUERY FALSE
  !A [] $4028 |CI0 |CI0 |9
#ENDCOMMAND

#REM ENTERMODE defines the top of the ENTRY section.

#COMMAND ENTERMODE &.
  //set start of ENTRY section
  !A [] $082 |CI!a  |VI14
  //clear SAVE key
  !A [] $286
#ENDCOMMAND

#REM ENTFIND FINDs a record based on the file/field of the last executed
#REM ENTRY command, and displays the results on a FIND. THE FIND mode
#REM is the only argument.
#REM ENTFIND also maintains the ENT$QUERY indicator.

#COMMAND ENTFIND &"$0""$1""$2""$3""$4""$5"
  !A [] $281 |CI!1
#ENDCOMMAND

#COMMAND ENTRY RWV#LUG UVC#LF UFVW#BC
  #IF !0=1
    AUTO3$ ENTRY !1 PAGE!f
  #ELSE
    #IFTYPE !2 "O"
      AUTO3$ ENTRY !1 PAGE!f !2
    #ELSE
      #CHECK !2 _RVCLE
      #IFCLASS !1 "E"
        !A [] $8000 !1 !2 {$C002,$C003 !3
      #ELSE
        !A [] $8000 !1 !2 !3
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

#REM ENTSFIND (SUPERFIND) FINDs a record in the main file, based on the
#REM file/field of the last ENTRY command, and displays the results.
#REM This depends on the main file number being in SYSINT 8 (|VI8).

#COMMAND ENTSFIND &"$0""$1""$2""$3""$4""$5" .
  !A [] $282 |CI!1
#ENDCOMMAND

#REM ENTUPDATE moves all changed windows from the
#REM window buffer to the record buffer

// only works with recnum tables. Command not used in VDF
#COMMAND ENTUPDATE &T .
  #IF !0>0
    !A [] $280 !1.RECNUM  // only works with recnum tables (obsolete command)
  #ELSE
    !A [] $280 |CI0
  #ENDIF
#ENDCOMMAND

#COMMAND ERASEFILE &R#LGU .
  !A [] $2C1 !1
#ENDCOMMAND

#COMMAND ERROR &#L%RGU #LUG .
  !A [] $047 !1 !2
#ENDCOMMAND

#COMMAND ERROR_REPORT SU#LGO .
  #IF !0>0
    !A [] $04C !1
  #ELSE
    !A [] $04C |CI0
  #ENDIF
#ENDCOMMAND

#COMMAND FIELD_DEF _E U#LG "TO" #LGUCE #LGRUEC .
  #IFDEF !1
    !A [] $82 !1 FILENUMBER
  #ELSE
    #CHECK !1.FILE_NUMBER _U
    #SET Q$ !1.FILE_NUMBER
    !A [] $82 |CI!q FILENUMBER
  #ENDIF
  !A [] $82 !2 FIELDNUMBER
  !A [] $345 !4 !5
#ENDCOMMAND

#COMMAND FILELIST &R#%LG "TO""" #LUGCE #LUCGE .
  #IFSAME !1 NEXT
    !A [] $301 !3 !4
  #ELSE
    #IFSAME !1 PATHNAME
      !A [] $302 !3 !4
    #ELSE
      #CHECK !1 _U
      !A [] $82 !1 FILENUMBER
      !A [] $300 !3 !4
    #ENDIF
  #ENDIF
#ENDCOMMAND

#REM Put back into FILELIST.  The file number must be in "FILENUMBER"
#REM Three values are: ROOT NAME, DISPLAY NAME, LOGICAL NAME.

#COMMAND FILELIST$PUT &#LRU #LRU #LU
  #IF !0>2
    !A [] $309 !3
  #ENDIF
  !A [] $30A !1 !2
#ENDCOMMAND

#COMMAND FILE$MODE$HELP R "READ_ONLY""SINGLE_USER""ALIAS""MASTER_ALIAS""DEFAULT" .
//  #CHECK !1.RECNUM _CVWLR#GU
  #IFSAME !2 READ_ONLY
        SET_ATTRIBUTE DF_FILE_ALIAS OF FILENUMBER TO DF_FILE_ALIAS_DEFAULT
        !A [] $0CB INDIRECT_FILE.RECNUM |CI91
  #ELSE
    #IFSAME !2 SINGLE_USER
      SET_ATTRIBUTE DF_FILE_ALIAS OF FILENUMBER TO DF_FILE_ALIAS_DEFAULT
      !A [] $0CB INDIRECT_FILE.RECNUM |CI7
  #ELSE
      #IFSAME !2 DEFAULT
        !A [] $0CB INDIRECT_FILE.RECNUM |CI0
        SET_ATTRIBUTE DF_FILE_ALIAS OF FILENUMBER TO DF_FILE_ALIAS_DEFAULT
      #ELSE
        #IFSAME !2 ALIAS
          !A [] $0CB INDIRECT_FILE.RECNUM |CI130
          SET_ATTRIBUTE DF_FILE_ALIAS OF FILENUMBER TO DF_FILE_IS_ALIAS
        #ELSE
          #IFSAME !2 MASTER_ALIAS
            !A [] $0CB INDIRECT_FILE.RECNUM |CI128
            SET_ATTRIBUTE DF_FILE_ALIAS OF FILENUMBER TO DF_FILE_IS_MASTER
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND FILE_MODE
  //#IFSAME !1 |FS0,0& |FN0,0& |FD0,0&
  // This supports both Indirect_file and Indirect_file.Recnum -JJT
  #IFSAME !1.FILE_NUMBER |FS0,0& |FN0,0& |FD0,0& |FS0,0&.RECNUM
  #ELSE
    #SET Q$ !1.FILE_NUMBER
    !A [] $82 |CI!q FILENUMBER
  #ENDIF
  FILE$MODE$HELP !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#REM FILE$MODE <FILE> <MODE NUMBER>
#REM    MODE VALUES (VALUES ARE ADDITIVE)
#REM    1   NO AUTOMATIC REREAD OF RECORD BUFFERS.
#REM    2   NO LOCKS (LOCK OR REREAD)
#REM    4   NO RE-READ OF BLOCK ZERO OF DATA FILE OR INDEXES
#REM    8   NO EDITS OF ACTIVE RECORDS (ERROR 66)
#REM    16  NO DELETES OF RECORDS (ERROR 63)
#REM    32  NO FINDS (ERROR 64)
#REM    64  NO CREATES OF NEW RECORDS. (ERROR 65)
#REM    128 ALWAYS RE_READ BLOCK 0
#REM Warning; Improper combinations of the above could disable
#REM multiuser checking and destroy the data base.
#REM 8 Thru 64 are non destructive and can be used in applications.
#REM FOR EXPERTS ONLY!

// see Old_open command for notes on this removal
//#COMMAND FILE$MODE RT #LGSU .
//  #CHECK !1.RECNUM _RULG
//  !A [] $0CB !1.RECNUM !2
//#ENDCOMMAND

#COMMAND FILE_SIZE R#LGSD "TO" R#LGE #LUGE #LGUE .
  #IFDEF !1 // SET FILE SIZE
    #CHECK !3.FILE_NUMBER _RU
    #SET Q$ !3.FILE_NUMBER
    !A [] $343 |CI!q !1
  #ELSE
    #CHECK !1.FILE_NUMBER _U
    #SET Q$ !1.FILE_NUMBER
    !A [] $82 |CI!q FILENUMBER
    !A [] $341 !3 !4
    !A [] $82 STRMARK !5
  #ENDIF
#ENDCOMMAND

#COMMAND FIND &"$0""$1""$2""$3""$4""$5" R "BY""" % .
  #IFCLASS !2 "F"
    #CHECK !2 _U#LGWV
    #CHECK !3 .
    !A [] $0C0 !2 |CI!1
  #ELSE
    #CHECK !2.FILE_NUMBER _U#LGWV
    #CHECK !4 _RUL#GVFW
    #SET Q$ !2.FILE_NUMBER
    #SET Y$ !4
    !A [] $0C6 |FS!q.!y |CI!1
  #ENDIF
#ENDCOMMAND

#COMMAND FIND$PAGE "AT""COLORS""" #LUG U#LG .
  #IF !0>0
    #IFSAME !1 AT
      !A [] $1C8 !2 !3
    #ELSE
      #IFSAME !1 COLORS
        !A [] $1C9 !2 !3
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

#REM  FLEX$INIT - STANDARD REPLACES
#REM  These are the standard symbols that are required for the compiler
#REM  This procedure will be automatically executed
#REM  when the compiler starts

#COMMAND FLEX$INIT &.
  #REPLACE CALC CALCULATE
  #REPLACE LT $0  // internal value for the find/indicate modes.
  #REPLACE LE $1
  #REPLACE EQ $2
  #REPLACE GE $3
  #REPLACE GT $4
  #REPLACE NE $5
//  #REPLACE TRUE $1
//  #REPLACE FALSE $0
  #REPLACE TRUE  |CZ1   // changed to bit constants so we can use true or false in
  #REPLACE FALSE |CZ0   // any command (e.g. move true to bStat). Also required change in indicate
  #REPLACE NOT ~
  #SET C$ 11
  #REPLACE LASTIF |!C
  #REPLACE ENT$PERMISSIVE |10
  #REPLACE IN$0 $4000
  #REPLACE IN$1 $4004
  #REPLACE IN$2 $4008
  #REPLACE IN$3 $400C
  #REPLACE IN$4 $4010
  #REPLACE IN$5 $4014
  #REPLACE IN$GLANY |0
  #REPLACE IN$GLALL |4
  #REPLACE IN$GRANY |0
  #REPLACE IN$GRALL |2
  #REPLACE IN$GMOR  |0
  #REPLACE IN$GMAND |1
  #REPLACE ERR |127
  #REPLACE ERRLINE |VI6
  #REPLACE LAST_CRIT_ERR |VI102
  #REPLACE EXT_CRIT_ERR |VI103
  #REPLACE CONSTRAIN_TESTS_COUNT |VI106
  #REPLACE CONSTRAIN_FOUND_COUNT |VI107
  #REPLACE FINDERR |126
  #REPLACE SEQEOF |125
  #REPLACE SEQEOL |121
  #REPLACE MULTIUSER |120
  #REPLACE FIELDINDEX |VI1
  #REPLACE WINDOWINDEX |VI2
  #REPLACE LASTERR |VI5
  #REPLACE KEYPRESS |123
  #REPLACE TERMCHAR |VI3
  #REPLACE FLEXKEY |VI4
  #REPLACE SCREENEND |VI17
  #REPLACE MEMAVAIL |VI18
  #REPLACE LASTENTRY |VI19
  #REPLACE FLX_REVISION |VI36
  #REPLACE ENTER$DISPLAY |VI38
  #REPLACE NOKEYCHECK |VI80
  #REPLACE CHAIN_DEPTH |VI81
  #REPLACE CURSOR_SET |VI82 // THESE ARE USED BY AUTOBACK
  #REPLACE CURSOR_RETURN |VI83
  #REPLACE MINIMUM_MEMORY |VI86
  #REPLACE INDEX_NUMBER |VI90
  #REPLACE SCREEN_WIDTH |VI91
  #REPLACE KEY.ANY  |100
  #REPLACE KEY.RETURN   |101
  #REPLACE KEY.PRINT    |102
  #REPLACE KEY.ESCAPE   |103
  #REPLACE KEY.LEFT |104
  #REPLACE KEY.RIGHT    |105
  #REPLACE KEY.FIELD    |106
  #REPLACE KEY.FIND |107
  #REPLACE KEY.SFIND    |108
  #REPLACE KEY.SAVE |109
  #REPLACE KEY.DELETE   |110
  #REPLACE KEY.CALCULATE |111
  #REPLACE KEY.USER |112
  #REPLACE KEY.CLEAR    |113
  #REPLACE KEY.NEXT |115
  #REPLACE KEY.PREVIOUS |114
  #REPLACE KEY.UP   |116
  #REPLACE KEY.DOWN |117
  #REPLACE KEY.HELP |118
  #REPLACE KEY.USER2    |119
  #REPLACE NUMPAGE  |VI28
  #REPLACE NUMWINDOW    |VI29
  #REPLACE #$
  #SET F$ 1
  #REPLACE NEXT_MENU |VI127
  #REPLACE CURRENT_IMAGE |VI9
  #REPLACE CURRENT_WINDOW |VI7
  #REPLACE LAST_GOSUB |VI0
  #REPLACE FOUND |254
  #REPLACE STRMARK |VI12
  #REPLACE STRLEN |VI13
  //   ENTER & REPORT DEF'S
  #REPLACE LINECOUNT |VI10
  #REPLACE PAGECOUNT |VI11
  #REPLACE PAGEEND |VI25
  #REPLACE PAGEFEED |VI26
  #SET D$ 128   // INTEGERS NOW START HERE.
  #SET P$ 0
  #REPLACE AUTOFIND $C000
  #REPLACE AUTOFIND_GE $C000,$C008
  #REPLACE FINDREQ  $C001
  #REPLACE NOPUT    $C002
  #REPLACE NOENTER  $C003
  #REPLACE SKIPFOUND $C004
  #REPLACE RETAINALL $C005
  #REPLACE RETAIN    $C006
  #REPLACE FORCEPUT $C007
  #REPLACE DISPLAYONLY $C002,$C003
  #REPLACE CAPSLOCK $C023
  #REPLACE ZERO_SUPPRESS $C024
  #REPLACE THOUSANDS $C025
  #REPLACE SUPPRESS $C040=''
  #REPLACE FLOAT$ $C026
  #REPLACE UPPER $C023
  #REPLACE SIGNRT $C027
  #REPLACE CHECK $C012
  #REPLACE RANGE $C013
  #REPLACE REQUIRED $C022
  #REPLACE AUTORETURN $C028
  #REPLACE AUTOBACK   $C029
  #REPLACE NO_CALC    $C02B   // Disable Calculate (internal)
  #REPLACE MODAL_INSERT $C02A // Change insert style (internal)
  #REPLACE AUTOCLEAR $C02D
  #REPLACE WP_BACKSP $C02E
  #REPLACE PAGEBREAK |124
  #REPLACE FILL $C040
  #REPLACE POINTS $C080
  #REPLACE FILENUMBER |VI15
  #REPLACE FIELDNUMBER |VI16
  #REPLACE INDEX.1 |CI1   // the indexes are just integers.
  #REPLACE INDEX.2 |CI2
  #REPLACE INDEX.3 |CI3
  #REPLACE INDEX.4 |CI4
  #REPLACE INDEX.5 |CI5
  #REPLACE INDEX.6 |CI6
  #REPLACE INDEX.7 |CI7
  #REPLACE INDEX.8 |CI8
  #REPLACE INDEX.9 |CI9
  #REPLACE INDEX.10 |CI10
  #REPLACE INDEX.11 |CI11
  #REPLACE INDEX.12 |CI12
  #REPLACE INDEX.13 |CI13
  #REPLACE INDEX.14 |CI14
  #REPLACE INDEX.15 |CI15
  #REPLACE INDEX.BATCH |CI10
  #REPLACE RECNUM |CI0
  #REPLACE EXPORT_FILES 1
  #REPLACE EXPORT_ONLY 2
  #REPLACE SEQ_EXPORT 4
  #REPLACE INDIRECT_FILE.RECNUM |FS0,0&
  // note we are defining indirect_file.file_number so one can use indirect_file directly. Note that this
  // technique (any use of indirect_file in any form) is not a recommended technique because there are API commands
  // to do anything it does. Therefore, we will not create yet another way to use indirect_file.
  #REPLACE INDIRECT_FILE.FILE_NUMBER |FS0,0&
  #REPLACE DESKTOP |CI2
  #REPLACE END_FUNCTION END_PROCEDURE
  #REPLACE PROCEDURE_RETURN FUNCTION_RETURN

  #REPLACE TOTAL_RESOURCES |VI104

    // video related replaces
  #REPLACE BW40 0
  #REPLACE C40  1
  #REPLACE BW80 2
  #REPLACE C80  3
  #REPLACE MONO 7
  #REPLACE EXTENDED_EGAVGA 64
  #REPLACE EXTENDED_VGA    128

  // API Constants
  #REPLACE DFERR_ERROR   |CI-1
  #REPLACE DF_SUCCESS    |CI0
  #REPLACE DFFALSE       |CI0
  #REPLACE DFTRUE        |CI1

  // DataFlex driver specific constants
  #REPLACE FLEX_SET_MAX_SORT_BUFFER             |CI1
  #REPLACE FLEX_GET_MAX_SORT_BUFFER             |CI2
  #REPLACE FLEX_REPAIR_FILE                     |CI3
  #REPLACE FLEX_GET_REPAIRS_NEEDED              |CI4
  #REPLACE FLEX_SET_INDEX_OPT                   |CI5
  #REPLACE FLEX_GET_INDEX_OPT                   |CI6
  #REPLACE FLEX_GET_STRICT_TRANSACTIONS         |CI7
  #REPLACE FLEX_SET_STRICT_TRANSACTIONS         |CI8

    // DataFlex specific file damage types
  #REPLACE FLEX_HEADER_OK             |CI0
  #REPLACE FLEX_BLOCK0_BAD            |CI1
  #REPLACE FLEX_HEADER_BAD            |CI2
  #REPLACE FLEX_HEADER_INTEGRITY_OFF  |CI4
  #REPLACE FLEX_HEADER_UNREADABLE     |CI8

  // Index optimization modes
  #REPLACE FLEX_INDEX_OPT_ON          |CI1
  #REPLACE FLEX_INDEX_OPT_PERMISSIVE  |CI2
  #REPLACE FLEX_INDEX_OPT_OFF         |CI3

  // Flex revision codes (for use with DF_FILE_REVISION)
  #REPLACE FLEX_REVISION_23   |CS"2.3B"
  #REPLACE FLEX_REVISION_30   |CS"3.0"


  // Attributes: Runtime
  #REPLACE DF_RUNTIME_PROGRESS_FREQUENCY |CI4097

  // Attributes: Global
  #REPLACE DF_LOCK_DELAY                        |CI1
  #REPLACE DF_LOCK_TIMEOUT                      |CI2
  #REPLACE DF_OPEN_PATH                         |CI3
  #REPLACE DF_DATE_FORMAT                       |CI4
  #REPLACE DF_DATE_SEPARATOR                    |CI5
  #REPLACE DF_DECIMAL_SEPARATOR                 |CI6
  #REPLACE DF_THOUSANDS_SEPARATOR               |CI7
  #REPLACE DF_ALL_FILES_TOUCHED                 |CI8
  #REPLACE DF_HIGH_DATA_INTEGRITY               |CI9
  #REPLACE DF_TRAN_COUNT                        |CI10
  #REPLACE DF_TRANSACTION_ABORT                 |CI11
  #REPLACE DF_REREAD_REQUIRED                   |CI12
  #REPLACE DF_FILELIST_NAME                     |CI13
  #REPLACE DF_REPORT_UNSUPPORTED_ATTRIBUTES     |CI14
  #REPLACE DF_STRICT_ATTRIBUTES                 |CI15
  #REPLACE DF_NUMBER_DRIVERS                    |CI16
  #REPLACE DF_DRIVER_NAME                       |CI17
  #REPLACE DF_DRIVER_NUMBER_SERVERS             |CI18
  #REPLACE DF_DRIVER_SERVER_NAME                |CI19
  #REPLACE DF_API_DISABLED                      |CI20
  #REPLACE DF_API_DISABLED_ERROR                |CI21
  #REPLACE DF_TRANABORT_ONERROR                 |CI22
  #REPLACE DF_OPEN_FILE_COUNT                   |CI23
  #REPLACE DF_DATE_4_STATE                      |CI24
  #REPLACE DF_EPOCH_VALUE                       |CI25
  #REPLACE DF_SYSDATE_4_STATE                   |CI26
  #REPLACE DF_NUMBER_FILES_SUPPORTED            |CI27



  // Attributes: File
  #REPLACE DF_FILE_STATUS	      |CI101
  #REPLACE DF_FILE_MODE               |CI102
  #REPLACE DF_FILE_MAX_RECORDS	      |CI103
  #REPLACE DF_FILE_RECORDS_USED	      |CI104
  #REPLACE DF_FILE_TYPE               |CI105
  #REPLACE DF_FILE_MULTIUSER	      |CI106
  #REPLACE DF_FILE_REUSE_DELETED      |CI107
  #REPLACE DF_FILE_NUMBER             |CI108
  #REPLACE DF_FILE_COMPRESSION	      |CI109
  #REPLACE DF_FILE_LAST_INDEX_NUMBER  |CI110
  #REPLACE DF_FILE_NUMBER_FIELDS      |CI111
  #REPLACE DF_FILE_LOGICAL_NAME	      |CI112
  #REPLACE DF_FILE_ROOT_NAME	      |CI113
  #REPLACE DF_FILE_CHANGED            |CI114
  #REPLACE DF_FILE_ALIAS              |CI115
  #REPLACE DF_FILE_TOUCHED            |CI116
  #REPLACE DF_FILE_TRANSACTION	      |CI117
  #REPLACE DF_FILE_OPENED             |CI118
  #REPLACE DF_FILE_DISPLAY_NAME       |CI119
  #REPLACE DF_FILE_PHYSICAL_NAME      |CI120
  #REPLACE DF_FILE_NEXT_OPENED	      |CI121
  #REPLACE DF_FILE_NEXT_USED	      |CI122
  #REPLACE DF_FILE_NEXT_EMPTY	      |CI123
  #REPLACE DF_FILE_RECORD_LENGTH      |CI124
  #REPLACE DF_FILE_RESTRUCTURE	      |CI125
  #REPLACE DF_FILE_OPEN_MODE	      |CI126
  #REPLACE DF_FILE_INTEGRITY_CHECK    |CI127
  #REPLACE DF_FILE_OWNER              |CI128
  #REPLACE DF_FILE_IS_SYSTEM_FILE     |CI129
  #REPLACE DF_FILE_LOCK_TYPE          |CI130
  #REPLACE DF_FILE_COMMITTED          |CI131
  #REPLACE DF_FILE_DRIVER             |CI132
  #REPLACE DF_FILE_RECORD_LENGTH_USED |CI133
  #REPLACE DF_FILE_HANDLE_TYPE        |CI134
  #REPLACE DF_FILE_RECORD_IDENTITY    |CI135
  #REPLACE DF_FILE_LOGIN              |CI136
  #REPLACE DF_FILE_RECORD_PRIVILEGE   |CI137 // PRIVATE, DO NOT USE
  #REPLACE DF_FILE_PRIVILEGE          |CI138 // PRIVATE, DO NOT USE
  #REPLACE DF_FILE_CREATION_SERIAL    |CI139 // PRIVATE, DO NOT USE
  #REPLACE DF_FILE_REVISION           |CI140
  #REPLACE DF_FILE_RELATED_COUNT      |CI141 // PRIVATE, DO NOT USE
  #REPLACE DF_FILE_RELATED_FIELDS     |CI142 // PRIVATE, DO NOT USE
  #REPLACE DF_FILE_SYSTEM_FILE        |CI143
  #REPLACE DF_FILE_SYSTEM_FIELD       |CI144
  #REPLACE DF_FILE_RECORD_REREAD      |CI145
  #REPLACE DF_FILE_RECNUM_TABLE       |CI1401
  #REPLACE DF_FILE_PRIMARY_INDEX      |CI1402


  // Attributes: Fields

  #REPLACE DF_FIELD_NUMBER	      |CI201
  #REPLACE DF_FIELD_TYPE	      |CI202
  #REPLACE DF_FIELD_LENGTH	      |CI203
  #REPLACE DF_FIELD_PRECISION	      |CI204
  #REPLACE DF_FIELD_RELATED_FILE      |CI205
  #REPLACE DF_FIELD_RELATED_FIELD     |CI206
  #REPLACE DF_FIELD_NAME	      |CI207
  #REPLACE DF_FIELD_INDEX	      |CI208
  #REPLACE DF_FIELD_OFFSET	      |CI209
  #REPLACE DF_FIELD_OLD_NUMBER	      |CI210
  #REPLACE DF_FIELD_OVERLAP           |CI211
  #REPLACE DF_FIELD_NATIVE_LENGTH     |CI212

  // Attributes: Index
  #REPLACE DF_INDEX_NUMBER_SEGMENTS     |CI301
  #REPLACE DF_INDEX_NUMBER_BUFFERS      |CI302
  #REPLACE DF_INDEX_TYPE                |CI303
  #REPLACE DF_INDEX_LEVELS              |CI304
  #REPLACE DF_INDEX_KEY_LENGTH          |CI305

  // Attributes: Index Segments
  #REPLACE DF_INDEX_SEGMENT_DIRECTION   |CI401
  #REPLACE DF_INDEX_SEGMENT_CASE        |CI402
  #REPLACE DF_INDEX_SEGMENT_FIELD       |CI403
  // Attributes: Driver
  #REPLACE DF_DRIVER_CONFORMANCE        |CI1201


  // Date types
  #REPLACE DF_DATE_USA           |CI0
  #REPLACE DF_DATE_EUROPEAN      |CI1
  #REPLACE DF_DATE_MILITARY      |CI2

  // Callback Types
  #REPLACE DF_MESSAGE_TEXT            |CI0
  #REPLACE DF_MESSAGE_HEADING_1       |CI1
  #REPLACE DF_MESSAGE_HEADING_2       |CI2
  #REPLACE DF_MESSAGE_HEADING_3       |CI3
  #REPLACE DF_MESSAGE_HEADING_4       |CI4
  #REPLACE DF_MESSAGE_HEADING_5       |CI5
  #REPLACE DF_MESSAGE_WARNING         |CI6
  #REPLACE DF_MESSAGE_PROGRESS_TITLE  |CI7
  #REPLACE DF_MESSAGE_PROGRESS_VALUE  |CI8

  // Aux file types
  #REPLACE DF_AUX_FILE_FD      |CI0
  #REPLACE DF_AUX_FILE_DEF     |CI1

  // File status values
  #REPLACE DF_FILE_INACTIVE       |CI0
  #REPLACE DF_FILE_ACTIVE         |CI1
  #REPLACE DF_FILE_ACTIVE_CHANGED |CI2

  // File user values
  #REPLACE DF_FILE_USER_SINGLE  |CI0
  #REPLACE DF_FILE_USER_MULTI   |CI1

  // File deleted values
  #REPLACE DF_FILE_DELETED_NOREUSE  |CI0
  #REPLACE DF_FILE_DELETED_REUSE    |CI1

  // Compressions types
  #REPLACE DF_FILE_COMPRESS_NONE        |CI0
  #REPLACE DF_FILE_COMPRESS_FAST        |CI1
  #REPLACE DF_FILE_COMPRESS_STANDARD    |CI2
  #REPLACE DF_FILE_COMPRESS_CUSTOM      |CI3

  // File alias
  #REPLACE DF_FILE_ALIAS_DEFAULT        |CI0
  #REPLACE DF_FILE_IS_MASTER            |CI1
  #REPLACE DF_FILE_IS_ALIAS             |CI2

  // File handle types
  #REPLACE DF_FILE_HANDLE_BAD                   |CI0
  #REPLACE DF_FILE_HANDLE_CLOSED                |CI1
  #REPLACE DF_FILE_HANDLE_OPENED                |CI2
  #REPLACE DF_FILE_HANDLE_EXISTING_RESTRUCTURE  |CI3
  #REPLACE DF_FILE_HANDLE_NEW_RESTRUCTURE       |CI4

  // File transaction types
  #REPLACE DF_FILE_TRANSACTION_NONE             |CI0
  #REPLACE DF_FILE_TRANSACTION_CLIENT_ATOMIC    |CI1
  #REPLACE DF_FILE_TRANSACTION_SERVER_ATOMIC    |CI2
  #REPLACE DF_FILE_TRANSACTION_SERVER_LOGGED    |CI3

  // Types of restructure required
  #REPLACE DF_NO_RESTRUCTURE            |CI0
  #REPLACE DF_RESTRUCTURE_FILE          |CI1
  #REPLACE DF_RESTRUCTURE_INDEX         |CI2
  #REPLACE DF_RESTRUCTURE_BOTH          |CI3

  // File touched attribute
  #REPLACE DF_FILE_NOT_TOUCHED         |CI48
  #REPLACE DF_FILE_TOUCHED_INACTIVE    |CI49
  #REPLACE DF_FILE_TOUCHED_ACTIVE      |CI50

  #REPLACE DF_FILEMODE_ORIGINAL    -1 // only valid for smart_filemode in data sets
  #REPLACE DF_FILEMODE_DEFAULT     0
  #REPLACE DF_FILEMODE_NO_REREAD   1
  #REPLACE DF_FILEMODE_NO_LOCKS    2
  #REPLACE DF_FILEMODE_NO_EDITS    8
  #REPLACE DF_FILEMODE_NO_DELETES  16
  #REPLACE DF_FILEMODE_NO_FINDS    32
  #REPLACE DF_FILEMODE_NO_CREATES  64
  #REPLACE DF_FILEMODE_READONLY    91
  #REPLACE DF_FILEMODE_SINGLE_USER 3

  // File closing type
  #REPLACE DF_PERMANENT 0
  #REPLACE DF_TEMPORARY 1

  // File locking types
  #REPLACE DF_LOCK_TYPE_NONE     |CI0
  #REPLACE DF_LOCK_TYPE_FILE     |CI1
  #REPLACE DF_LOCK_TYPE_RECORD   |CI2

  // Modes for openning a file.
  #REPLACE DF_SHARE               |CI0
  #REPLACE DF_EXCLUSIVE           |CI1

  // Index types
  #REPLACE DF_INDEX_TYPE_ONLINE   |CI0
  #REPLACE DF_INDEX_TYPE_BATCH    |CI1

  // Segment case used?
  #REPLACE DF_CASE_USED     |CI0
  #REPLACE DF_CASE_IGNORED  |CI1

  // Segment direction
  #REPLACE DF_ASCENDING     |CI0
  #REPLACE DF_DESCENDING    |CI1

  // Field Types
  #REPLACE DF_ASCII      |CI0
  #REPLACE DF_BCD        |CI1
  #REPLACE DF_DATE       |CI2
  #REPLACE DF_OVERLAP    |CI3
  #REPLACE DF_TEXT       |CI5
  #REPLACE DF_BINARY     |CI6
  #REPLACE DF_DATETIME   |CI7

  // dfStructureEnd Option bits
  #REPLACE DF_STRUCTEND_OPT_NONE       |CI0
  #REPLACE DF_STRUCTEND_OPT_FORCE      |CI1
  #REPLACE DF_STRUCTEND_OPT_RECOMPRESS |CI2
  #REPLACE DF_STRUCTEND_OPT_IN_PLACE   |CI4

  #REPLACE DF_SORT_OPTION_NONE             |CI0
  #REPLACE DF_SORT_OPTION_NO_DATA_CHECK    |CI8
  #REPLACE DF_SORT_OPTION_BAD_DATA_FIXUP   |CI16
  #REPLACE DF_SORT_OPTION_BAD_DATA_FILE    |CI32
  #REPLACE DF_SORT_OPTION_BAD_DATA_ABORT   |CI64
  #REPLACE DF_SORT_OPTION_DUP_DATA_FILE    |CI128
  #REPLACE DF_SORT_OPTION_DUP_DATA_ABORT   |CI256

  // Field fill types
  #REPLACE DF_HIGH     |CI0
  #REPLACE DF_LOW      |CI1

  // Resource Types
  // DAC reservers the negative values, you may use the positive values,
  // 0 means uninitialized or error.
  #REPLACE DF_RESOURCE_TYPE_ERROR     |CI0  // if resource is invalid
                                            // or uninitialized.
  #REPLACE DF_RESOURCE_TYPE_BINARY    |CI-1 // use this with include_resource for
                                            // bitmaps and other binary files.
  #REPLACE DF_RESOURCE_TYPE_LINE      |CI-2 // default type for resources.

  // These symbols are passed to the SYSCONF function to determine
  // which OS specific item is returned.
  #REPLACE SYSCONF_TIMER_RESOLUTION     |CI0
  #REPLACE SYSCONF_DIR_SEPARATOR        |CI1
  #REPLACE SYSCONF_OS_SHORT_NAME        |CI2
  #REPLACE SYSCONF_OS_MAJOR_REV         |CI3
  #REPLACE SYSCONF_OS_MINOR_REV         |CI4
  #REPLACE SYSCONF_OS_NAME              |CI5
  #REPLACE SYSCONF_MACHINE_NAME         |CI6
  #REPLACE SYSCONF_FILE_MASK            |CI7
  #REPLACE SYSCONF_DATAFLEX_REV         |CI8
  #REPLACE SYSCONF_SYSTEM_NAME          |CI9
  #REPLACE SYSCONF_PATH_SEPARATOR       |CI10
  #REPLACE SYSCONF_RUNTIME_NAME         |CI11
  #REPLACE SYSCONF_UTC_TIME_OFFSET      |CI12

  // Subsystem numbers
  #REPLACE DF_CMD_SUBSYSTEM_REV    |CI5
  #REPLACE DF_UI_SUBSYSTEM_REV     |CI1
  #REPLACE DF_DS_SUBSYSTEM_REV     |CI1

  #REPLACE DF_CMD_SUBSYSTEM    |CI0
  #REPLACE DF_UI_SUBSYSTEM     |CI1
  #REPLACE DF_DS_SUBSYSTEM     |CI2

  #REPLACE DF_NUMBER_SUBSYSTEMS |CI3

  #REPLACE ENUM_LIST ENUMERATION_LIST
  #REPLACE END_ENUM_LIST END_ENUMERATION_LIST

  //
  // Date Constants
  //
  #REPLACE DATE4_STATE    |CI0
  #REPLACE EPOCH_VALUE    |CI1
  #REPLACE SYSDATE4_STATE |CI2

  // These are values to be used by the raw file commands
  // representing different file permission bits
  #REPLACE DF_FLEX_UID_EXECUTE   |CI1024  //04000
  #REPLACE DF_FLEX_GID_EXECUTE   |CI512   //02000
  #REPLACE DF_FLEX_OWNER_READ    |CI256   //00400
  #REPLACE DF_FLEX_OWNER_WRITE   |CI128   //00200
  #REPLACE DF_FLEX_OWNER_EXECUTE |CI64    //00100
  #REPLACE DF_FLEX_GROUP_READ    |CI32    //00040
  #REPLACE DF_FLEX_GROUP_WRITE   |CI16    //00020
  #REPLACE DF_FLEX_GROUP_EXECUTE |CI8     //00010
  #REPLACE DF_FLEX_WORLD_READ    |CI4     //00004
  #REPLACE DF_FLEX_WORLD_WRITE   |CI2     //00002
  #REPLACE DF_FLEX_WORLD_EXECUTE |CI1     //00001
  #REPLACE DF_FLEX_ALL_RIGHTS    |CI20471

  // Error Codes used by the Compiler
  #REPLACE DFERR_COMP_BAD_IMAGE_NAME                 |CI4293
  #REPLACE DFERR_COMP_CONSTANT_EXPECTED              |CI4299
  #REPLACE DFERR_COMP_ILLEGAL_RETURN_TYPE            |CI4310
  #REPLACE DFERR_COMP_IMAGE_NOT_FOUND                |CI4311
  #REPLACE DFERR_COMP_INVALID_DATATYPE               |CI4315
  #REPLACE DFERR_COMP_INVALID_TYPE                   |CI4317
  #REPLACE DFERR_COMP_MISSING_ARGUMENT               |CI4320
  #REPLACE DFERR_COMP_MISSING_END_OBJECT             |CI4323
  #REPLACE DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT   |CI4328
  #REPLACE DFERR_COMP_SYMBOL_ALREADY_DEFINED         |CI4332
  #REPLACE DFERR_COMP_TOO_MANY_MESSAGES              |CI4339
  #REPLACE DFERR_COMP_UNRESOVLED_CONTROL_BLOCK       |CI4348

  #REPLACE DFERR_COMP_ILLEGAL_OBJECT_DEFINTION       |CI4388 // object name used is not valid
  #REPLACE DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION     |CI4389 // property name cannot be used
  #REPLACE DFERR_COMP_ILLEGAL_METHOD_DEFINTION       |CI4390 // method name cannot be used
  #REPLACE DFERR_COMP_ILLEGAL_CODE_PLACEMENT         |CI4391 // Location of code, nesting, is wrong
  #REPLACE DFERR_COMP_INVALID_METHOD_SYNTAX          |CI4392 // syntax is incorrect for method definition
  #REPLACE DFERR_COMP_INVALID_MESSAGE_SYNTAX         |CI4393 // sysntax is incorrect for sending message
  #REPLACE DFERR_COMP_INVALID_OBJECT_REFERENCE       |CI4394 // object named in message is invalid
  #REPLACE DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE   |CI4395 // Obsolete - was 101 (Moveused by fmac)
  #REPLACE DFERR_COMP_INVALID_ARGUMENT               |CI4396 // Agument in line is incorrect
  #REPLACE DFERR_COMP_ILLEGAL_EXTERNAL_FUNCTION_DEFINITION |CI4397 // name cannot be used
  //
  #REPLACE DFERR_COMP_MISSING_DEBUG_INFORMATION      |CI4500 // debug information is not provided
  #REPLACE DFERR_COMP_INCOMPATIBLE_DEBUG_INFORMATION |CI4501 // debug inforamtion is is not correct
  #REPLACE DFERR_COMP_RECURSIVE_STRUCT_DECLARATION   |CI4513 // recursive struct definition
  #REPLACE DFERR_COMP_AMBIGUOUS_SYNTAX.              |CI4514 // either Left of "'[' is not array, use '(' if indicator" or "Left of '.' is not of type struct or table"

  // constants used by rich edit class
  #REPLACE FR_WHOLEWORD 2
  #REPLACE FR_MATCHCASE 4

  #REPLACE SCF_ALL       4
  #REPLACE SCF_SELECTION 1
  #REPLACE SCF_WORD      2
  #REPLACE SCF_DEFAULT   0

  #REPLACE ERR_RE_ATTR_INCONSISTENT_THROUGH_SELECTION |CI40001
  #REPLACE ERR_RE_SUCCESS                             |CI0
  #REPLACE ERR_RE_CANNOT_SETTEXT                      |CI40002
  #REPLACE ERR_RE_CONVERSION_CODEPAGE                 |CI40003
  #REPLACE ERR_RE_FNAME_TOO_LONG                      |CI40004
  #REPLACE ERR_RE_CANNOT_OPEN_FILE                    |CI40005




  // Error handler may return source information as "Source = module.function". This is the
  // text that returned from the runtime that contains this information.
  #REPLACE C_ErrorContextSourceText |CS"Source ="

  #SET  N$ 2 // save 0,1 stacks for IF/ELSE
  #SET ZR$ 0 // for compile-time-assigned resource_ids
  #SET ZS$ 0 // for enumerated lists
  #SET ZT$ 0 //  "       "       "
  #XPUSH !n $INIT

// Note that for this build of FMAC the subsystems are the same for character mode
// and windows.

  #CHKSUB 0 6  // Verify the General Flex subsystem. Version 0 of command system. Revision 4.
               // This was changed from 0 3 to 0 4 to force recompilation of programs from 3.1 to 3.2.
               // And changed from 0 5 to force recompilation when we changed the size of the argument and command line.
               // And changed from 0 6 to force recompilation on 7.1.13 build.
#ENDCOMMAND

#COMMAND FOR &ECFWGSNR#LU "FROM" %UGLR# "TO""" %UGL# .
  // we do iftype checks because the command checking does not understand A and K
  #IFTYPE !1 "K"
    #ERROR 4345 "!1, Struct not allowed"
  #ELSE
    #IFTYPE !1 "A"
      #ERROR 4345 "!1, Array not allowed"
    #ELSE
      #SET N$ !N
      #PUSH !R
      #XPUSH !n $INIT
      //MOVEINT !3 TO !1
      !A [] $082 !3 !1
      #IF (!0>3)
        // IF !1 LE !5 GOTO FOR$!r
        !A [] $4004 !1 !5 |11 |2
        !A [|11] $041 |CL0
        #FREF FOR$!r !a
      #ENDIF
      #$ !A 0 0 0 $041 |CL0
      #FREF END$!r !a
      #$ BEGIN$!r:
      #$ WHILE$!r:
      #IF !0=3
        #$ !A [] $083 !1
      #ELSE
        #$ !A [] $083 !1 !5
        #$ !A [|122] $041 |CL0
        #FREF END$!r !a
      #ENDIF
      FOR$!r:
    #ENDIF
  #ENDIF
#ENDCOMMAND

// FORMAT window {}
// FORMAT window THRU window {}

#COMMAND FORMAT RUVCFL#G
  #IF !0>2
    FORMAT$RANGE !1 !2 !3 !4 !5
  #ELSE
    #CHECK !2 _RVCFWL#BE
    #CHECK !3 .
    #FORMAT !1 !2
  #ENDIF
#ENDCOMMAND

#COMMAND FORMAT$RANGE ERUVCFL#G "THRU""THROUGH" ERUVCFL#G RVCFWL#B .
  #FORMAT !1 !4
  #IF (!1<!3)
    #SET Q$ !1
    FORMAT$RANGE |WS!Q THRU !3 !4
  #ENDIF
#ENDCOMMAND

#COMMAND FORMFEED &.    // just like PAGECHECK 500
  !A [] $203 |CI500 |CI0
#ENDCOMMAND

#COMMAND GET_ARGUMENT_SIZE "TO" _RUDCE#LGB .
  !A [] $24F !2
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      GET_CHANNEL_SIZE channelNumber TO integerVariable
//
//   Descrtiption:
//      A command to retrieve the "size" of a sequential device (opened with
//      direct_input). Warning, devices that do not support the concept of
//      "size" (such as LST:) report an error.
//
//   Parmeters:
//       channelNumber
//            Number of a valid (open) channel.
//       integerVariable
//            Variable to return the channel size to. If the channel is not
//            open, 0 is returned.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND GET_CHANNEL_SIZE #LRUG$ "TO" #LRUG$EC .
  !A [] $111 !1 !3
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      GET_RESOURCE_TYPE resourceName|resourceId TO integerVariable
//
//   Descrtiption:
//      A command to retrieve the type of a resource at runtime. (Note: the
//      resource type is set a compile-time.) For the first parameter, you may
//      pass either the resource name (not in quotes) or the integer value of
//      the resource id.
//
//   Parmeters:
//       resourceName
//            Name of a resource.
//       resourceId
//            Integer value of a resource id. (The resource name is just a
//            symbolic replacement (with a .RSC suffix) of a constant integer
//            equal to the resource id.)
//       integerVariable
//            Variable to return the resource type to.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND GET_RESOURCE_TYPE _R TO %#USGLR
  #IFDEF !1
    !A [] $112 !1 !3
  #ELSE
    !A [] $112 !1.RSC !3
  #ENDIF
#ENDCOMMAND

#COMMAND GET_CURRENT_COLORS "TO" _RUDCE#LGB _RUDCE#LGB .
  !A [] $14E !2 !3
#ENDCOMMAND

#COMMAND GET_CURRENT_DIRECTORY "TO" _RUDCE#LGB .
  !A [] $2D1 !2
#ENDCOMMAND

#COMMAND GET_CURRENT_INPUT_CHANNEL "TO" _RUDCE#LGB .
  !A [] $10D !2
#ENDCOMMAND

#COMMAND GET_CURRENT_LOCKCOUNT "TO" _RUDCE#LGB .
  !A [] $0E6 !2
#ENDCOMMAND

#COMMAND GET_CURRENT_OUTPUT_CHANNEL "TO" _RUDCE#LGB .
  !A [] $10E !2
#ENDCOMMAND

#COMMAND GET_CURRENT_USER_COUNT "TO" _RUDCE#LGB .
  !A [] $2DB !2
#ENDCOMMAND

#COMMAND GET_DATE_FORMAT "TO" _RUDCE#LGB .
  !A [] $2D8 !2
#ENDCOMMAND

#COMMAND GET_ENVIRONMENT &RD#GOBLU "TO" _RCEUGOB# .
  !A [] $2CF !1 !3
#ENDCOMMAND

#COMMAND GET_LICENSED_MAX_USERS "TO" _RUDCE#LGB .
  !A [] $2DA !2
#ENDCOMMAND

#COMMAND GET_NUMBER_FORMAT "TO" _RUDCE#LGB .
  !A [] $2D9 !2
#ENDCOMMAND

#COMMAND GETXY #USGLR #USGLR .
  !A [] $14D !1 !2
#ENDCOMMAND

#COMMAND GOSUB &RVFWSNDE#G .
  #IFDEF !1
    !A [] $042 !1
  #ELSE
    !A [] $042 |CL0
    #FREF !1 !a
  #ENDIF
#ENDCOMMAND

#COMMAND GOTO &RVFWSNDE#G .
  #IFDEF !1
    !A [] $041 !1
  #ELSE
    !A [] $041 |CL0
    #FREF !1 !a
  #ENDIF
#ENDCOMMAND

#COMMAND GOTOXY &%#USGL %#USGLR .
  !A [] $145 !1 !2
#ENDCOMMAND

#COMMAND HELP &T .
  #IF !0>0
    #CHECK !1.N _U
    !A [] $1C5 !1.N
  #ELSE
    !A [] $1C5 |CI0
  #ENDIF
#ENDCOMMAND

#COMMAND IF LR
  #IFSAME !1 ~
    IFNOT !2 !3 !4 !5 !6 !7 !8 !9
  #ELSE
    #IFLOGICAL !1 // added to 12.0 to support indicators outside of expressions
      IF (!1) !2 !3 !4 !5 !6 !7 !8 !9  // if indicator, place it within an expression
    #ELSE
      #IFSAME !1 STATUS
        INDCT$STATUS LASTIF STATUS !2
        IF$HELP !3 !4 !5 !6 !7 !8 !9
      #ELSE
        #IFSAME !2 $0 $1 $2 $3 $4 $5 MATCH IN
          INDCT$AS LASTIF AS !1 !2 !3
          IF$HELP  !4 !5 !6 !7 !8 !9
        #ELSE
          #IFCLASS !1 "G"
            INDCT$GROUP LASTIF GROUP ALL !1
          #ELSE
            INDCT$AS LASTIF AS !1
          #ENDIF
          IF$HELP !2 !3 !4 !5 !6 !7 !8 !9
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND IFNOT LR
  #IFSAME !1 ~
    IF !2 !3 !4 !5 !6 !7 !8 !9
  #ELSE
    #IFLOGICAL !1 // added to 12.0 to support indicators outside of expressions
      IFNOT (!1) !2 !3 !4 !5 !6 !7 !8 !9  // if indicator, place it within an expression
    #ELSE
      #IFSAME !1 STATUS
        INDCT$STATUS LASTIF~ STATUS !2
        IF$HELP !3 !4 !5 !6 !7 !8 !9
      #ELSE
        #IFSAME !2 $0 $1 $2 $3 $4 $5 MATCH IN
          INDCT$AS LASTIF~ AS !1 !2 !3
          IF$HELP  !4 !5 !6 !7 !8 !9
        #ELSE
          #IFCLASS !1 "G"
            INDCT$GROUP LASTIF~ GROUP ALL !1
          #ELSE
            INDCT$AS LASTIF~ AS !1
          #ENDIF
          IF$HELP !2 !3 !4 !5 !6 !7 !8    !9
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

// note that IF_ and IFNOT_ are private and old. They do not work in all
// cases. For example, "If_ Indicator" will not work. Use IF
#COMMAND IF_ LR // THIS IF_ WILL NOT WORK WITH ELSE!
  #IFSAME !1 ~
    IFNOT_ !2 !3 !4 !5 !6 !7 !8 !9
  #ELSE
    #IFSAME !1 STATUS
      INDCT$STATUS LASTIF STATUS !2
      [LASTIF] !3 !4 !5 !6 !7 !8 !9
    #ELSE
      #IFSAME !2 $0 $1 $2 $3 $4 $5 MATCH IN
        INDCT$AS LASTIF AS !1 !2 !3
        [LASTIF] !4 !5 !6 !7 !8 !9
      #ELSE
        #IFCLASS !1 "G"
          INDCT$GROUP LASTIF GROUP ALL !1
        #ELSE
          INDCT$AS LASTIF AS !1
        #ENDIF
        [LASTIF] !2 !3 !4 !5 !6 !7 !8 !9
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND IFNOT_ LR // THIS IFNOT_ WILL NOT WORK WITH ELSE!
  #IFSAME !1 ~
    IF_ !2 !3 !4 !5 !6 !7 !8 !9
  #ELSE
    #IFSAME !1 STATUS
      INDCT$STATUS LASTIF~ STATUS !2
      [LASTIF] !3 !4 !5 !6 !7 !8 !9
    #ELSE
      #IFSAME !2 $0 $1 $2 $3 $4 $5 MATCH IN
        INDCT$AS LASTIF~ AS !1 !2 !3
        [LASTIF] !4 !5 !6 !7 !8 !9
      #ELSE
        #IFCLASS !1 "G"
          INDCT$GROUP LASTIF~ GROUP ALL !1
        #ELSE
          INDCT$AS LASTIF~ AS !1
        #ENDIF
        [LASTIF] !2 !3 !4 !5 !6 !7 !8 !9
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND IF$HELP
  !A [~LASTIF] $41 |CI0   // If LASTIF is false jump to end of IF command.
  #XPUSH 1 !a     // Save line number of jump at static nesting level.
  #XPUSH 0 !n     // Save nesting level in stack 0.
  !1 !2 !3 !4 !5 !6 !7 !8 !9
  #XPOP 0 Q$      // Restore nesting level into Q.
  #XPOP  1 S$     // Restore IF JUMP line number
  #XPUSH !q !s        // Push it back for the ELSE.
  #IF (!n>!q)     // after a begin
    #FREF END$!r !s    // Make IF JUMP goto end of begin block.
  #ELSE       // same or lower nesting level
    #FREF (!a+1) !s    // Make IF JUMP goto end of the IF.
  #ENDIF
#ENDCOMMAND

#COMMAND IFCHANGE R R
  #IFDEF !1
    #CHECK !1 _RFCVGE
    !A [] $1C6 !1
  #ELSE
    #CHECK !1.FILE_NUMBER _URWGV
    !A [] $303 !1.FILE_NUMBER // should work with filename or indirect_file (which is obsolete)
  #ENDIF
  [|122] !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      INCLUDE_RESOURCE fileName AS resourceName {TYPE resourceType}
//
//   Descrtiption:
//      A command to include (embed) a file as a resource.
//
//   Parmeters:
//       fileName
//            Name of a file (NOT in quotes) to include. May include a path.
//       resourceName
//            Name of the resource (NOT in quotes).
//       resourceType
//            A constant integer (or a symbolic replacement for a constant
//            integer) that is recorded in the .flx to indicate the type of
//            resource. If omitted, DF_RESOURCE_TYPE_LINE is assumed. You
//            uase any positive value for user-defined types. Do NOT use
//            0. 0 means the resource is uninitialized (registered, but not
//            included.) DAC reserves the negative values.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND INCLUDE_RESOURCE _TR "AS" _R """TYPE" _%USNVLE#
  #IF (!0>3)
    #SET Q$ !5 // specified type.
  #ELSE
    #SET Q$ DF_RESOURCE_TYPE_LINE // default to line.
  #ENDIF
  #IFDEF !3.RSC
    #RESOURCE !1 !3.RSC !q $0  // re-register resource; $0 = already named (just
  #ELSE                    // setting resource filename and type).
    #REPLACE !3.RSC |CI!ZR // create unique resource id.
    #RESOURCE !1 !Zr !q !3 // register new resource.
  #ENDIF
#ENDCOMMAND

#COMMAND INCREMENT #ELCRUG .
  #IFTYPE !1 "IV"
     !A [] $083 !1 |CI0
  #ELSE
     Move (!1 + 1) to !1
   #ENDIF
#ENDCOMMAND

#COMMAND INDCT$$0 &
  !A [] $4028 |CI0 |CI0 !1 !3
#ENDCOMMAND

#COMMAND INDCT$$1 &RX R .
  !A [] $4028 |CI0 |CI0 !1~ !3
#ENDCOMMAND

#COMMAND INDCT$AS //&RX "AS" LU "$0""$1""$2""$3""$4""$5""MATCH""IN""" #LUG .
  #IF (!0<4)
    #IFCLASS !3 "G"
      #CHECK !4 ""     // INDICATE IND1 AS IND2
      #CHECK !3 _SNDI#LO
      !A [] $4020 !3 |GB[0] !1 |3
    #ELSE

      // If here we've got either a single variable if
      //    If Var .... <or>
      //    If (Var)
      //
      // Not all data types are supported in this format and the compiler will create an error if
      // you pick the wrong one.
      //
      // Those Allowed are: Real, Number, Date, String, Integer, Boolean, Short, UShort, Char, UChar, Address
      //
      // Those not Allowed are: Float, Decimal, Currency, Time, DateTime, TimeSpan, Variant, BigInt, UBigInt, UInteger
      //
      // This was changed for 8.3. Prior to 8.3 types which were not supported (e.g. float) compiled but did not work.
      // Now you get an error message at compile time. Also, address types which did not work now are allowed and work properly.
      //
      // Struct and arrays can only be used if they are members (e.g. not MyIntArray, but MyIntArray[1]; not MyStruct, but MyStruct.bMem)
      // and if the member is within an expression (e.g. not MyIntArray[1], but (MyIntArray[1]) ).
      // In addition you cannot use deprecated "If X[1] EQ Y[1]" syntax with structs and arrays. You must use expressions "if (x[1]=y[1])"

      // INDICATE IND AS X
      #CHECK !3 _U
      // compare real 0 against real
      #IFTYPE  !3 "R"
        !A [] IN$5 !3 |CR0 !1 |3
      #ELSE
        // compar number 0 for date and number
        #IFTYPE  !3 "ND"
          !A [] IN$5 !3 |CN0 !1 |1
        #ELSE
          // compare integer 0 for integer, Long(?), Boolean, UBigint, UInteger, UShort, BigInt, Short, Char, UChar, Address
          // prior to 8.3 this was "ILZOQGVUWCYH". In 8.3 we removed currency (O) and decimal (Q), BigInt (H), UBigInt (G), UInteger (V), added address (X)
          #IFTYPE !3 "ILZUWCYX"
            !A [] IN$5 !3 |CI0 !1 |2
          #ELSE
            // compare string "" against string
            #IFTYPE !3 "S"
              !A [] IN$5 !3 |CS"" !1 |0
            #ELSE
              // if type is a struct or array, we cannot use this. One of two types of errors
              #IFTYPE !3 "KA"
                #IFCLASS !3 "E"
                  // if within an expression, it must be returning the entire struct or array which cannot be evaludated
                  #ERROR DFERR_COMP_INVALID_TYPE "The expression returns a struct or array. This cannot used for logical evaluation."
                #ELSE
                  // if not an expression. This could be a non-member which is never allowed.
                  // or it might be a member which requires parenthesis. eg: "if Var.bMem" should be "if (Var.bMem)"
                  #ERROR DFERR_COMP_INVALID_TYPE "Structs and Arrays must be members and can only be evaluated within an expression. Use (bVars[x]) or (Var.bMem)"
                #ENDIF
              #ELSE
                // types of BigInt, UBingInt, UInteger, time, timedate, float, currency, decimal, variant and timespan cannot be used directly in expression or as variables.
                // They can be used inside of a boolean expression. So you can not do "If fFloatVar" or "If (fFloatVar)" but you can do
                // "If (fFloatVar<>0)" instead. We don't support variant types because at compile time we just don't know what kind of data they
                // will contain.
                #IFTYPE !3 "TMFOPQJHGV"
                  #ERROR DFERR_COMP_INVALID_TYPE "The variable data-type is not valid for logical evaluation. Use (var<>0)"
                #ELSE
                  #CHECK !3 _O
                  !A [] $4020 !3 |GB[0] !1 IN$GLALL |3
                #ENDIF
              #ENDIF
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ELSE
    #CHECK !5 _R
    #IFSAME !4 MATCH
      !A [] $4031 !3 !5 !1 !6
    #ELSE
      #IFSAME !4 IN
        !A [] $4030 !3 !5 !1 !6
      #ELSE
        #CHECK !3 _U

        // If here we've got either a old style if statement
        //    If Var NE Xxxx <or>
        //    If Var EQ Var
        //
        // First of all note that this is a deprecated style and not all of the newer types are supported. If we
        // find an invalid type in either side of the comparison, we will generate a compiler error
        //
        // Those Allowed are: Real, Number, Date, String, Integer, Boolean, Short, UShort, Char, UChar, Address
        //
        // Those not Allowed are: Float, Decimal, Currency, Time, DateTime, TimeSpan, Variant, BigInt, UBigInt, UInteger
        //                        Struct or Arrays (even members of a valid data-type)
        //
        // This was changed for 8.3 and this may generate new compiler errors. That's good as it is catching errors.

        // note that the order of these are important.
        #IF2TYPE !3 !5 "TMFOPQJHGVAK"  // bad guys are: time, datetime, timespan, float, currency, decimal, variant, BigInt, UBigInit, UInteger, Struct, Array
          #ERROR DFERR_COMP_INVALID_TYPE "One or both comparision variable datatypes are not valid for logical evaluation. Use (var<>xx)"
        #ELSE
          #IF2TYPE  !3 !5 "R"  // real
            !A [] IN!4 !3 !5 !1 !6 |3
          #ELSE
            #IF2TYPE  !3 !5 "ND" // number, date
              #IF2TYPE !3 !5 "X" // cannot compare address to number/date.
                #ERROR DFERR_COMP_INVALID_TYPE "You cannot compare an address to a number or a date"
              #ELSE
                !A [] IN!4 !3 !5 !1 !6 |1
              #ENDIF
            #ELSE
              // #IF2TYPE !3 !5 "IL" // pre-8.3 it was this (we let just about everything act as string, which did not work)
              #IF2TYPE !3 !5 "ILZUWCYX" // integer, (long), boolean, Short, uShort, Char, UChar, Address
                !A [] IN!4 !3 !5 !1 !6 |2
              #ELSE
                !A [] IN!4 !3 !5 !1 !6 |0  // if nothing else, string
              #ENDIF
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND INDCT$GROUP &XR "GROUP" R"ALL""ANY" CVFWSN#LRU "AND""OR""" "ANY""ALL""" CVFWSN#LU .
  #IF !0>4
    #CHECK !7 _R
    !A [] $4020 !4 !7 !1 IN$GL!3 IN$GR!6 IN$GM!5
  #ELSE
    !A [] $4020 !4 |GB[0] !1 IN$GL!3 |3
  #ENDIF
#ENDCOMMAND

#COMMAND INDCT$STATUS &R R #LWV
  #IFDEF !3
    !A [] $4029 !3 |CI0 !1 !4
  #ELSE
    #CHECK !3.FILE_NUMBER _U#LWV
    #SET Q$ !3.FILE_NUMBER
    !A [] $4029 |CI!q |CI0 !1 !4
  #ENDIF
#ENDCOMMAND

#COMMAND INDEX_DEF R R#LGU "TO" #LGRNDCE #LGNDCE #LGNDCE
  #IFDEF !1
    !A [] $82 !1 FILENUMBER
  #ELSE
    #CHECK !1.FILE_NUMBER _UE
    #SET Q$ !1.FILE_NUMBER
    !A [] $82 |CI!q FILENUMBER
  #ENDIF
  !A [] $344 !2 !4 // index fields
  #IF !0>4
    !A [] $82 STRLEN !5 // number of fields
    #IF !0>5
      !A [] $349 !2 !6 // index attributes
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND INDICATE R
  #IFSAME !1 ~
    #IFDEF !2
    #ELSE
      #REPLACE !2 |!C
    #ENDIF
    INDICATE !2~ !3 !4 !5 !6 !7 !8 !9
  #ELSE
    // #CHECK !2 "AS""STATUS""$0""$1""GROUP"
    #IFDEF !1
      #CHECK !1 _X
    #ELSE
      #REPLACE !1 |!C
    #ENDIF
    // INDCT$!2 !1 !2 !3 !4 !5 !6 !7 !8 !9 // old logic

    // Logic changed to handle true/false defined as constants instead of $0 $1
    // False is |CZ0, dfFalse is |CI0. If either, use $0.
    // True  is |CZ1, dfTrue  is |CI1 If either, use $1.
    #IFSAME !2 false dfFalse
      INDCT$$0 !1 $0 !3 !4 !5 !6 !7 !8 !9 // special command for Indicate !1 False
    #ELSE
      #IFSAME !2 true dftrue
         INDCT$$1 !1 $1 !3 !4 !5 !6 !7 !8 !9  // special command for Indicate !1 True
      #ELSE
         INDCT$!2 !1 !2 !3 !4 !5 !6 !7 !8 !9  // old fashion command uses !2 to assemble the command
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND INDICATOR RT
  #REPLACE !1 |!C
  #IF (!0>1)
    INDICATOR !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

#COMMAND INHERIT_SCREEN &.
  !A [] $14B
#ENDCOMMAND

#COMMAND INKEY #LUCRE &.
  !A [] $147 !1
#ENDCOMMAND

#COMMAND INKEY$ #LUCRE &.
  !A [] $149 !1
#ENDCOMMAND

#COMMAND INPUT &#ULGR #LUG #ULG .
  #IFCLASS !1 "C"
    #CHECK !2 _RCLUEG _RCLUG
    //move 0 to strmark
    !A  [] $086 |CI0 |VI12
    !A [] $142 !1
    // INPUT !2 !3
    !A [] $140 !2 !3 |CI79
  #ELSE
    #CHECK !1 _RCLUEG
    !A [] $140 !1 !2 |CI79
  #ENDIF
#ENDCOMMAND

#COMMAND INSERT #LGR "IN" #LGRCE "AT"""
  #IF (!0>3)
    #CHECK !5 _#LGR%
    //MOVEINT !5 TO STRMARK
    !A [] $82 !5 STRMARK
  #ENDIF
  !A [] $24C !3 !1
#ENDCOMMAND

//JJT-5.1
//#COMMAND INTEGER TR
//  // ALLOW FOR MORE INTS
//  #REPLACE !1 |VI!D
//  #IF (!0>1)
//    INTEGER !2 !3 !4 !5 !6 !7 !8 !9
//  #ENDIF
//#ENDCOMMAND

#COMMAND IS_FILE_INCLUDED R R "TO"""
  !A [] $E0 !1 !2
  #IF !0>2
    #CHECK !4 _CUEGRL
    MOVE (FOUND) TO !4
  #ENDIF
#ENDCOMMAND

#COMMAND KEYCHECK
  !A [] $046
  #IF !0>0
    [KEYPRESS] !1 !2 !3 !4 !5 !6 !7 !8
  #ENDIF
#ENDCOMMAND

#COMMAND KEYPROC &R%WVF """GOSUB" WFVNSD# .
  #IFSAME !1 ON
    !A [] $82 |CI0 |VI33
  #ELSE
    #IFSAME !1 OFF
      !A [] $82 |CI9999 |VI33
    #ELSE
      #SET Y$ !a
      #IF (!0>1)
        // MOVEINT ADR(3) TO KEY LOC
        #SET Q$ (!1-100+40) // address in SYSINT
        #IFDEF !3
          !A [] $082 !3 |VI!q
        #ELSE
          !A [] $082 |CI0 |VI!q
          #FREF !3 !a
        #ENDIF
      #ELSE
        #SET Q$ (!1-100)
        #KEYPROC !q !Y
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND LEFT &#UGL$ "TO" #UEGRLC L#% .
  #IF !0>3
    !A [] $082 !4 STRMARK
  #ENDIF
  !A [] $241 !1 !3
#ENDCOMMAND

#COMMAND LENGTH &#LUG$ "TO" C#LREUG .
  !A [] $246 !1 !3
#ENDCOMMAND

#COMMAND LOCK &.
  !A [] $0C7
#ENDCOMMAND

#COMMAND LOOP &.
  #POP S$
  #CHECK BEGIN$!s _RVFWSNDEU
  !A [] $041 BEGIN$!s
  END$!s:
  #SET N$ !n-1
#ENDCOMMAND

#COMMAND MAKEDEF$   // make a list of symbols defined
  #IF !0>0
    #IFDEF !1
    #ELSE
      !1:
    #ENDIF
    #IF !0>1
      MAKEDEF$ !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND MAKE_FILE RU#LG U#LG U#LG U#LG .
  !A [] $34A !4
  #IF !0>2
    !A [] $82 !3 FILENUMBER
  #ELSE
    !A [] $82 |CI0 FILENUMBER
  #ENDIF
  #IF !0>1
    !A [] $346 !1 !2
  #ELSE
    !A [] $346 !1 |CS''
  #ENDIF
#ENDCOMMAND

#COMMAND MEMORY #LRCUGE &.
  !A [] $2CA !1
#ENDCOMMAND

#COMMAND MID &#UGL$ "TO" #UGRLEC #L%U #L% .
  #IF !0>4
    !A [] $082 !5 STRMARK
  #ENDIF
  !A [] $082 !4 STRLEN
  !A [] $245 !1 !3
#ENDCOMMAND

#REM  The type of a move is determined at compile time, based on the
#REM  type of the destination.  The move type refers to the intermediate
#REM  value to which the source will be converted.

//JJT-5.1
//#COMMAND MOVE #LU "TO" #GLEURC .
//  #IFCLASS !1 "G"  // MOVE INDICATOR
//    #CHECK !1 _VWFC
//    !A [] $4020 !1 |GB[0] !3 IN$GLALL |3
//  #ELSE
//// Type independent move as of 2.3
//    !A  [] $086 !1 !3
//  #ENDIF
//#ENDCOMMAND

#COMMAND MOVEDATE &%#GULI "TO" #UCIGERL .
  !A [] $084 !1 !3
#ENDCOMMAND

#COMMAND MOVEINT &%#GULD "TO" #UCSDEGRL .
  !A [] $082 !1 !3
#ENDCOMMAND

#COMMAND MOVENUM &#ULG "TO" #UCLGREL .
  !A [] $081 !1 !3
#ENDCOMMAND

#COMMAND MOVEREAL &#ULG "TO" #UCLGER .
  !A [] $085 !1 !3
#ENDCOMMAND

#COMMAND MOVESTR &#ULG$ "TO" #UCLGR$E .
  !A [] $080 !1 !3
#ENDCOMMAND

#COMMAND MULTI$     // repeat a command for each argument (internal)
  #IF !0>1
    !1 !2
  #ENDIF
  #IF !0>2
    MULTI$ !1 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

#COMMAND MULTIBACK$ // same as above, except that arguments
  #IF !0>2        // are output in reverse order
    MULTIBACK$ !1 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
  #IF !0>1
    !1 !2
  #ENDIF
#ENDCOMMAND

#COMMAND NAME R#L T
  #IFDEF !1
    #REPLACE !2 !1
    #CHECK !3 .
  #ELSE
    #IFCLASS !1.1 "W"
      AUTOPAGE !1
    #ELSE
      AUTO3$ #REPLACE !1 PAGE!f
    #ENDIF
    #IF !0>1
      NAME !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF
#ENDCOMMAND

// JJT-5.1
//#COMMAND NUMBER TR
//  #NUM V$
//  #REPLACE !1 |VN!v
//  #IF (!0>1)
//    NUMBER !2 !3 !4 !5 !6 !7 !8 !9
//  #ENDIF
//#ENDCOMMAND

#COMMAND ON R "GOTO""GOSUB""OFF" SNOBIODE
  #IFSAME !1 ERROR
    // MOVEINT ADDR to ONERROR (|VI31)
    #IFDEF !3
      !A [] $082 !3 |VI31
      #CHECK !2 "GOSUB"
    #ELSE
      !A [] $082 |CI0 |VI31
      #IFSAME !2 GOSUB
        #FREF !3 !a
      #ELSE
        #CHECK !2 "OFF"
      #ENDIF
    #ENDIF
  #ELSE
    #SET Q$ (!0-1)
    // INDICATE OK$1 AS !1 GT 0
    #IFDEF OK$1
    #ELSE
    #REPLACE OK$1 |!C
    #REPLACE OK$2 |!C
    #ENDIF
    #CHECK !1 _#ULGRS
    !A [] $4010 !1 |CI0 OK$1 |2
    // INDICATE OK$2 AS !1 LT !q
    !A [] $4000 !1 |CI!q OK$2 |2
    #SET Q$ (!a+2)
    #IFSAME !2 GOTO
    !A [OK$1 OK$2] $041 |CE(!q+!1 )
    #ELSE
    !A [OK$1 OK$2] $042 |CE(!q+!1 )
    #ENDIF
    #SET Q$ (!a+!0)
    !A [] $041 |CL!q  //ERROR jump around GOTOs
    MULTI$ GOTO !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND


#REM OS$CALL makes a system BDOS call.  Only calls that can be passed
#REM integer (not pointer) values can be used.  Use at your own risk!
#REM Format of command:
#REM OS$CALL <FUNCTION> <ARGUMENT> {TO <RESULT>}
#REM <FUNCTION>    - BDOS function code - See O/S documentation.
#REM <ARGUMENT>    - Integer value to pass with function (optional)
#REM <RESULT>      - Result code returned by function

#REM Example to set CP/M I/O byto to "NEW_IO_BYTE (integer):
#REM OS$CALL 8 NEW_IO_BYTE

#REM Example to get console status:
#REM OS$CALL 12 0 TO CONSTAT //integer

#COMMAND OS$CALL &#LRU%DG #L%UG "TO""" #LCGUE .
  !A [] $2C8 !1 !2
  #IF !0>3
    //MOVEINT STRMARK TO !4
    !A [] $82 STRMARK !4
  #ENDIF
#ENDCOMMAND

#COMMAND OUTCLOSE &.
  // OUTFILE 'CON:'
  !A [] $200 |CS'CON:'
#ENDCOMMAND

#COMMAND OUTFILE &NDILU#G .
  !A [] $200 !1
#ENDCOMMAND

#COMMAND OUTPUT
  #IFSAME !1 CHANNEL
    !A [] $10A |CI1 !2
    OUTPUT !3
  #ELSE
    #CHECK !2 .
    #IF !0>0
      #CHECK !1.N _#LUGFV
      !A [] $202 !1.N
    #ELSE
      !A [] $202 |VI9
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND OUTPUT_WRAP R
  #IFSAME !1 CHANNEL
    !A [] $10A |CI1 !2
    OUTPUT_WRAP !3
  #ELSE
    #CHECK !2 .
    #CHECK !1.N _#LUGFV
    !A [] $20A !1.N // Fill wrap fields and set |122 if empty
    OUTPUT !1
    [NOT |122] BLANKFORM !1
    !A [NOT |122] $20A !1.N
    [NOT |122] REPEAT
    #IFDEF NEWPAGE
      PAGECHECK !1.LINES
      [PAGEBREAK] GOSUB NEWPAGE
    #ENDIF
    OUTPUT !1
    !A [] $20A !1.N // get more from wrap fields
    [NOT |122] LOOP
  #ENDIF
#ENDCOMMAND

#COMMAND PAD &#ULG$ "TO" #ULGRCE L%# .
  #IF !0>3
    !A [] $082 !4 STRMARK
  #ENDIF
  !A [] $240 !1 !3
#ENDCOMMAND

#COMMAND PAGE R%
  #IFSAME !1 SET
    #IF !0>1
      //  Set attributes for future use
      #CHECK !2.N _RU#LG
      MOVE !2.N TO STRMARK
      FIND$PAGE !3 !4 !5
      FIND$PAGE !6 !7 !8
    #ELSE
      //  Page an image named SET immediately
      !A [] $1C0 !1.N
    #ENDIF
  #ELSE
    #IF !0>1
      //  Set attributes for use now
      #CHECK !1.N _RU#LG
      MOVE !1.N TO STRMARK
      FIND$PAGE !2 !3 !4
      FIND$PAGE !5 !6 !7
    #ENDIF
    //  Put image with new attributes on screen now
    //  OR, put regular image on screen now.
    !A [] $1C0 !1.N
  #ENDIF
#ENDCOMMAND

#COMMAND PAGECHECK &#LG% .
  #IFDEF !1  |CI0
    !A [] $203 !1 |CI0
  #ELSE
    #CHECK !1.LINES _VFWU#LG
    !A [] $203 !1.LINES |CI0
  #ENDIF
#ENDCOMMAND

#COMMAND POS &#UGRL$ "IN" #UGRL$ #L% #L% .
  !A [] $244 !1 !3
  #IF !0>3
    #CHECK !4 "TO"
    #CHECK !5 _RCEUL
    !A [] $082 STRMARK !5
  #ENDIF
#ENDCOMMAND

#COMMAND PRINT #L
  #IF !0>2
    #IF !0>3
      #FORMAT !3 !4
      #CHECK !4 _CVFW#L
    #ENDIF
    #CHECK !2 "TO"
    #CHECK !3 _CVF#L
    #IFTYPE !3 "IND"
      !A [] $206 !1 !3
    #ELSE
      #IFTYPE !3 "R"
        !A [] $208 !1 !3
      #ELSE
        !A [] $205 !1 !3
      #ENDIF
    #ENDIF
  #ELSE
    AUTO4$ PRINT !1 TO PAGE!f !2
  #ENDIF
#ENDCOMMAND

#COMMAND PRINT_WRAP #L
  #IF !0>2
    #IF !0>3
      #FORMAT !3 !4
      #CHECK !4 _CVFW#L
    #ENDIF
    #CHECK !2 "TO"
    #CHECK !3 _CVF#L
    #IFCLASS !1 "F"
      !A [] $209 |CS"DBMS:!1" !3 // assign seq file to wrap window.
    #ELSE
      !A [] $209 !1 !3
    #ENDIF
  #ELSE
    AUTO4$ PRINT_WRAP !1 TO PAGE!f !2
  #ENDIF
#ENDCOMMAND

#COMMAND READ
  #IFSAME !1 CHANNEL
    !A [] $10A |CI0 !2
    #IF !0>2
      #CHECK !3 _ULEC
      READ !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ELSE
    !A [] $108 !1
    #IF !0>1
      #CHECK !2 _ULEC
      READ !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND READLN
  #IFSAME !1 CHANNEL
    #CHECK !3 _ULE
    !A [] $10A |CI0 !2
    READLN !3 !4 !5 !6 !7 !8 !9
  #ELSE
    #IF !0=0
      !A [] $104 |CS''
    #ENDIF
    #IF !0=1
      !A [] $104 !1
    #ENDIF
    #IF !0>1
      #CHECK !1 _ULE
      !A [] $108 !1
      READLN !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND READ_BLOCK
  #IFSAME !1 CHANNEL
    !A [] $10A |CI0 !2
    #IF !0>2
      #CHECK !3 _ULE
      #CHECK !4 _RU
      !A [] $109 !3 !4
    #ENDIF
  #ELSE
    #CHECK !1 _ULEC
    #CHECK !2 _RU
    !A [] $109 !1 !2
  #ENDIF
#ENDCOMMAND

#COMMAND READ_DFINI &#LGOBDR .
  !A [] $14C !1
#ENDCOMMAND

//#COMMAND REAL TR
//  #REAL V$
//  #REPLACE !1 |VR!v
//  #IF (!0>1)
//    REAL !2 !3 !4 !5 !6 !7 !8 !9
//  #ENDIF
//#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      REGISTER_RESOURCE resourceName
//
//   Descrtiption:
//      A command to register a resource for use prior to its inclusion.
//
//   Parmeters:
//       resourceName
//            Name of the resource (NOT in quotes).
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND REGISTER_RESOURCE _R
  #IFDEF !1.RSC
  #ELSE
    #REPLACE !1.RSC |CI!ZR // create unique resource symbol.
    #RESOURCE $0 !Zr 0 !1  // register resource; $0 = no filename; 0 = no type.
  #ENDIF
#ENDCOMMAND

#COMMAND REGISTRATION &#RLUGCE #LUGEC .
  !A [] $307 !1 !2
#ENDCOMMAND

#COMMAND RENAMEFILE &#LGU "TO" R#LGU .
  !A [] $2C2 !1 !3
#ENDCOMMAND

#COMMAND REPEAT &.
  #SET N$ !N
  #PUSH !R
  #XPUSH !n $INIT
  #IFIND // INCLUDE JUMPS IF INDICATORS ON LINE
  // GOTO BEGIN$!r
  !A [] $041 |CL0
  #FREF BEGIN$!r !a
  #$ !A 0 0 0 $041 |CL0
  #FREF END$!r !a
  #ENDIF
  #$ WHILE#!r:
  #$ BEGIN$!r:
#ENDCOMMAND



#COMMAND REPLACE #LG "IN" #LGCE "WITH" #LRG
  #IFIND
    [] BEGIN
    POS !1 IN !3
    #$ [FOUND] MOVESTR (REPLACE(!1,!3,!5)) TO !3
    END
 #ELSE
    POS !1 IN !3
    [FOUND] MOVESTR (REPLACE(!1,!3,!5)) TO !3
 #ENDIF
#ENDCOMMAND

// not updated for File_number vs recnum support. This should not be used with VDF. See Enter command for notes
#COMMAND REPORT T "BY""DOWN" VFW%LGR "BREAK"""
  #CHECK !1.RECNUM _UVCWGL
  INTEGER RECCOUNT
  #SET P$ 0
  //          MOVEINT 20000 TO LINECOUNT  // start with a full page
  !A [] $82 |CI20000 |VI10
  //          MOVE 0 TO RECCOUNT
  !A [] $82 |CI0 RECCOUNT
  //          BREAKINIT           // init breakpoints
  !A [] $207
  //          INDICATE FIRSTREC TRUE      // used for subtotals
  #IFDEF FIRSTREC
  #ELSE
    #REPLACE FIRSTREC |!C
  #ENDIF
  !A [] $4028 |CI0 |CI0 FIRSTREC~
  #IFSAME !2 BY
    FIND GE !1 BY !3          // FIND first record
  #ELSE
    FIND LE !1 BY !3
  #ENDIF
  [~FOUND] GOTO END$OF$REPORT
  //          CLEARSCREEN         // start with a clear screen
  !A [] $144
  RPT.LOOP://   INDICATE SELECT TRUE      // default for SELECT
  #IFDEF SELECT
  #ELSE
    #REPLACE SELECT |!C
  #ENDIF
  !A [] $4028 |CI0 |CI0 SELECT~
  //          GOSUB RPT.SELECTION     // go to user selection
  !A [] $42 |CL0
  #FREF RPT.SELECTION !a
  //[NOT SELECT] GOTO RPT.CONT        // test SELECT
  !A [~ SELECT] $41 |CL0
  #FREF RPT.CONT !a
  BREAK$ !5 !6 !7 !8 !9       // set breakpoints
  #SET X$ !p                  // set up to break down
  [NOT FIRSTREC] BREAK$DOWN RPT.SUBTOTAL  // break down for SUBTOTAL
  #SET X$ 0               // set up to break up
  //          RELATE !1           // get related records
  !A [] $C4 !1.RECNUM
  BREAK$UP RPT.SUBHEADER      // break up for SUBHEADER
  //          INCREMENT RECCOUNT
  !A [] $083 RECCOUNT |CI0
  //          GOSUB RPT.BODY          // print body
  !A [] $42 |CL0
  #FREF RPT.BODY !a
  //          INDICATE FIRSTREC FALSE     // not first any more
  !A [] $4028 |CI0 |CI0 FIRSTREC
  RPT.CONT:
  #IFSAME !2 BY
    FIND GT !1 BY !3          // FIND next record
  #ELSE
    FIND LT !1 BY !3
  #ENDIF
  //          KEYCHECK            // check keyboard
  !A [] $46
  //[FOUND NOT KEYPRESS] GOTO RPT.LOOP    // if ok, loop
  !A [FOUND ~ KEYPRESS] $41 RPT.LOOP
  //[KEYPRESS]  GOSUB RPT.KEYPRESS    // user can disable KEYPRESS
  !A [FOUND KEYPRESS]   $42 |CL0
  #FREF RPT.KEYPRESS !a
  !A [FOUND ~ KEYPRESS] $41 RPT.LOOP
  #SET X$ !p                  // set up for break down
  END.OF.REPORT:
  [~ FIRSTREC]  BREAK$DOWN RPT.SUBTOTAL $X    // break down for last subtotals
  //[FIRSTREC]  GOSUB RPT.TOTAL       // print TOTAL
  !A [~ FIRSTREC] $42 |CL0
  #FREF RPT.TOTAL !a
  //          GOTO END$OF$REPORT      // GOTO end
  !A [] $41 |CL0
  #FREF END$OF$REPORT !a
  NEWPAGE://    GOSUB RPT.HEADER      // new page, print HEADER
  !A [] $42 |CL0
  #FREF RPT.HEADER !a
  #SET X$ 0    // this will reprint the page headers if included //
  [NOT FIRSTREC] BREAK$PRT SUBHEADER      // reprint pages
  //          RETURN              // end of NEWPAGE
  !A [] $43 |CI0
  RPT.SELECTION:              // selection starts after REPORT
#ENDCOMMAND

#COMMAND REPORTEND .         // end of REPORT
  MAKEDEF$ RPT.HEADER RPT.SELECTION RPT.BODY RPT.TOTAL
  #SET X$ 0
  BREAK$T3
  // RETURN
  !A [] $43 |CI0
  #IFDEF RPT.KEYPRESS
  #ELSE
    RPT.KEYPRESS:
    // STRING AKEY$ 1
    #IFDEF AKEY$
    #ELSE
      #STR V$ 1
      #REPLACE AKEY$ |VS!v
    #ENDIF
    // SHOWLN 'A KEY HAS BEEN PRESSED.'
    !A [] $142 |CS'A KEY HAS BEEN PRESSED.'
    !A [] $143
    // SHOW   'DO YOU WANT TO STOP THE REPORT (Y or N)? '
    !A [] $142 |CS'DO YOU WANT TO STOP THE REPORT (Y or N)? '
    // INKEY AKEY$
    !A [] $147 AKEY$
    !A [] $141 AKEY$
    // IF NOT AKEY$ IN 'Yy' RETURN RPT.LOOP
    INDCT$AS SELECT AS AKEY$ IN 'Yy'
    //JJT-5.1
    //[~ SELECT] RETURN RPT.LOOP
    [~ SELECT] Gosub_RETURN RPT.LOOP
    //JJT-5.1
    //RETURN END$OF$REPORT  // Necessary to pop stack
    Gosub_RETURN END$OF$REPORT  // Necessary to pop stack
  #ENDIF
  END$OF$REPORT:
#ENDCOMMAND

// JJT-5.1
//#COMMAND RETURN VFWNDE#G
//  #IF !0=0
//    !A [] $043 |CL0
//  #ELSE
//    #IFSAME !1 RETURN
//      #SET Q$ (!a+2)
//      !A [] $043 |CL!q // RETURN RETURN
//      RETURN !2 !3 !4 !5 !6 !7 !8 !9
//    #ELSE
//      #IFDEF !1
//        #CHECK !1 _S
//        #CHECK !2 .
//        !A [] $043 !1
//      #ELSE
//        !A [] $043 |CL0
//        #FREF !1 !a
//      #ENDIF
//    #ENDIF
//  #ENDIF
//#ENDCOMMAND

#COMMAND RIGHT &#UGRL$ "TO" #UGRLEC L#% .
  #IF !0>3
    !A [] $082 !4 STRLEN
  #ENDIF
  !A [] $242 !1 !3
#ENDCOMMAND

#COMMAND RUNPROGRAM_PIPE #RLGU #RLGU #RLGU .
    !A [] $2D6 !3    // Specify the object to receive MSG_INSERT
                     // with the output from the pipe.
    !A [] $2D7 !1 !2 // Execute the OS command with any arguments.
#ENDCOMMAND

#COMMAND RUNPROGRAM #RLG #LG #LGU #LGU .
    // 14.0 SHELL option does a ShellExecute. Can be:
    // SHELL must be the first parameter
    #IFSAME !1 SHELL
        Runprogram$Shell !2 !3 !4
    #ELSE
      #IFSAME !1 WAIT BACKGROUND
        #IF !0>3
          #ERROR DFERR_COMP_INVALID_ARGUMENT TOO MANY ARGUMENTS TO RUNPROGRAM !1
        #ELSE
            #IFSAME !1 WAIT
                !A [] $2CC !2 !3
              #ELSE // BACKGROUND
                !A [] $2CD !2 !3
              #ENDIF
        #ENDIF
      #ELSE
          // Number of args is checked by type checking of command for PIPE.
        #IFSAME !1 PIPE
            #IF !0<4
                RUNPROGRAM_PIPE !2 "" !3 !4 !5 !6 !7 !8 !9
            #ELSE
                RUNPROGRAM_PIPE !2 !3 !4 !5 !6 !7 !8 !9
            #ENDIF
        #ELSE // Plain RUNPROGRAM.
            #IF !0>2
                #ERROR DFERR_COMP_INVALID_ARGUMENT TOO MANY ARGUMENTS TO RUNPROGRAM
            #ELSE
                  !A [] $2C0 !1 !2
            #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
#ENDCOMMAND

#COMMAND Runprogram$Shell "WAIT""BACKGROUND" #LGU #LGU .
  #IFSAME !1 Wait
    !A [] $2f2 !2 !3
  #ELSE
    !A [] $2f1 !2 !3
  #ENDIF
#ENDCOMMAND


#COMMAND SCREENMODE #%LGR # .
  #IFSAME !1 ON
    !A [] $148 |CE(458752)     // SCREENMODE on 0x70000
  #ELSE
    #IFSAME !1 OFF
      !A [] $148 |CE(196608)       // SCREENMODE off 0x30000
    #ELSE
      #CHECK !1 _U
      !A [] $148 !1
    #ENDIF
  #ENDIF
  #IF !0>1
    SCREENMODE !2
  #ENDIF
#ENDCOMMAND

#COMMAND SECTION &RT #LGU .
  #IFSAME !1 SELECTION            // SELECTION is null SECTION
  #ELSE
    // RETURN                   // RETURN from last routine
    !A [] $43 |CI0
    RPT.!1:                 // label SECTION
    #IFDEF !2       // LINES REQ SPEC
      // PAGECHECK !2
      !A [] $203 !2
      // [PAGEBREAK] GOSUB NEWPAGE
      !A [PAGEBREAK] $42 NEWPAGE
      #IFDEF !1.LINES
        #SET F$ !1.N
        #SET E$ 0
      #ENDIF
    #ELSE
      #IFDEF !1.LINES                 // is there a page?
        // PAGECHECK !1.LINES           // check for end of page
        !A [] $203 !1.LINES |CI0
        //[PAGEBREAK] GOSUB NEWPAGE     // if end, GOSUB NEWPAGE
        !A [PAGEBREAK] $42 NEWPAGE
        // AUTOPAGE !1              // start default page
        #SET F$ !1.N
        #SET E$ 0
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND SET_ARGUMENT_SIZE &#LGRBOUSD .
  !A [] $24E !1
#ENDCOMMAND

#COMMAND SET_DFPATH "TO" &#LGRBOUD .
  !A [] $2D0 !2
#ENDCOMMAND

#COMMAND SET_CHANNEL_POSITION  &#LRUG$ "TO" &#LRUG$ .
  !A [] $10C !1 !3
#ENDCOMMAND

#COMMAND SET_OPTION #LGR . // Sets window options
  #IFCLASS !1 _C         // To stay on perminantly until
    #SET Q$ !1         // Turned off with CLEAR_OPTION.
    !A [] $04A |CI!q |CI0     // SET_OPTION NO_CALC // Turn off calculate.
  #ELSE
    !A [] $04A !1 |CI0    // THIS COMMAND IS FOR INTERNAL USE.
  #ENDIF
#ENDCOMMAND

#COMMAND SET_RELATE &#LGOBRWCV "TO" #LGOBRWCV .
  !A [] $348 !1 !3
#ENDCOMMAND

#COMMAND SET_TERMLIST &#LGOBDR #LGOBDIN .
  !A [] $14A !1 !2
#ENDCOMMAND

#COMMAND SETCHANGE &RCVF%G .
  !A [] $1C7 !1
#ENDCOMMAND

#COMMAND SHOW #ULRG$
  !A [] $142 !1
  #IF (!0>1)
    SHOW !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

#COMMAND SHOWLN #LGU$
  #IF (!0>0)
    SHOW !1 !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
  !A [] $143
#ENDCOMMAND

#COMMAND SLEEP #LGURDBO .
  !A [] $02CE !1
#ENDCOMMAND

// removed along with the other Old_Xxxxx commands. Note that there is no current status command.
//#COMMAND STATUS$ &CVW#LG "TO" #LUGRE
//  #IFDEF !1
//    !A [] $304 !1 !3
//  #ELSE
//    #CHECK !1.RECNUM _CVWLR#GU
//    !A [] $304 !1.RECNUM !3
//  #ENDIF
//#ENDCOMMAND

#COMMAND STOP &.
  !A [] $144
  !A [] $040
#ENDCOMMAND

#COMMAND STOP_HERE
    !A [] $4d !1
#ENDCOMMAND

// JJT-5.1
//#COMMAND STRING TR E#L%
//  #IF (!0>1)
//    #IFDEF !2
//      #CHECK !2 _VSWDF
//      #STR V$ !2
//      #REPLACE !1 |VS!v
//      #IF (!0>2)
//        STRING !3 !4 !5 !6 !7 !8 !9
//      #ENDIF
//    #ELSE
//      #STR V$ 80
//      #REPLACE !1 |VS!v
//      STRING !2 !3 !4 !5 !6 !7 !8 !9
//    #ENDIF
//  #ELSE
//    #STR V$ 80
//    #REPLACE !1 |VS!v
//  #ENDIF
//#ENDCOMMAND

#COMMAND SUBTOTAL RFVC#LSD
  PRINT !1% !2 !3 !4 !5
  !A [] $082 |CI0 !1%
#ENDCOMMAND

#REM Get system date, hour, min, seconds.
#REM WILL NOT WORK UNDER CPM 2.2

#COMMAND SYSDATE$HELP
//  #IFDEF IS$WINDOWS     // This code is no longer required in VDF5. KCR
//      !A [] $2E2 |CI2 !2
//  #ENDIF
  !A [] $2C9 !1 !2
  #IF !0>2
    //MOVE STRLEN TO !3
    !A [] $82 STRLEN !3
  #ENDIF
  #IF !0>3
    //MOVE STRMARK TO !4
    !A [] $82 STRMARK !4
     #IF !0>4
      //MOVE |VI37 TO !5
      !A [] $82 |VI37 !5
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND SYSDATE #ERCUGL #ECUGL #ECUGL #ECUGL . // SYSDATE DATE HR MIN SECOND
    SYSDATE$HELP !1 DFFALSE !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND SYSDATE4 #ERCUGL #ECUGL #ECUGL #ECUGL . // SYSDATE DATE HR MIN SECOND
    SYSDATE$HELP !1 DFTRUE !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND SYSTEM &.
  !A [] $2C7
#ENDCOMMAND

#COMMAND TRIM &#LUG$ "TO" C#ELRUG .  // remove pre- and trailing spaces
  !A [] $24B !1 !3
#ENDCOMMAND

#COMMAND UNLOCK &.
  !A [] $0C8
#ENDCOMMAND

#COMMAND UNTIL R L L L .
  #POP S$
  IFNOT_ !1 !2 !3 !4 GOTO BEGIN$!s
  END$!s:
  #SET N$ !n-1
#ENDCOMMAND

#COMMAND UPPERCASE &C#LUGRND$ "TO""" C#LUG$END .
  #IF !0>1
    !A [] $249 !1 !3
  #ELSE
    !A [] $249 !1 !1
  #ENDIF
#ENDCOMMAND

#COMMAND WHILE R L L L .
  #SET N$ !N
  #PUSH !R
  #XPUSH !n $INIT
  // GOTO WHILE$!r
  !A [] $041 |CL0
  #FREF WHILE$!r !a
  #$ !A 0 0 0 $041 |CL!a
  #FREF END$!r !a
  #$ WHILE$!r:
  #$ BEGIN$!r:
  #$ IFNOT_ !1 !2 !3 !4 GOTO END$!r
#ENDCOMMAND

#COMMAND WRITE$STR #ULRG$
    !A [] $106 !1
    #IF (!0>1)
      WRITE$STR !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
#ENDCOMMAND

#COMMAND WRITE
  #IFSAME !1 CHANNEL
    !A [] $10A |CI1 !2
    #IF !0>2
      WRITE$STR !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ELSE
    #IF (!0>0)
      WRITE$STR !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND WRITELN
  #IFSAME !1 CHANNEL
    !A [] $10A |CI1 !2
    #IF !0>2
      WRITE$STR !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ELSE
    #IF (!0>0)
      WRITE$STR !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF
  !A [] $107
#ENDCOMMAND

#COMMAND GET_CHANNEL_POSITION &#LRUG$ "TO" &#LRUG$EC .
  !A [] $10B !1 !3
#ENDCOMMAND



// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//     INITIALIZE_INTERFACE
//
//   Parameters:
//     None.
//
//   Description:
//     INITIALIZE_INTERFACE initializes the object resource information.
//     It should be executed before any other object related operations
//     are performed.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND INITIALIZE_INTERFACE .&
  // B$ obj_flag        bit 0 = in_object, bit 1 = in_class, bit 2 = in proc/func
  // X.AGG agg_count(class)     defined count of objects in class

  // ZA$ procedure/function label for procedures and functions
  // ZB$ current_dep        the current dependant number to assign
  // ZC$ current_message    the current flex message number
  // ZD$ group_size         size of the current item group
  // ZE$ group_id           unique id of current item group
  // ZF$ super_class_count  count of objects in superclass
  // ZG$ temp               temp counter (items, functions etc)
  // ZH$ access_method      the current access method identifyer
  // ZI$ sub_obj_count      the sub object counter
  // ZJ$ current_object     the current_object number

//  #SET ZC$ $400             // begin up high, past predefinded
  #SET ZC$ $1000            // now reserving 4K for predefined msgs

//  #SET ZH$ $4001          // begin access methods here
  #SET ZH$ $40000001        // now using 32-bit msg ids; allows for 256M objs

  #SET ZJ$ 2                // desktop and clipboard are first

  #REPLACE IS$NEW$FMAC |CI1 // indicates that this is the new fmac
//  #REPLACE IS$WINDOWS |CI1  // comment this to create character mode version

  #REPLACE MANGLE_NAMES              |CI1   // Adds name mangling.
  #REPLACE EXTENDED_DATA_TYPES       |CI1   // Adds extended data types.
  #IFNDEF SUPPORT$ADDRESS
    #IFDEF EXTENDED_DATA_TYPES
      #REPLACE SUPPORT$ADDRESS           |CI1
    #ENDIF
  #ENDIF
  //#REPLACE WINBASE_CONSOLIDATION     |CI1   // Moves messages into dfmsg.pkg


// Informational output to screen/printer/file.
// This information is essential to know whether things are right at compile time.

  #IFDEF IS$WINDOWS
    #REM FMAC FOR VISUAL DATAFLEX AND WEB APP STUDIO.
  #ELSE
    #REM FMAC FOR DATAFLEX CHARACTER MODE.
  #ENDIF

  #IFDEF MANGLE_NAMES
    #REM NAME MANGLING ENABLED!
  #ENDIF

  #IFDEF EXTENDED_DATA_TYPES
    #REM EXTENDED DATA TYPES ENABLED!
  #ENDIF

  // Current FMAC Version, Revision and Build
  #REPLACE FMAC_VERSION  |CI16
  #REPLACE FMAC_REVISION |CI1
  #REPLACE FMAC_BUILD    |CI81


#IFDEF IS$WINDOWS

  // Define object class types.
  #REPLACE U_cObject            |CI1    // Basic object support.
  #REPLACE U_cUIObject          |CI2    // UI Object

  // removed in 8.3 --- might have #replaces defined in dfbase.pkg
  //#REPLACE U_DESKTOP            |CI1    // a desktop class object - obsolete
  //#REPLACE U_BaseClass          |CI1    // a desktop class object - obsolete
  //#REPLACE U_MESSAGE            |CI2    // a message class object -obsolete

  #REPLACE U_cm_MENU            |CI3    // a menu class object
  #REPLACE U_cm_EDIT            |CI4    // a edit class object
  #REPLACE U_SCROLLB            |CI5    // a scroll bar class object
  #REPLACE U_cm_LIST            |CI6    // a list class object
  #REPLACE U_cm_BUTTON          |CI7    // a button class object
  #REPLACE U_cm_CHECKBOX        |CI8    // a check box class object
  #REPLACE U_cm_CHECKLIST       |CI9    // a check box class object
  #REPLACE U_cm_FORM            |CI10   // a form class object
  #REPLACE U_cm_FORMLIST        |CI11   // a form class object
  #REPLACE U_CLIENT             |CI12   // a client area class object
  #REPLACE U_cm_TITLE           |CI13   // a title bar class object
  #REPLACE U_cm_ACTION_BAR      |CI14   // a action bar class object
  #REPLACE U_cm_WARNING_MSG     |CI15   // a warning message class object
  #REPLACE U_cm_CRIT_MSG        |CI16   // a critical error class object
  #REPLACE U_cm_ERROR           |CI17   // a standard error class object
  #REPLACE U_cm_HELP            |CI18   // a help class object
  #REPLACE U_ARRAY              |CI19   // a array class of mixed scalars
  #REPLACE U_TRACE              |CI20   // a trace class object
  #REPLACE U_cm_ENTRY           |CI21   // a data entry class object
  #REPLACE U_cm_ENTRYLIST       |CI22   // a data entry class object
  #REPLACE U_cm_DIALOG          |CI23   // a DIALOG area class object
  #REPLACE U_cm_RADIO           |CI24   // a radio button area
  #REPLACE U_cm_RADIOLIST       |CI25   // a radio list  area
  #REPLACE U_cm_VCONSOLE        |CI26   // a virtual console area
  #REPLACE U_CLIPBOARD          |CI27   // the clipboard handler

  #REPLACE U_DFBaseObject                 |CI28
  #REPLACE U_DFBaseWindow                 |CI29
  #REPLACE U_DFBaseUIWindow               |CI30
  #REPLACE U_DFBaseContainer              |CI31
  #REPLACE U_DFBaseDialog                 |CI32
  #REPLACE U_DFBasePanel                  |CI33
  #REPLACE U_cDesktop                     |CI34  // prior to 8.3 this was dfBaseDesktop
  #REPLACE U_DFBaseControl                |CI35
  #REPLACE U_DFBaseMenu                   |CI36
  #REPLACE U_DFBaseButton                 |CI37
  #REPLACE U_DFBasePushButton             |CI38
  //#REPLACE U_DFComboButton                |CI39  // no longer exists
  #REPLACE U_DFBaseCheckBox               |CI40
  #REPLACE U_DFBaseRadioButton            |CI41
  #REPLACE U_DFBaseTriState               |CI42    // not supported at highlevel
  #REPLACE U_DFBaseForm                   |CI43
  #REPLACE U_DFBaseEntry                  |CI44
  //#REPLACE U_DFComboForm                  |CI45  // no longer exists
  #REPLACE U_DFBaseList                   |CI46
  #REPLACE U_DFBaseFormList               |CI47
  #REPLACE U_DFBaseCheckList              |CI48    // not used
  #REPLACE U_DFBaseRadioList              |CI49    // not used
  #REPLACE U_DFBaseEntryList              |CI50    // not used
  #REPLACE U_DFBaseComboBox               |CI51
  #REPLACE U_DFBaseTriStateList           |CI52
  #REPLACE U_DFBasePushButtonList         |CI53
  #REPLACE U_DFBaseActionBar              |CI54
  #REPLACE U_DFBasePullDown               |CI55
  #REPLACE U_DFBaseSysMenu                |CI56
  #REPLACE U_DFBaseGroup                  |CI57
  #REPLACE U_DFBaseScrollBar              |CI58
  #REPLACE U_DFBaseHorzScrollBar          |CI59
  #REPLACE U_DFRubberBand                 |CI60   // no longer exists
  #REPLACE U_DFBaseTextBox                |CI61
  #REPLACE U_DFBaseEdit                   |CI62
  #REPLACE U_DFBaseSession                |CI63
  #REPLACE U_DFBaseDllSession             |CI64
  #REPLACE U_DFBaseSerial                 |CI65
  #REPLACE U_DFBaseLineForm               |CI66
  //#REPLACE U_DFVconsole                   |CI67  // no longer exists
  #REPLACE U_DFBaseToolPanel              |CI68
  #REPLACE U_DFBaseMapiSession            |CI69
  #REPLACE U_DFBaseImageList              |CI70
  #REPLACE U_DFBaseTabDialog              |CI71
  #REPLACE U_DFBaseToolBar                |CI72 // was dfbuttonbar
  #REPLACE U_DFBaseComboBoxEntry          |CI73
  #REPLACE U_DFBaseMdiClient              |CI74
  #REPLACE U_DFBaseListBox                |CI75
  #REPLACE U_DFBaseEditPulldown           |CI76
  #REPLACE U_DFBaseLineControl            |CI77

  // inet classes
  #REPLACE U_INETTRANSFER                 |CI78
  #REPLACE U_CFTPTRANSFER                 |CI79
  #REPLACE U_CBASEHTTPTRANSFER            |CI80


  // XML Classes
  #REPLACE U_BaseXMLDOMNODE               |CI81
  #REPLACE U_BaseXMLDOMNODELIST           |CI82
  #REPLACE U_BaseXMLDOMNAMEDNODEMAP       |CI83
  #REPLACE U_BaseXMLDOMPARSEERROR         |CI84
  #REPLACE U_BaseXMLDOMIMPLEMENTATION     |CI85
  #REPLACE U_BaseXMLDOMDOCUMENTFRAGMENT   |CI86
  #REPLACE U_BaseXMLDOMDOCUMENT           |CI87
  #REPLACE U_BaseXMLDOMCHARACTERDATA      |CI88
  #REPLACE U_BaseXMLDOMTEXTNODE           |CI89
  #REPLACE U_BaseXMLDOMCDATASECTION       |CI90
  #REPLACE U_BaseXMLDOMCOMMENT            |CI91
  #REPLACE U_BaseXMLDOMATTRIBUTE          |CI92
  #REPLACE U_BaseXMLDOMELEMENT            |CI93
  #REPLACE U_BaseXMLDOMPROCESSINGINSTRUCTION    |CI94
  #REPLACE U_BaseXMLDOMDOCUMENTTYPE       |CI95
  #REPLACE U_BaseXMLDOMNOTATION           |CI96
  #REPLACE U_BaseXMLDOMENTITY             |CI97
  #REPLACE U_BaseXMLDOMENTITYREFERENCE    |CI98

  #REPLACE U_CBASEWEBSERVICE              |CI00105

  // flexcom2 runtime classes

  #REPLACE U_DFCOMAUTOMATIONOBJECT        |CI107
  #REPLACE U_DFCOMDOCUMENTOBJECT          |CI108
  #REPLACE U_DFCOMACTIVEXCONTROL          |CI109
  #REPLACE U_DFCOMDESIGNCONTROL           |CI110
  #REPLACE U_DFCOMIDISPATCHDRIVER         |CI111

  #REPLACE U_DFBaseRichEdit               |CI112 // added 11.0
  #REPLACE U_DFBaseTextEdit               |CI113 // added 11.0

  #Replace U_cIdleHandler                 |CI128  // added 12.1


#ELSE

  // character mode class defintions

  // Define object class types.
  #REPLACE U_DESKTOP            |CI1    // a desktop class object
  #REPLACE U_MESSAGE            |CI2    // a message class object
  #REPLACE U_MENU               |CI3    // a menu class object
  #REPLACE U_EDIT               |CI4    // a edit class object
  #REPLACE U_SCROLLB            |CI5    // a scroll bar class object
  #REPLACE U_LIST               |CI6    // a list class object
  #REPLACE U_BUTTON             |CI7    // a button class object
  #REPLACE U_CHECKBOX           |CI8    // a check box class object
  #REPLACE U_CHECKLIST          |CI9    // a check box class object
  #REPLACE U_FORM               |CI10   // a form class object
  #REPLACE U_FORMLIST           |CI11   // a form class object
  #REPLACE U_CLIENT             |CI12   // a client area class object
  #REPLACE U_TITLE              |CI13   // a title bar class object
  #REPLACE U_ACTION_BAR         |CI14   // a action bar class object
  #REPLACE U_WARNING_MSG        |CI15   // a warning message class object
  #REPLACE U_CRIT_MSG           |CI16   // a critical error class object
  #REPLACE U_ERROR              |CI17   // a standard error class object
  #REPLACE U_HELP               |CI18   // a help class object
  #REPLACE U_ARRAY              |CI19   // a array class of mixed scalars
  #REPLACE U_TRACE              |CI20   // a trace class object
  #REPLACE U_ENTRY              |CI21   // a data entry class object
  #REPLACE U_ENTRYLIST          |CI22   // a data entry class object
  #REPLACE U_DIALOG             |CI23   // a DIALOG area class object
  #REPLACE U_RADIO              |CI24   // a radio button area
  #REPLACE U_RADIOLIST          |CI25   // a radio list  area
  #REPLACE U_VCONSOLE           |CI26   // a virtual console area
  #REPLACE U_CLIPBOARD          |CI27   // the clipboard handler
#ENDIF

  // Base data structures
  #REPLACE MESSAGE_CLASS        |CI0
  #REPLACE MENU_CLASS           |CI1
  #REPLACE LIST_CLASS           |CI2
  #REPLACE EDIT_CLASS           |CI3
  #REPLACE SCROLL_CLASS         |CI4
  #REPLACE ARRAY_CLASS          |CI5


  // Define physical key names
  #REPLACE KEY_ALT              |VI$8200
  #REPLACE KEY_SHIFT            |VI$8400
  #REPLACE KEY_CTRL             |VI$8800

  #REPLACE KEY_ENTER            |VI$9001
  #REPLACE KEY_TAB              |VI$9002
  #REPLACE KEY_BACK_SPACE       |VI$9003
  #REPLACE KEY_ESCAPE           |VI$9004
  #REPLACE KEY_UP_ARROW         |VI$9005
  #REPLACE KEY_DOWN_ARROW       |VI$9006
  #REPLACE KEY_LEFT_ARROW       |VI$9007
  #REPLACE KEY_RIGHT_ARROW      |VI$9008
  #REPLACE KEY_HOME             |VI$9009
  #REPLACE KEY_END              |VI$900A
  #REPLACE KEY_PGUP             |VI$900B
  #REPLACE KEY_PGDN             |VI$900C
  #REPLACE KEY_INSERT           |VI$900D
  #REPLACE KEY_DELETE           |VI$900E
  #REPLACE KEY_F1               |VI$9010
  #REPLACE KEY_F2               |VI$9011
  #REPLACE KEY_F3               |VI$9012
  #REPLACE KEY_F4               |VI$9013
  #REPLACE KEY_F5               |VI$9014
  #REPLACE KEY_F6               |VI$9015
  #REPLACE KEY_F7               |VI$9016
  #REPLACE KEY_F8               |VI$9017
  #REPLACE KEY_F9               |VI$9018
  #REPLACE KEY_F10              |VI$9019
  #REPLACE KEY_F11              |VI$901A
  #REPLACE KEY_F12              |VI$901B
  #REPLACE KEY_A                |VI$8041
  #REPLACE KEY_B                |VI$8042
  #REPLACE KEY_C                |VI$8043
  #REPLACE KEY_D                |VI$8044
  #REPLACE KEY_E                |VI$8045
  #REPLACE KEY_F                |VI$8046
  #REPLACE KEY_G                |VI$8047
  #REPLACE KEY_H                |VI$8048
  #REPLACE KEY_I                |VI$8049
  #REPLACE KEY_J                |VI$804A
  #REPLACE KEY_K                |VI$804B
  #REPLACE KEY_L                |VI$804C
  #REPLACE KEY_M                |VI$804D
  #REPLACE KEY_N                |VI$804E
  #REPLACE KEY_O                |VI$804F
  #REPLACE KEY_P                |VI$8050
  #REPLACE KEY_Q                |VI$8051
  #REPLACE KEY_R                |VI$8052
  #REPLACE KEY_S                |VI$8053
  #REPLACE KEY_T                |VI$8054
  #REPLACE KEY_U                |VI$8055
  #REPLACE KEY_V                |VI$8056
  #REPLACE KEY_W                |VI$8057
  #REPLACE KEY_X                |VI$8058
  #REPLACE KEY_Y                |VI$8059
  #REPLACE KEY_Z                |VI$805A
  #REPLACE KEY_SPACE            |VI$8020
  #REPLACE KSPACE               |VI$8020
  #REPLACE KEY_0                |VI$8030
  #REPLACE KEY_1                |VI$8031
  #REPLACE KEY_2                |VI$8032
  #REPLACE KEY_3                |VI$8033
  #REPLACE KEY_4                |VI$8034
  #REPLACE KEY_5                |VI$8035
  #REPLACE KEY_6                |VI$8036
  #REPLACE KEY_7                |VI$8037
  #REPLACE KEY_8                |VI$8038
  #REPLACE KEY_9                |VI$8039
  #REPLACE KEY_PLUS             |VI$802B
  #REPLACE KEY_MINUS            |VI$802D
  #REPLACE KEY_EQUAL            |VI$803D
  #REPLACE KEY_BACK_SLASH       |VI$805C
  #REPLACE KEY_SLASH            |VI$802F

  // Define Accelerator key names.
  #REPLACE KHELP                |CI274
  #REPLACE KSAVE_RECORD         |CI265
  #REPLACE KDELETE_RECORD       |CI266
  #REPLACE KEXIT_FUNCTION       |CI281
  #REPLACE KEXIT_APPLICATION    |CI282
  #REPLACE KPROMPT              |CI283
  #REPLACE KPRINT_SCREEN        |CI258
  #REPLACE KCLEAR               |CI269
  #REPLACE KREFRESH_SCREEN      |CI284
  #REPLACE KSWITCH              |CI285
  #REPLACE KSWITCH_BACK         |CI286
  #REPLACE KFIND                |CI263
  #REPLACE KFIND_PREVIOUS       |CI270
  #REPLACE KFIND_NEXT           |CI271
  #REPLACE KSUPER_FIND          |CI264
  #REPLACE KSUPER_FIND_PREVIOUS |CI287
  #REPLACE KSUPER_FIND_NEXT     |CI288
  #REPLACE KACTION_BAR          |CI289
  #REPLACE KENTER               |CI257
  #REPLACE KUPARROW             |CI272
  #REPLACE KDOWNARROW           |CI273
  #REPLACE KLEFTARROW           |CI260
  #REPLACE KRIGHTARROW          |CI261
  #REPLACE KSCROLL_BACK         |CI290
  #REPLACE KSCROLL_FORWARD      |CI291
  #REPLACE KSCROLL_LEFT         |CI292
  #REPLACE KSCROLL_RIGHT        |CI293
  #REPLACE KBEGIN_OF_LINE       |CI294
  #REPLACE KEND_OF_LINE         |CI295
  #REPLACE KNEXT_ITEM           |CI296
  #REPLACE KPREVIOUS_ITEM       |CI262
  #REPLACE KDELETE_CHARACTER    |CI277
  #REPLACE KERASE_END_OF_LINE   |CI297
  #REPLACE KBACK_SPACE          |CI278
  #REPLACE KCANCEL              |CI259
  #REPLACE KBEGIN_OF_PANEL      |CI298
  #REPLACE KEND_OF_PANEL        |CI299
  #REPLACE KBEGIN_OF_DATA       |CI300
  #REPLACE KEND_OF_DATA         |CI301
  #REPLACE KWORD_LEFT           |CI302
  #REPLACE KWORD_RIGHT          |CI303
  #REPLACE KINSERT              |CI276
  #REPLACE KCLEAR_AND_RETURN    |CI279
  #REPLACE KADD_MODE            |CI304
  #REPLACE KPASTE               |CI305
  #REPLACE KCOPY                |CI306
  #REPLACE KCUT                 |CI307
  #REPLACE KCLEAR_ALL           |CI308
  #REPLACE KMOUSE               |CI309
  #REPLACE KMARK                |CI310
  #REPLACE KZOOM                |CI311
  #REPLACE KCLOSE_PANEL         |CI312

  //OLD KEY DEFINITIONS
  #REPLACE KCALCULATE           |CI267
  #REPLACE KUSER                |CI268
  #REPLACE KUSER2               |CI275
  #REPLACE KCLEOW               |CI280


  //#FREG |CI$01CE STRING PERCENTAGE RETURNS INTEGER

  #REPLACE DFLT$VALUE               __X__
  #REPLACE DFLT$MESSAGE             __X__
  #REPLACE DFLT$AUX_VALUE           __X__
  #REPLACE DFLT$SHADOW_STATE        __X__
  #REPLACE DFLT$SELECT_STATE        __X__
  #REPLACE DFLT$CHECKBOX_ITEM_STATE __X__
  #REPLACE DFLT$AUTOCLEAR_STATE     __X__
  #REPLACE DFLT$CENTER_STATE        __X__
  #REPLACE DFLT$ENTRY_STATE         __X__
  #REPLACE DFLT$ITEM_CHANGED_STATE  __X__
  #REPLACE DFLT$ITEM_ENTRY_MSG      __X__
  #REPLACE DFLT$ITEM_EXIT_MSG       __X__
  #REPLACE DFLT$ITEM_VALIDATE_MSG   __X__
  #REPLACE DFLT$DATA_FILE           __X__
  #REPLACE DFLT$DATA_FIELD          __X__
  #REPLACE DFLT$DATA_WINDOW         __X__
  #REPLACE DFLT$ITEM_OPTIONS        __X__
  #REPLACE DFLT$ITEM_OPTION         __X__
  #REPLACE DFLT$PROMPT_OBJECT       __X__
  #REPLACE DFLT$ZOOM_OBJECT         __X__

#IFDEF IS$WINDOWS

  // Define all Form properties that require an index (item). If the item parameter
  // is omitted item 0 is used as a default. This allows single item objects (e.g. Form)
  // to omit the item number. (e.g. Set Password_State to True).

  #REPLACE DFLT$FORM_WIDTH                 __F__
  #REPLACE DFLT$FORM_COLOR                 __F__
  #REPLACE DFLT$FORM_DATATYPE              __F__
  #REPLACE DFLT$FORM_OPTIONS               __F__
  #REPLACE DFLT$FORM_FONT                  __F__
  #REPLACE DFLT$FORM_ROW                   __F__
  #REPLACE DFLT$FORM_COLUMN                __F__
  #REPLACE DFLT$FORM_TYPEFACE              __F__
  #REPLACE DFLT$FORM_FONTHEIGHT            __F__
  #REPLACE DFLT$FORM_FONTWEIGHT            __F__
  #REPLACE DFLT$FORM_FONTITALICS           __F__
  #REPLACE DFLT$FORM_FONTUNDERLINE         __F__
  #REPLACE DFLT$BUTTON_ASPECT              __F__
  #REPLACE DFLT$FORM_HEIGHT                __F__
  #REPLACE DFLT$FORM_GUIWIDTH              __F__
  #REPLACE DFLT$FORM_GUIHEIGHT             __F__
  #REPLACE DFLT$FORM_GUIROW                __F__
  #REPLACE DFLT$FORM_GUICOLUMN             __F__
  #REPLACE DFLT$FORM_MARGIN                __F__
  #REPLACE DFLT$FORM_OPTION                __F__
  #REPLACE DFLT$FORM_STYLE                 __F__
  #REPLACE DFLT$FORM_EXTENDED_STYLE        __F__
  #REPLACE DFLT$FORM_BORDER                __F__
  #REPLACE DFLT$PASSWORD_STATE             __F__
  #REPLACE DFLT$FORM_MASK                  __F__
  #REPLACE DFLT$FORM_BUTTON                __F__
  #REPLACE DFLT$FORM_BUTTON_VALUE          __F__
  #REPLACE DFLT$FORM_WINDOW_HANDLE         __F__
  #REPLACE DFLT$FORM_BUTTON_WINDOW_HANDLE  __F__
  #REPLACE DFLT$MASKED_VALUE               __F__  // these are really form properties
  #REPLACE DFLT$UNMASKED_VALUE             __F__  // so if no param use 0
  #REPLACE DFLT$FORM_JUSTIFICATION_MODE    __F__

  // These are index (item or form) tem based properties that require two
  // parameters in the set statement following the "to". Please do not
  // create any more of these kinds of messages
  #REPLACE DFLT$2$ITEM_OPTION              __2__
  #REPLACE DFLT$2$FORM_COLOR               __2__
  #REPLACE DFLT$2$FORM_STYLE               __2__
  #REPLACE DFLT$2$FORM_EXTENDED_STYLE      __2__

#ENDIF



  //Reserve$Internal$Functions // this disallows these names to be used in
                             // in functions, properties or cts.
  #REPLACE FN$Abs                          __F__
  #REPLACE FN$Acos                         __F__
  #REPLACE FN$Append                       __F__
  #REPLACE FN$Ascii                        __F__
  #REPLACE FN$Asin                         __F__
  #REPLACE FN$Atan                         __F__
  #REPLACE FN$Center                       __F__
  #REPLACE FN$Character                    __F__
  #REPLACE FN$Cos                          __F__
  #REPLACE FN$Date                         __F__
  #REPLACE FN$Eval                         __F__
  #REPLACE FN$Exp                          __F__
  #REPLACE FN$Hi                           __F__
  #REPLACE FN$If                           __F__
  #REPLACE FN$Insert                       __F__
  #REPLACE FN$Integer                      __F__
  #REPLACE FN$Left                         __F__
  #REPLACE FN$Length                       __F__
  #REPLACE FN$Log                          __F__
  #REPLACE FN$Low                          __F__
  #REPLACE FN$Lowercase                    __F__
  #REPLACE FN$Ltrim                        __F__
  #REPLACE FN$Mid                          __F__
  #REPLACE FN$Mod                          __F__
  #REPLACE FN$Not                          __F__
  #REPLACE FN$Number                       __F__
  #REPLACE FN$Overstrike                   __F__
  #REPLACE FN$Pad                          __F__
  #REPLACE FN$Pos                          __F__
  #REPLACE FN$Random                       __F__
  #REPLACE FN$Real                         __F__
  #REPLACE FN$Remove                       __F__
  #REPLACE FN$Repeat                       __F__
  #REPLACE FN$Replace                      __F__
  #REPLACE FN$Replaces                     __F__
  #REPLACE FN$Right                        __F__
  #REPLACE FN$Round                        __F__
  #REPLACE FN$Rtrim                        __F__
  #REPLACE FN$Sin                          __F__
  #REPLACE FN$Sqrt                         __F__
  #REPLACE FN$String                       __F__
  #REPLACE FN$Tan                          __F__
  #REPLACE FN$Trim                         __F__
  #REPLACE FN$Uppercase                    __F__

  #IFDEF EXTENDED_DATA_TYPES
    #REPLACE FN$CurrentDateTime              __F__
    #REPLACE FN$DateGetDay                   __F__
    #REPLACE FN$DateGetDayofWeek             __F__
    #REPLACE FN$DateGetDayofYear             __F__
    #REPLACE FN$DateGetHour                  __F__
    #REPLACE FN$DateGetMinute                __F__
    #REPLACE FN$DateGetMonth                 __F__
    #REPLACE FN$DateGetSecond                __F__
    #REPLACE FN$DateGetYear                  __F__
    #REPLACE FN$DateSetDay                   __F__
    #REPLACE FN$DateSetHour                  __F__
    #REPLACE FN$DateSetMinute                __F__
    #REPLACE FN$DateSetMonth                 __F__
    #REPLACE FN$DateSetSecond                __F__
    #REPLACE FN$DateSetYear                  __F__
    #REPLACE FN$IsDateValid                  __F__
    #REPLACE FN$SpanDays                     __F__
    #REPLACE FN$SpanHours                    __F__
    #REPLACE FN$SpanMinutes                  __F__
    #REPLACE FN$SpanSeconds                  __F__
    #REPLACE FN$SpanTotalDays                __F__
    #REPLACE FN$SpanTotalHours               __F__
    #REPLACE FN$SpanTotalMinutes             __F__
    #REPLACE FN$SpanTotalSeconds             __F__
    #REPLACE FN$Addressof                    __F__
    #REPLACE FN$Cast                         __F__
    #REPLACE FN$Convert                      __F__
    #REPLACE FN$InvokeXML                    __F__
    //
    #REPLACE FN$Storec                       __F__
    #REPLACE FN$Storew                       __F__
    #REPLACE FN$Storedw                      __F__
    #REPLACE FN$Derefc                       __F__
    #REPLACE FN$Derefw                       __F__
    #REPLACE FN$Derefdw                      __F__
    #REPLACE FN$MemCopy                      __F__
    #REPLACE FN$MemSet                       __F__

    #REPLACE FN$IsSameCOMObject              __F__
    #REPLACE FN$IsNullCOMObject              __F__
    #REPLACE FN$NullCOMObject                __F__


    // 11.0 changes
    #REPLACE FN$FindByRowId                  __F__
    #REPLACE FN$GetRowId                     __F__
    #REPLACE FN$NullRowId                    __F__
    #REPLACE FN$IsNullRowId                  __F__
    #REPLACE FN$IsSameRowId                  __F__
    #REPLACE FN$SerializeRowId               __F__
    #REPLACE FN$DeSerializeRowId             __F__
    #REPLACE FN$SizeOfArray                  __F__
    #REPLACE FN$ResizeArray                  __F__
    #REPLACE FN$CStringLength                __F__
    #REPLACE FN$SizeOfType                   __F__ // size of any data type including structs

    // 11.1 changes
    #REPLACE FN$BinarySearchArray            __F__
    #REPLACE FN$CopyArray                    __F__
    #REPLACE FN$CountArray                   __F__
    #REPLACE FN$FillArray                    __F__
    #REPLACE FN$MinArray                     __F__
    #REPLACE FN$MaxArray                     __F__
    #REPLACE FN$ReverseArray                 __F__
    #REPLACE FN$SearchArray                  __F__
    #REPLACE FN$ShuffleArray                 __F__
    #REPLACE FN$SortArray                    __F__
    // 15.0 changes added post 15.0
    #REPLACE FN$RemoveFromArray              __F__
    #REPLACE FN$InsertInArray                __F__
    #REPLACE FN$RightPos                     __F__

  #ENDIF // is windows

    // Object commands
  #REPLACE OBJ$INIT         $0440
  #REPLACE OBJ$CREATE       $0441
  #REPLACE OBJ$ILIST        $0442
  #REPLACE OBJ$ITEM         $0443
  #REPLACE OBJ$ENDILIST     $0444
  #REPLACE OBJ$ACCLIST      $0445 // not used
  #REPLACE OBJ$ONKEY        $0446
  #REPLACE OBJ$ENDALIST     $0447 // not used
  #REPLACE OBJ$ENDDEFINE    $0448 // not used
  #REPLACE OBJ$IODISPATCH   $0449
  #REPLACE OBJ$SET          $044A
  #REPLACE OBJ$GET          $044B
  #REPLACE OBJ$SEND         $044C
  #REPLACE OBJ$FIX          $044D  // not used
  #REPLACE OBJ$END          $044E
  #REPLACE OBJ$FWDFIX       $044F  // not used
  #REPLACE OBJ$HRET         $0450
  #REPLACE OBJ$ITEM_EXEC    $0451
  #REPLACE OBJ$ACCEPT       $0452
  #REPLACE CREATE$CLASS     $0453
  #REPLACE HANDLE$FOR       $0454
  #REPLACE OBJ$END$HANDLER  $0455
  #REPLACE LOCAL$ARGUMENT   $0456
  #REPLACE FIND$OBJECT      $0457
  #REPLACE END$CLASS        $0458
  #REPLACE CREATE$SUB$PAGE  $0459
  #REPLACE CLONE$CLASS      $045A
  #REPLACE OBJ$ENTRY$ITEM   $045B
  #REPLACE MOVE$SUB$PAGE    $045C
  #REPLACE OBJ$TIMER        $045D
  #REPLACE SCREEN$OPT       $045E
  #REPLACE CREATE$PROPERTY  $045F
  #REPLACE REDEFINE$SUB$PAGE $0464

  //Focus modes:
  #REPLACE FOCUSABLE    |CI0
  #REPLACE NONFOCUSABLE |CI1
  #REPLACE POINTER_ONLY |CI2
  #REPLACE NO_ACTIVATE  |CI3

  //Search modes:
  #REPLACE FIRST_CHARACTER  |CI0
  #REPLACE INCREMENTAL      |CI1
  #REPLACE CAPITAL          |CI2
  #REPLACE NO_SEARCH        |CI3

  //Delegation modes:
  #REPLACE DELEGATE_TO_PARENT       |CI0
  #REPLACE NO_DELEGATE_OR_ERROR     |CI1
  #REPLACE NO_DELEGATION            |CI2
  #REPLACE RETURN_INVALID_MESSAGE   |CI3
  #REPLACE DELEGATE_PRIOR_LEVEL     |CI4

  //Location modes:
  #REPLACE ABSOLUTE         |CI0
  #REPLACE RELATIVE         |CI1
  #REPLACE ITEM_RELATIVE    |CI2

  //Sort modes:
  #REPLACE ASCENDING        |CI0
  #REPLACE DESCENDING       |CI1

  //Select Modes:
  #REPLACE NO_SELECT        |CI0
  #REPLACE SINGLE_SELECT    |CI1
  #REPLACE MULTI_SELECT     |CI2
  #REPLACE AUTO_SELECT      |CI3

  //Entry item options:
  #REPLACE IWINDOW          $C0A1
  #REPLACE IENTRY           $C0A2
  #REPLACE IEXIT            $C0A3
  #REPLACE IVALIDATE        $C0A4
  #REPLACE IZOOM            $C0A5
  #REPLACE IPROMPT          $C0A6

  //Import modes
  #REPLACE INHERIT          1
  #REPLACE NO_OVERWRITE     2

  //System integers
  #REPLACE CURRENT_OBJECT     |VI85
  #REPLACE SELF               |VI85  // as of 12.0 this is now part of fmac
  #REPLACE FORWARD$MESSAGE    |VI87
  #REPLACE CURRENT_MESSAGE    |VI88
  #REPLACE TOTAL_OBJECTS      |VI89

  // Define the desktop objects
  #REPLACE NULL_OBJECT          |CI0
  #REPLACE CLIPBOARD            |CI1
  #REPLACE CLIPBOARD.N          |CI0
  //#REPLACE DESKTOP              |CI2            // now defined in flex$init
  #REPLACE DESKTOP.N            |CI0
  //#REPLACE END_FUNCTION         END_PROCEDURE   // now defined in flex$init
  //#REPLACE PROCEDURE_RETURN     FUNCTION_RETURN // now defined in flex$init
  #REPLACE NO_IMAGE             |CI-9999

  #REPLACE CURRENT              |CI-99 //use current item#
  #REPLACE TOGGLE_STATE         |CI3   //toggle boolean state
  #REPLACE UPWARD_DIRECTION     |CI0   //scroll up
  #REPLACE DOWNWARD_DIRECTION   |CI1   //scroll down

//  #REPLACE GET_SCROLLBAR        |CI$4000
//  #REPLACE GET_CLIPBOARD        |CI$4001
//  #FREG |CI$4000 RETURNS INTEGER
//  #FREG |CI$4001 RETURNS INTEGER

// bumped up for 32-bit msg ids
  #REPLACE GET_SCROLLBAR        |CI$40000000
  #REPLACE GET_CLIPBOARD        |CI$40000001
  #FREG |CI$40000000 RETURNS INTEGER
  #FREG |CI$40000001 RETURNS INTEGER

  #REPLACE ERROR_OBJECT_ID      |VI100
  #REPLACE ERROR_TYPE           |VI101

  #REPLACE ERROR_CHILD_INHERITS_PARENT  |CI0
  #REPLACE ERROR_OFF_IN_CHILD           |CI1
  #REPLACE ERROR_DEFAULT_IN_CHILD       |CI2

  //deactivate search modes
  #REPLACE SCOPE_TYPE                   |CI1
  #REPLACE POPUP_TYPE                   |CI2
  #REPLACE AREA_TYPE                    |CI3

  //add_focus/activate/deactivate/release_focus error return codes
  #REPLACE ERROR_ENTERING               |CI1
  #REPLACE ERROR_EXITING                |CI2
  #REPLACE ERROR_ACTIVATING             |CI3
  #REPLACE ERROR_DEACTIVATING           |CI4
  #REPLACE ERROR_CANT_ACCEPT_FOCUS      |CI5
  #REPLACE ERROR_CANT_CREATE_TREE       |CI6
  #REPLACE ERROR_ADD_TO_INACTIVE_OBJECT |CI7
  #REPLACE ERROR_NO_FOCUSABLE_CHILDREN  |CI8

  // modes for peInNeighborHood
  #REPLACE nhNo         |CI0   // not a neighbor, check to see if parent is neighbor
  #REPLACE nhPublic     |CI1   // Is a neighbor hood, All descendant objects may address each other
  #REPLACE nhPrivate    |CI2   // Is a private neighborhood. descendants can not addres each other

  // alias data-types. These used to be in dll.pkg but are best defined here.
  #REPLACE Pointer Integer     // Parameter is a POINTER
  #REPLACE DWord Integer       // Parameter is a DWORD (32 bits)
  #REPLACE Handle DWord        // Parameter is a HANDLE (32 bits)
  #REPLACE Void_Type Integer   // Return type is  VOID

  // The following set of replacements define the type of load for the
  // DLL.  Each load type has the standard set of trade offs, speed
  // vs memory.  A lib that is loaded each time is probable the most memory
  // efficient, but suffers from load speed overhead.  However, large DLLs
  // that are retained in memory are not using system resources as
  // efficientry as possible.  Note that some DLLs are already in memory.
  // The Windows Kernel and USER libs are already loaded by Windows, and
  // do not take up more memory.
  // These are used by command SET_DEFAULT_CALLTYPE (which is actually rarely if ever used)

  #REPLACE LOAD_ON_EACH_USE |CI0     // Load and free on each call (slow)
  #REPLACE LOAD_LIBRARY     |CI1     // Load Lib on definition
  #REPLACE DELETE_ENTRY     |CI2     // Delete lib entry in reg DataBase
  #REPLACE FREE_LIBRARY     |CI4     // Free lib in Reg DataBase
  #REPLACE LOAD_ON_USE      |CI8     // Load lib on first use (call)




  #CHKSUB 1 1                   // Verify the UI subsystem.
  !A [] OBJ$INIT |CI0           // INITIALIZE_INTERFACE
  #FREF OBJ$DESK$NUM !a         // Number of desktop dependants
#ENDCOMMAND

// define all messages used by object system.  This is new to VDF7. All messages
// are now defined here.

// define all runtime messages common to VDF and CM DF

// Note: make sure number of lines in command is less than 1024

#COMMAND Define$BuiltIn$DF$Messages
  CMSG I GET_ACTIVE_STATE                  |CI$001
  CMSG I GET_PARENT                        |CI$002
  CMSG V SET_PARENT                        |CI$003     I
  CMSG I MSG_PAGE_OBJECT                   |CI$004     I
  CMSG I GET_LOCATION                      |CI$005
  CMSG V SET_LOCATION                      |CI$006     I  I
  CMSG I GET_ENTRY_MSG                     |CI$007
  CMSG V SET_ENTRY_MSG                     |CI$008     I
  CMSG I GET_EXIT_MSG                      |CI$009
  CMSG V SET_EXIT_MSG                      |CI$00A     I
  CMSG V SET_SIZE                          |CI$00B     I  I
  CMSG I GET_SIZE                          |CI$00C
  CMSG I GET_CURRENT_ITEM                  |CI$00D
  CMSG V SET_CURRENT_ITEM                  |CI$00E     I
  CMSG I GET_TOP_ITEM                      |CI$00F
  CMSG V SET_TOP_ITEM                      |CI$010     I
  CMSG S GET_VALUE                         |CI$011     I
  CMSG V SET_VALUE                         |CI$012     I  S
  CMSG I GET_MESSAGE                       |CI$013     I
  CMSG V SET_MESSAGE                       |CI$014     I  I
  CMSG I GET_ITEM_COUNT                    |CI$015
  CMSG V SET_ITEM_COUNT                    |CI$016     I
  CMSG I GET_SELECT_COUNT                  |CI$017
  CMSG V SET_SELECT_COUNT                  |CI$018     I
  CMSG I GET_MULTI_SELECT_MSG              |CI$019
  CMSG V SET_MULTI_SELECT_MSG              |CI$01A     I
  CMSG V SET_FOCUS_MODE                    |CI$01B     I
  CMSG I GET_FOCUS_MODE                    |CI$01C
  CMSG V SET_VISIBLE_STATE                 |CI$01D     I
  CMSG I GET_VISIBLE_STATE                 |CI$01E
  CMSG V SET_SELECT_MODE                   |CI$01F     I
  CMSG I GET_SELECT_MODE                   |CI$020
  CMSG V SET_WRAP_STATE                    |CI$021     I
  CMSG I GET_WRAP_STATE                    |CI$022
  CMSG V SET_SHADOW_STATE                  |CI$023     I  I
  CMSG I GET_SHADOW_STATE                  |CI$024     I
  CMSG I GET_SELECT_STATE                  |CI$025     I
  CMSG V SET_SELECT_STATE                  |CI$026     I  I
  CMSG V SET_AUTOCLEAR_STATE               |CI$027     I  I
  CMSG I GET_AUTOCLEAR_STATE               |CI$028     I
  CMSG V SET_CENTER_STATE                  |CI$029     I  I
  CMSG I GET_CENTER_STATE                  |CI$02A     I
  CMSG V SET_CHECKBOX_ITEM_STATE           |CI$02B     I  I
  CMSG I GET_CHECKBOX_ITEM_STATE           |CI$02C     I
  CMSG I MSG_STOP_UI                       |CI$02D
  CMSG S MSG_ERROR                         |CI$02E     I
  CMSG V MSG_HELP                          |CI$02F
  CMSG V MSG_BELL                          |CI$030
  CMSG V MSG_PAINT                         |CI$031
  CMSG V MSG_NONE                          |CI$032
  CMSG V MSG_EXIT                          |CI$033
  CMSG V MSG_NEXT                          |CI$034
  CMSG V MSG_PULL_RIGHT                    |CI$035
  CMSG V MSG_PULL_LEFT                     |CI$036
  CMSG I MSG_KEY                           |CI$037     I
  CMSG I MSG_INSERT_ITEM                   |CI$038     I  S
  CMSG I MSG_ADD_ITEM                      |CI$039     I  S
  CMSG V MSG_DELETE_ITEM                   |CI$03A     I
  CMSG V MSG_DELETE_DATA                   |CI$03B
  CMSG V MSG_SORT_ITEMS                    |CI$03C     I
  CMSG I GET_ITEM_MATCHING                 |CI$03D     S
  CMSG I GET_AUX_VALUE                     |CI$03E     I
  CMSG V SET_AUX_VALUE                     |CI$03F     I  I
  CMSG I GET_SEARCH_MODE                   |CI$040
  CMSG V SET_SEARCH_MODE                   |CI$041     I
  CMSG I GET_INVERSE_STATE                 |CI$042
  CMSG V SET_INVERSE_STATE                 |CI$043     I
  CMSG V MSG_SCROLL                        |CI$044     I  I
  CMSG V SET_CLASS_COLORS                  |CI$045     I  I  I
  CMSG I GET_HORIZONTAL_INCREMENT          |CI$046
  CMSG V SET_HORIZONTAL_INCREMENT          |CI$047     I
  CMSG V MSG_UP                            |CI$048
  CMSG V MSG_DOWN                          |CI$049
  CMSG V MSG_RIGHT                         |CI$04A
  CMSG V MSG_LEFT                          |CI$04B
  CMSG V MSG_BEGINNING_OF_DATA             |CI$04C
  CMSG V MSG_END_OF_DATA                   |CI$04D
  CMSG V MSG_BEGINNING_OF_PANEL            |CI$04E
  CMSG V MSG_END_OF_PANEL                  |CI$04F
  CMSG V MSG_BEGINNING_OF_LINE             |CI$050
  CMSG V MSG_END_OF_LINE                   |CI$051
  CMSG V MSG_PAGE_UP                       |CI$052
  CMSG V MSG_PAGE_DOWN                     |CI$053
  CMSG V SET_INSERT_MODE                   |CI$054     I
  CMSG V MSG_GOTO_LINE                     |CI$055     I
  CMSG V MSG_MOVE_ABSOLUTE                 |CI$056     I  I
  CMSG V MSG_MOVE_RELATIVE                 |CI$057     I  I
  CMSG V MSG_MARK_ON                       |CI$058
  CMSG V MSG_PASTE                         |CI$059     I  I  I
  CMSG V MSG_CUT                           |CI$05A     I  I  I
  CMSG V MSG_COPY                          |CI$05B     I  I  I
  CMSG V MSG_INSERT                        |CI$05C     S
  CMSG V MSG_DELETE_CHAR                   |CI$05D
  CMSG V MSG_DELETE_LINE                   |CI$05E
  CMSG V MSG_DELETE_TO_EOL                 |CI$05F
  CMSG I MSG_FIND                          |CI$060     S
  CMSG I MSG_REPLACE                       |CI$061     S  S
  CMSG V MSG_PRINT                         |CI$062
  CMSG I GET_MARK                          |CI$063
  CMSG I GET_CHANGED_STATE                 |CI$064
  CMSG V SET_CHANGED_STATE                 |CI$065     I
  CMSG V SET_RIGHT_MARGIN                  |CI$066     I
  CMSG I GET_LINE_COUNT                    |CI$067
  CMSG V SET_STATUS_LINE_STATE             |CI$068     I
  CMSG V SET_BLOCK_MOUSE_STATE             |CI$069     I
  CMSG I GET_BLOCK_MOUSE_STATE             |CI$06A
  CMSG V SET_COLUMN_MODE                   |CI$06B     I
  CMSG I GET_COLUMN_MODE                   |CI$06C
  CMSG V SET_FILE_NAME                     |CI$06D     S
  CMSG S GET_FILE_NAME                     |CI$06E
  CMSG V MSG_DEFAULT_KEY                   |CI$06F
  CMSG V SET_DYNAMIC_UPDATE_STATE          |CI$070     I
  CMSG I GET_FOCUS                         |CI$071
  CMSG V MSG_REFRESH_SCREEN                |CI$072     I
  CMSG V MSG_PREVIOUS                      |CI$073
  CMSG V SET_CHECK_STRING                  |CI$074     S  S
  CMSG I MSG_ACTIVATE                      |CI$075    V
  CMSG I MSG_ACTIVATE_GROUP                |CI$076
  CMSG I GET_MSG_DEACTIVATE                |CI$077     I        // <<< Awful hack!
  CMSG I MSG_DEACTIVATE                    |CI$077     I        // <<< Awful hack!
  CMSG I MSG_DEACTIVATE_GROUP              |CI$078
  CMSG V SET_LOCAL_ROTATE_STATE            |CI$079     I
  CMSG I GET_LOCAL_ROTATE_STATE            |CI$07A
  CMSG V SET_CLIENT_AREA_STATE             |CI$07B     I
  CMSG I GET_CLIENT_AREA_STATE             |CI$07C
  CMSG I GET_READ_ONLY_STATE               |CI$07D
  CMSG V SET_READ_ONLY_STATE               |CI$07E     I
  CMSG V SET_LINE_WIDTH                    |CI$07F     I  I
  CMSG I GET_LINE_SIZE                     |CI$080
  CMSG I GET_DISPLAY_SIZE                  |CI$081
  CMSG V SET_SCROLL_BAR_VISIBLE_STATE      |CI$082     I
  CMSG V SET_ORIGIN                        |CI$083     I  I
  CMSG I GET_ORIGIN                        |CI$084
  CMSG I GET_POSITION                      |CI$085
  CMSG I MSG_TRUE                          |CI$086
  CMSG I MSG_FALSE                         |CI$087
  CMSG I MSG_LAST_KEY_PRESSED              |CI$088
  CMSG V SET_RADIO_STRING                  |CI$089     S  S
  CMSG V SET_ENTRY_STATE                   |CI$08A     I  I
  CMSG I GET_ENTRY_STATE                   |CI$08B     I
  CMSG V MSG_READ                          |CI$08C
  CMSG V MSG_WRITE                         |CI$08D
  CMSG V SET_SCROLL_BAR_OFFSET             |CI$08E     I
  CMSG I GET_SCROLL_BAR_OFFSET             |CI$08F
  CMSG I MSG_ITEM_CHANGE                   |CI$090     I  I
  CMSG I GET_ITEM_CHANGED_STATE            |CI$091     I
  CMSG V SET_ITEM_CHANGED_STATE            |CI$092     I  I
  CMSG I GET_AUTO_TOP_ITEM_STATE           |CI$093
  CMSG V SET_AUTO_TOP_ITEM_STATE           |CI$094     I
  CMSG V SET_KBD_INPUT_MODE                |CI$095     I
  CMSG I MSG_SUPPLY_KEY                    |CI$096     I
  CMSG I GET_INSERT_MODE                   |CI$097
  CMSG I MSG_OK                            |CI$098
  CMSG I MSG_CANCEL                        |CI$099
  CMSG Q GET_ARRAY_VALUE                   |CI$09A     I      // This has a ghost untyped parameter
  CMSG V SET_ARRAY_VALUE                   |CI$09B     I  Q   // This has a ghost untyped parameter
  CMSG V MSG_CONSTRUCT_OBJECT              |CI$09C
  CMSG I MSG_ACTIVATING                    |CI$09D
  CMSG V MSG_TRACE_SWITCH                  |CI$09E     I  I
  CMSG V MSG_TRACE_MESSAGE                 |CI$09F
  CMSG V MSG_TRACE_STEP                    |CI$0A0     I
  CMSG V MSG_TRACE_OUTPUT                  |CI$0A1     S
  CMSG I MSG_DEACTIVATING                  |CI$0A2
  CMSG I GET_CLASS                         |CI$0A3
  CMSG S GET_HELP_NAME                     |CI$0A4
  CMSG V MSG_EXIT_APPLICATION              |CI$0A5
  CMSG V MSG_PRINT_SCREEN                  |CI$0A6     S
  CMSG I GET_RIGHT_MARGIN                  |CI$0A7
  CMSG I GET_DELEGATION_MODE               |CI$0A8
  CMSG V SET_DELEGATION_MODE               |CI$0A9     I
  CMSG I GET_BASE_CLASS                    |CI$0AA
  CMSG V SET_ITEM_ENTRY_MSG                |CI$0AB     I  I
  CMSG I GET_ITEM_ENTRY_MSG                |CI$0AC     I
  CMSG V SET_ITEM_EXIT_MSG                 |CI$0AD     I  I
  CMSG I GET_ITEM_EXIT_MSG                 |CI$0AE     I
  CMSG V SET_ITEM_VALIDATE_MSG             |CI$0AF     I  I
  CMSG I GET_ITEM_VALIDATE_MSG             |CI$0B0     I
  CMSG V SET_DATA_FILE                     |CI$0B1     I  I
  CMSG I GET_DATA_FILE                     |CI$0B2     I
  CMSG V SET_DATA_FIELD                    |CI$0B3     I  I
  CMSG I GET_DATA_FIELD                    |CI$0B4     I
  CMSG V SET_DATA_WINDOW                   |CI$0B5     I  I
  CMSG I GET_DATA_WINDOW                   |CI$0B6     I
  CMSG V SET_ITEM_OPTIONS                  |CI$0B7     I  I
  CMSG I GET_ITEM_OPTIONS                  |CI$0B8     I
  CMSG V SET_ITEM_OPTION                   |CI$0B9     I  I  I
  CMSG I GET_ITEM_OPTION                   |CI$0BA     I  I
  CMSG V MSG_ENTRY_UPDATE                  |CI$0BB     I  I
  CMSG V MSG_ENTRY_FIND                    |CI$0BC     I
  CMSG V MSG_ENTRY_SUPERFIND               |CI$0BD     I  I
  CMSG V MSG_ENTRY_DISPLAY                 |CI$0BE     I  I
  CMSG V MSG_ENTRY_CLEAR                   |CI$0BF     I
  CMSG I GET_VALIDATE_ITEMS                |CI$0C0     I
  CMSG I GET_ITEM_WINDOW                   |CI$0C1           // takes no params?
  CMSG V MSG_COPY_ITEMS                    |CI$0C2     *     // sav_cur_obj - params on the flex stack
  CMSG I GET_IMAGE_NUMBER                  |CI$0C3           // 6/2/98 5:39
  CMSG V MSG_ENTRY_CLEAR_ALL               |CI$0C4     I
  CMSG V MSG_SELECT_TOGGLING               |CI$0C5     I  I
  CMSG I GET_ITEM_ENTRY                    |CI$0C6     I
  CMSG I GET_ITEM_EXIT                     |CI$0C7     I
  CMSG I GET_ITEM_VALIDATE                 |CI$0C8     I
  CMSG I GET_READ_ONLY_ERROR               |CI$0C9     I  I
  CMSG S GET_NAME                          |CI$0CA
  CMSG I GET_ENTRY                         |CI$0CB
  CMSG V MSG_DESTROY_OBJECT                |CI$0CC     V
  CMSG V MSG_DESTROY_ALL_OBJECTS           |CI$0CD
  CMSG I GET_MOUSE_HIT                     |CI$0CE
  CMSG V SET_OBJECT_COLOR                  |CI$0CF     I  I
  CMSG V SET_ARROWS                        |CI$0D0     I  I  I
  CMSG V MSG_SWITCH                        |CI$0D1
  CMSG V MSG_SWITCH_BACK                   |CI$0D2
  CMSG I GET_WAS_FOUND                     |CI$0D3     I    // Invalid coding.
  CMSG I GET_STATUS_LINE_STATE             |CI$0D4
  CMSG V SET_HIGHLIGHT_STATE               |CI$0D5     I
  CMSG V MSG_ROTATE_UP                     |CI$0D6
  CMSG V MSG_POP_PAGES                     |CI$0D7
  CMSG V SET_CLASS                         |CI$0D8     I
  CMSG V MSG_FETCH_HELP                    |CI$0D9
  CMSG I GET_OBJECT_ID                     |CI$0DA
  CMSG V MSG_INIT_INSTANCE                 |CI$0DB
  CMSG I MSG_PAGE                          |CI$0DC     I
  CMSG I MSG_PAGE_DELETE                   |CI$0DD
  CMSG I GET_COLORS                        |CI$0DE
  CMSG I GET_BAR_LOCATION                  |CI$0DF
  CMSG V RETURN_LOCATION                   |CI$0E0     // called from "C" only. 2 pointer to ints.
  CMSG V CHANGE_LOCATION                   |CI$0E1     // called from "C" only. 2 pointer to ints.
  CMSG V MSG_WRITE_DBMS                    |CI$0E2     *   // variable params, pushed on to flex stack
  CMSG V MSG_READ_DBMS                     |CI$0E3     *   // variable params, pushed on to flex stack.
  CMSG S GET_STRING_VALUE                  |CI$0E4     I
  CMSG N GET_NUMBER_VALUE                  |CI$0E5     I
  CMSG D GET_DATE_VALUE                    |CI$0E6     I
  CMSG I GET_INTEGER_VALUE                 |CI$0E7     I
  CMSG R GET_REAL_VALUE                    |CI$0E8     I
  CMSG V SET_BASE_ITEM                     |CI$0E9     I
  CMSG I GET_BASE_ITEM                     |CI$0EA
  CMSG V SET_ITEM_LIMIT                    |CI$0EB     I
  CMSG I GET_ITEM_LIMIT                    |CI$0EC
  CMSG V MSG_MARK_OFF                      |CI$0ED
  CMSG V SET_SEARCH_CASE                   |CI$0EE     I
  CMSG V SET_PRIOR_FOCUS                   |CI$0EF     I
  CMSG I GET_PRIOR_FOCUS                   |CI$0F0
  CMSG V SET_NEXT_FOCUS                    |CI$0F1     I
  CMSG I GET_NEXT_FOCUS                    |CI$0F2
  CMSG V SET_SCROLLBAR                     |CI$0F3     I
  CMSG I GET_ASCII_STATE                   |CI$0F4
  CMSG V SET_ASCII_STATE                   |CI$0F5     I
  CMSG I GET_TEXT_INDENT                   |CI$0F6
  CMSG V SET_TEXT_INDENT                   |CI$0F7     I
  CMSG V MSG_ENTRY_AUTOFIND                |CI$0F8     I
  CMSG V SET_SCOPE_STATE                   |CI$0F9     I
  CMSG I GET_SCOPE_STATE                   |CI$0FA
  CMSG V MSG_MOUSE_CHANGE_FOCUS            |CI$0FB     I
  CMSG I GET_CHILD_COUNT                   |CI$0FC
  CMSG V MSG_MOUSE_UP                      |CI$0FD     I  I
  CMSG V MSG_MOUSE_UP2                     |CI$0FE     I  I
  CMSG V MSG_MOUSE_UP3                     |CI$0FF     I  I
  CMSG V MSG_MOUSE_CLICK                   |CI$100     I  I
  CMSG V MSG_MOUSE_CLICK2                  |CI$101     I  I
  CMSG V MSG_MOUSE_CLICK3                  |CI$102     I  I
  CMSG V MSG_MOUSE_DOWN                    |CI$103     I  I
  CMSG V MSG_MOUSE_DOWN2                   |CI$104     I  I
  CMSG V MSG_MOUSE_DOWN3                   |CI$105     I  I
  CMSG V MSG_MOUSE_DRAG                    |CI$106     I  I
  CMSG V MSG_MOUSE_DRAG2                   |CI$107     I  I
  CMSG V MSG_MOUSE_DRAG3                   |CI$108     I  I
  CMSG I GET_ABSOLUTE_MOUSE_LOCATION       |CI$109
  CMSG V SET_ABSOLUTE_MOUSE_LOCATION       |CI$10A     I  I  I
  CMSG I GET_DYNAMIC_UPDATE_STATE          |CI$10B
  CMSG V SET_MAX_LINES                     |CI$10C     I
  CMSG I GET_MAX_LINES                     |CI$10D
  CMSG V MSG_VIRTUAL_CONSOLE               |CI$10E
  CMSG I GET_NEXT_ENTRY_OK                 |CI$10F
  CMSG I GET_PREVIOUS_ENTRY_OK             |CI$110
  CMSG V SET_DYNAMIC_COLORS                |CI$111     I  I
  CMSG V SET_NEW_ITEM                      |CI$112     I
  CMSG V SET_BROADCAST_STATE               |CI$113     I
  CMSG I GET_BROADCAST_STATE               |CI$114
  CMSG I GET_WRAPPING                      |CI$115
  CMSG I GET_ROW_CHANGING                  |CI$116     I  I
  CMSG V MSG_ADD_FOCUS                     |CI$117     I
  CMSG V MSG_REMOVE_OBJECT                 |CI$118
  CMSG V MSG_RELEASE_FOCUS                 |CI$119
  CMSG I MSG_ENTERING                      |CI$11A
  CMSG I MSG_EXITING                       |CI$11B     I
  CMSG I MSG_ENTERING_SCOPE                |CI$11C
  CMSG I MSG_EXITING_SCOPE                 |CI$11D     I
  CMSG V MSG_SWITCH_NEXT_GROUP             |CI$11E
  CMSG V MSG_SWITCH_PRIOR_GROUP            |CI$11F
  CMSG I GET_CURRENT_SCOPE                 |CI$120
  CMSG V SET_CURRENT_SCOPE                 |CI$121     I
  CMSG V MSG_POPUP                         |CI$122
  CMSG V MSG_POPUP_GROUP                   |CI$123
  CMSG V SET_POPUP_STATE                   |CI$124     I
  CMSG I GET_POPUP_STATE                   |CI$125
  CMSG V SET_RING_STATE                    |CI$126     I
  CMSG I GET_RING_STATE                    |CI$127
  CMSG V MSG_MOVE_FOCUS_TREE               |CI$128     I
  CMSG V SET_PROMPT_OBJECT                 |CI$129     I  I
  CMSG I GET_PROMPT_OBJECT                 |CI$12A     I
  CMSG V SET_ZOOM_OBJECT                   |CI$12B     I  I
  CMSG I GET_ZOOM_OBJECT                   |CI$12C     I
  CMSG I GET_PRIOR_LEVEL                   |CI$12D
  CMSG I GET_NEXT_LEVEL                    |CI$12E
  CMSG I GET_PRIOR_SCOPE                   |CI$12F
  CMSG I GET_NEXT_SCOPE                    |CI$130
  CMSG V MSG_SWITCH_PRIOR_SCOPE            |CI$131
  CMSG V MSG_SWITCH_NEXT_SCOPE             |CI$132
  CMSG V SET_ATTACH_PARENT_STATE           |CI$133     I
  CMSG I GET_ATTACH_PARENT_STATE           |CI$134
  CMSG V MSG_CHILD_WRAPPING                |CI$135     I
  CMSG V SET_DISPLAY_MODE                  |CI$136     I  I
  CMSG I GET_DISPLAY_MODE                  |CI$137     I
  CMSG V MSG_COLOR_BLOCK                   |CI$138     I  I
  CMSG V MSG_NEXT_OBJECT                   |CI$139
  CMSG V MSG_PRIOR_OBJECT                  |CI$13A
  CMSG V SET_APPLICATION_NAME              |CI$13B     S
  CMSG S GET_APPLICATION_NAME              |CI$13C
  CMSG V SET_MODULE_NAME                   |CI$13D     S
  CMSG S GET_MODULE_NAME                   |CI$13E
  CMSG I GET_LAST_CHILD                    |CI$13F
  CMSG V SET_WINDOW_COLOR                  |CI$140     I  I
  CMSG I GET_WINDOW_COLOR                  |CI$141     I
  CMSG I MSG_PROCESS_KEY                   |CI$142     I
  CMSG V MSG_ACTIVATE_SCOPE                |CI$143
  CMSG I GET_FIND_SCOPE                    |CI$144
  CMSG I GET_SCOPE_FOCUS                   |CI$145
  CMSG I GET_VALID_ITEM                    |CI$146     I
  CMSG V MSG_UPDATE_DISPLAY                |CI$147
  CMSG V SET_ITEM                          |CI$148     I
  CMSG V MSG_TRACE_COMMAND                 |CI$149
  CMSG I GET_OBJECT_COLOR                  |CI$14A
  CMSG V SET_OBJECT_VALIDATION             |CI$14B     I
  CMSG I GET_OBJECT_VALIDATION             |CI$14C
  CMSG I GET_NEXT_OBJECT_ID                |CI$14D     I
  CMSG I GET_PRIOR_OBJECT_ID               |CI$14E     I
  CMSG I GET_CLASS_COLORS                  |CI$14F     I
  CMSG I GET_LOCATION_TYPE                 |CI$150
  CMSG I GET_OBJECT_SIZE                   |CI$151
  CMSG I GET_IN_USE_STATE                  |CI$152
  CMSG V SET_IN_USE_STATE                  |CI$153     I
  CMSG V MSG_ATTACH_DEO_TO_SERVER          |CI$154
  CMSG V MSG_REQUEST_CLEAR_ALL             |CI$155
  CMSG V MSG_CLEAR                         |CI$156
  CMSG V SET_CURRENT_RECORD                |CI$157     I
  CMSG I GET_CURRENT_RECORD                |CI$158
  CMSG V MSG_REBUILD_CONSTRAINTS           |CI$159
  CMSG V MSG_CONSTRAIN                     |CI$15A
  CMSG V SET_MAIN_FILE                     |CI$15B     I
  CMSG I GET_MAIN_FILE                     |CI$15C
  CMSG I GET_FIND_SERVER                   |CI$15D
  CMSG I GET_LOCATE_SERVER                 |CI$15E
  CMSG V MSG_MARK_AS_COMPONENT             |CI$15F
  CMSG V MSG_DELETING                      |CI$160
  CMSG I GET_VALIDATE_DELETE               |CI$161
  CMSG V MSG_REQUEST_DELETE                |CI$162
  CMSG V MSG_DISPLAY                       |CI$163
  CMSG V MSG_RELATE_MAIN_FILE              |CI$164
  CMSG V MSG_CLEAR_UI                      |CI$165
  CMSG V MSG_DISPLAY_UI                    |CI$166
  CMSG V MSG_REQUEST_ASSIGN                |CI$167     I
  CMSG I GET_VALIDATE_SAVE                 |CI$168
  CMSG V MSG_ATTACH_MAIN_FILE              |CI$169
  CMSG V MSG_REQUEST_CLEAR                 |CI$16A
  CMSG V MSG_BACKOUT                       |CI$16B
  CMSG V MSG_UPDATE                        |CI$16C
  CMSG V MSG_SAVE_MAIN_FILE                |CI$16D
  CMSG V MSG_DELETE_MAIN_FILE              |CI$16E
  CMSG I GET_ENTRY_PERMISSIVE_STATE        |CI$16F
  CMSG V SET_ENTRY_PERMISSIVE_STATE        |CI$170     I
  CMSG V SET_ORDERING                      |CI$171     I
  CMSG I GET_ORDERING                      |CI$172
  CMSG I GET_COMPONENT_STATE               |CI$173
  CMSG V SET_COMPONENT_STATE               |CI$174     I
  CMSG I GET_HAS_COMPONENTS_STATE          |CI$175
  CMSG V SET_HAS_COMPONENTS_STATE          |CI$176     I
  CMSG V MSG_REQUEST_SAVE                  |CI$177
  CMSG V MSG_REMOVE_FOCUS                  |CI$178
  CMSG V MSG_ATTACH_SERVER                 |CI$179     I
  CMSG V MSG_DETACH_SERVER                 |CI$17A     I
  CMSG V MSG_ATTACH_CLIENT                 |CI$17B     I
  CMSG V MSG_DETACH_CLIENT                 |CI$17C     I
  CMSG V MSG_ADD_USER_INTERFACE            |CI$17D     V
  CMSG V MSG_REMOVE_USER_INTERFACE         |CI$17E     V
  CMSG V MSG_MAIN_FILE_CHANGED             |CI$17F     I
  CMSG I GET_IS_SUPERFIND_REQUIRED         |CI$180     I
  CMSG V MSG_REQUEST_FIND                  |CI$181     I  I  I
  CMSG V MSG_ADD_PARENT_FILE               |CI$182     I
  CMSG V MSG_REMOVE_PARENT_FILE            |CI$183     I
  CMSG V MSG_REQUEST_SUPERFIND             |CI$184     I  I  I
  CMSG V MSG_REQUEST_READ                  |CI$185     I  I  I
  CMSG V MSG_READ_BY_RECNUM                |CI$186     I  I
  CMSG V MSG_FIND_BY_RECNUM                |CI$187     I  I
  CMSG V MSG_ESTABLISH_FIND_DIRECTION      |CI$188     I  I  I
  CMSG V MSG_LOCATE_NEXT                   |CI$189
  CMSG I GET_RECORD_NOT_FOUND              |CI$18A     I
  CMSG V MSG_INIT_CLASS                    |CI$18B
  CMSG V SET_IMAGE_NUMBER                  |CI$18C     I
  CMSG I GET_ROW                           |CI$18D     I
  CMSG I GET_CURRENT_ROW                   |CI$18E
  CMSG I GET_TOP_ROW                       |CI$18F
  CMSG I GET_BOTTOM_ITEM                   |CI$190
  CMSG I GET_BOTTOM_ROW                    |CI$191
  CMSG I GET_ROW_COUNT                     |CI$192
  CMSG I GET_DISPLAYABLE_ROWS              |CI$193
  CMSG V MSG_ADD_ROW                       |CI$194     I
  CMSG V MSG_INSERT_ROW                    |CI$195     I  I
  CMSG V SET_PALETTE_COLOR                 |CI$196     I  I  I
  CMSG I GET_PALETTE_COLOR                 |CI$197     I  I
  CMSG V SET_CLASS_PALETTE                 |CI$198     I  I
  CMSG I GET_CLASS_PALETTE                 |CI$199     I
  CMSG I GET_NO_DELETE_STATE               |CI$19A
  CMSG V SET_NO_DELETE_STATE               |CI$19B     I
  CMSG V MSG_REQUEST_ENTRY_UPDATE          |CI$19C     I  I
  CMSG V MSG_SCROLL_PAINT                  |CI$19D
  CMSG V MSG_SHOW_ITEM                     |CI$19E     I
  CMSG V SET_EXTERNAL_PAINT_STATE          |CI$19F     I
  CMSG I GET_EXTERNAL_PAINT_STATE          |CI$1A0
  CMSG V SET_MATRIX_SIZE                   |CI$1A1     I  I
  CMSG I GET_MATRIX_SIZE                   |CI$1A2
  CMSG V SET_SKIP_STATE                    |CI$1A3     I
  CMSG I GET_SKIP_STATE                    |CI$1A4
  CMSG I GET_REQUEST_VALIDATE              |CI$1A5
  CMSG I GET_AUTO_FILL_STATE               |CI$1A6
  CMSG V SET_AUTO_FILL_STATE               |CI$1A7     I
  CMSG I GET_FIND_PERMISSIVE_STATE         |CI$1A8
  CMSG V SET_FIND_PERMISSIVE_STATE         |CI$1A9     I
  CMSG V MSG_TRANSACTION_ABORTED           |CI$1AA     I
  CMSG V MSG_CLEAR_ALL                     |CI$1AB
  CMSG V MSG_CREATING                      |CI$1AC
  CMSG V MSG_DESTROYING                    |CI$1AD
  CMSG I GET_SHOULD_SAVE                   |CI$1AE
  CMSG I GET_WHICH_DATA_SET                |CI$1AF     I
  CMSG I GET_VALIDATE_CONSTRAINTS          |CI$1B0
  CMSG V MSG_ERROR_REPORT                  |CI$1B1     V
  CMSG V MSG_REQUEST_RELATE                |CI$1B2     I
  CMSG S GET_ERROR_TEXT                    |CI$1B3     I
  CMSG I GET_SUGGESTED_ORDERING            |CI$1B4
  CMSG V SET_SUGGESTED_ORDERING            |CI$1B5     I
  CMSG I GET_NO_RELATE_STATE               |CI$1B6
  CMSG V SET_NO_RELATE_STATE               |CI$1B7     I
  CMSG I GET_WINDOW_LOCATION               |CI$1B8     I
  CMSG I GET_SIGNON_STATUS                 |CI$1B9
  CMSG V MSG_ADD_WATCHER                   |CI$1BA     I
  CMSG V MSG_REMOVE_WATCHER                |CI$1BB     I
  CMSG I GET_SEARCH_CASE                   |CI$1BC
  CMSG I GET_SHOULD_SAVE_ROW               |CI$1BD
  CMSG V MSG_DISPLAY_STATUS                |CI$1BE     S
  CMSG V MSG_CLEAR_SET                     |CI$1BF
  CMSG I GET_AUTOFIND_ITEM                 |CI$1C0
  CMSG V SET_KEY_PATH                      |CI$1C1     I
  CMSG I GET_KEY_PATH                      |CI$1C2
  CMSG I GET_CAN_DELETE                    |CI$1C3
  CMSG V MSG_UPDATE_DEPENDENT_ITEMS        |CI$1C4
  CMSG I GET_SUPERFIND_FIELD               |CI$1C5     I  I
  CMSG V MSG_REFRESH                       |CI$1C6     I
  CMSG V MSG_PROCESS_ACCELERATOR           |CI$1C7     I  I
  CMSG I GET_ERROR_TEXT_AVAILABLE          |CI$1C8     I
  CMSG I GET_PROTOTYPE_OBJECT              |CI$1C9
  CMSG V MSG_REFIND_RECORDS                |CI$1CA
  CMSG V MSG_END_CONSTRUCT_OBJECT          |CI$1CB
  CMSG V MSG_CLEAR_MAIN_FILE               |CI$1CC
  CMSG V MSG_REQUEST_CLEAR_FILE            |CI$1CD     I
  CMSG I GET_CALLBACK                      |CI$1CE     S  I
  CMSG I GET_IS_CRITICAL                   |CI$1CF     I
  CMSG I GET_VIRTUAL_CONSOLE               |CI$1D0
  CMSG V SET_VIRTUAL_CONSOLE               |CI$1D1     I
  CMSG I GET_KBD_INPUT_MODE                |CI$1D2
  CMSG I GET_VERIFY_RETRY                  |CI$1D3

  // added to VDF 8.2
  CMSG I GET_PENEIGHBORHOOD                |CI$0539    // get peNeighborHood to eHood
  CMSG I SET_PENEIGHBORHOOD                |CI$053A    // set peNeighborHood to nhPrivate|nhPublic|nhNo
  CMSG I GET_ONCHILDWRAPPING               |CI$053B    // get onChildWrapping hoDest bDown to hoNewDest
  CMSG I GET_CONTAINSFOCUS                 |CI$053C    // get ContainsFocus to bHasFocus
  CMSG I GET_RINGPARENT                    |CI$053D    // get RingParent to hoRingOwner
  CMSG I GET_ISCOLUMNVISIBLE               |CI$053e    // get IsColumnVisible iColumn to bIsVisible
  CMSG I MSG_DOMAKECOLUMNVISIBLE           |CI$053f    // Send DoMakeColumnVisible iColumn
  CMSG I GET_PBAUTOFILLFROMFIRST           |CI$0540    // Get/Set pbAutoFillFromFirst to bFirst (true=dflt)
  CMSG I SET_PBAUTOFILLFROMFIRST           |CI$0541
  CMSG I GET_PBINHERITCONSTRAINTS          |CI$057A    // should DSO/DDO inherit constraints from servers (dflt=true)
  CMSG I SET_PBINHERITCONSTRAINTS          |CI$057B

#ENDCOMMAND

// define all runtime messages used just by VDF
// Note: make sure number of lines in command is less than 1024
#COMMAND Define$BuiltIn$VDF$Messages

  CMSG I GET_FONT                          |CI$1D4
  CMSG V SET_MAP_MODE                      |CI$1D5     I
  CMSG I GET_MAP_MODE                      |CI$1D6
  CMSG V SET_TYPEFACE                      |CI$1D7     S
  CMSG S GET_TYPEFACE                      |CI$1D8
  CMSG V SET_FONTSIZE                      |CI$1D9     I  I
  CMSG I GET_FONTSIZE                      |CI$1DA
  CMSG V SET_FONTWEIGHT                    |CI$1DB     I
  CMSG I GET_FONTWEIGHT                    |CI$1DC
  CMSG V SET_FONTITALICS                   |CI$1DD     I
  CMSG I GET_FONTITALICS                   |CI$1DE
  CMSG V SET_FONTUNDERLINE                 |CI$1DF     I
  CMSG I GET_FONTUNDERLINE                 |CI$1E0
  CMSG I GET_FOREIGNLINK                   |CI$1E1
  CMSG V SET_FOREIGNLINK                   |CI$1E2     I
  CMSG I GET_ACKSTATE                      |CI$1E3
  CMSG V SET_ACKSTATE                      |CI$1E4     I
  CMSG I GET_LINKTEMPERATURE               |CI$1E5
  CMSG V SET_LINKTEMPERATURE               |CI$1E6     I
  CMSG I GET_RETRYCOUNT                    |CI$1E7
  CMSG V SET_RETRYCOUNT                    |CI$1E8     I
  CMSG I GET_DDE_INITIATE                  |CI$1E9     I  S
  CMSG S GET_SESS_REQUEST                  |CI$1EA     S
  CMSG I GET_SESS_RECEIVE                  |CI$1EB     S  S
  CMSG I GET_SESS_TERMINATE                |CI$1EC
  CMSG I GET_SESS_EXECUTE                  |CI$1ED     S
  CMSG I GET_SESS_CONNECT                  |CI$1EE     S  S
  CMSG S GET_SESS_READ                     |CI$1EF     S
  CMSG I GET_SESS_WRITE                    |CI$1F0     S  S
  CMSG I GET_SESS_DISCONNECT               |CI$1F1
  CMSG I GET_SESS_PERFORM                  |CI$1F2     S
  CMSG I GET_PRIVATEFOREIGNLINK            |CI$1F3
  CMSG V SET_PRIVATEFOREIGNLINK            |CI$1F4     I
  CMSG I GET_GUILOCATION                   |CI$1F5
  CMSG V SET_GUILOCATION                   |CI$1F6     I  I
  CMSG I GET_MAP_RATIOS                    |CI$1F7
  CMSG V SET_MAP_RATIOS                    |CI$1F8     I  I
  CMSG I GET_BORDER_STYLE                  |CI$1F9
  CMSG V SET_BORDER_STYLE                  |CI$1FA     I
  CMSG I GET_CLIPPING_MODE                 |CI$1FB
  CMSG V SET_CLIPPING_MODE                 |CI$1FC     I
  CMSG I GET_CAPTION_BAR                   |CI$1FD
  CMSG V SET_CAPTION_BAR                   |CI$1FE     I
  CMSG I GET_MINIMIZE_ICON                 |CI$1FF
  CMSG V SET_MINIMIZE_ICON                 |CI$200     I
  CMSG I GET_MAXIMIZE_ICON                 |CI$201
  CMSG V SET_MAXIMIZE_ICON                 |CI$202     I
  CMSG I GET_SYSMENU_ICON                  |CI$203
  CMSG V SET_SYSMENU_ICON                  |CI$204     I
  CMSG I GET_VIEW_MODE                     |CI$205
  CMSG V SET_VIEW_MODE                     |CI$206     I
  CMSG I GET_BORDER_WIDTH                  |CI$207
  CMSG V SET_BORDER_WIDTH                  |CI$208     I
  CMSG I GET_SCROLL_RANGE                  |CI$209
  CMSG V SET_SCROLL_RANGE                  |CI$20A     I  I
  CMSG I GET_PAGESIZE                      |CI$20B
  CMSG V SET_PAGESIZE                      |CI$20C     I
  CMSG I GET_LINESIZE                      |CI$20D
  CMSG V SET_LINESIZE                      |CI$20E     I
  CMSG I GET_COLUMN_WIDTH                  |CI$20F
  CMSG V SET_COLUMN_WIDTH                  |CI$210     I
  CMSG I GET_SORTED_STATE                  |CI$211
  CMSG V SET_SORTED_STATE                  |CI$212     I
  CMSG I GET_UNDO                          |CI$213
  CMSG I GET_ITEM_TYPE                     |CI$214     I
  CMSG V SET_ITEM_TYPE                     |CI$215     I  I
  CMSG I GET_SELECTED_OBJECTID             |CI$216
  CMSG V SET_FORM_WIDTH                    |CI$217     I  I
  CMSG I GET_FORM_WIDTH                    |CI$218     I
  // This message isn't really used anymore, except once in the IDE.
  CMSG V SET_FORM_COLOR                    |CI$219     I  I  I
  CMSG I GET_FORM_COLOR                    |CI$21A     I
  CMSG V SET_FORM_DATATYPE                 |CI$21B     I  I
  CMSG I GET_FORM_DATATYPE                 |CI$21C     I
  CMSG V SET_FORM_OPTIONS                  |CI$21D     I  I
  CMSG I GET_FORM_OPTIONS                  |CI$21E     I
  CMSG V SET_FORM_FONT                     |CI$21F     I  I
  CMSG I GET_FORM_FONT                     |CI$220     I
  CMSG V SET_FORM_ROW                      |CI$221     I  I
  CMSG I GET_FORM_ROW                      |CI$222     I
  CMSG V SET_FORM_COLUMN                   |CI$223     I  I
  CMSG I GET_FORM_COLUMN                   |CI$224     I
  CMSG V SET_JUSTIFICATION_MODE            |CI$225     I
  CMSG I GET_JUSTIFICATION_MODE            |CI$226
  CMSG V SET_FORM_TYPEFACE                  |CI$227     I  S
  CMSG S GET_FORM_TYPEFACE                  |CI$228     I
  CMSG V SET_FORM_FONTHEIGHT                |CI$229     I  I
  CMSG I GET_FORM_FONTHEIGHT                |CI$22A     I
  CMSG V SET_FORM_FONTWEIGHT                |CI$22B     I  I
  CMSG I GET_FORM_FONTWEIGHT                |CI$22C     I
  CMSG V SET_FORM_FONTITALICS               |CI$22D     I  I
  CMSG I GET_FORM_FONTITALICS               |CI$22E     I
  CMSG V SET_FORM_FONTUNDERLINE             |CI$22F     I  I
  CMSG I GET_FORM_FONTUNDERLINE             |CI$230     I
  CMSG V SET_NAME                          |CI$231     S
  CMSG V SET_BITMAP                        |CI$232     S
  CMSG V SET_BUTTON_ASPECT                 |CI$233     I  I
  CMSG I GET_BUTTON_ASPECT                 |CI$234     I
  CMSG V SET_BUTTON_POSITION               |CI$235     I
  CMSG I GET_BUTTON_POSITION               |CI$236
  CMSG I GET_ITEM_COLOR                    |CI$237     I
  CMSG I GET_BANDED_OBJECT                 |CI$238
  CMSG V SET_FORM_HEIGHT                   |CI$239     I  I
  CMSG I GET_FORM_HEIGHT                   |CI$23A     I
  CMSG V SET_AUTO_ALIGN                    |CI$23B     I
  CMSG I GET_AUTO_ALIGN                    |CI$23C
  CMSG V SET_COMBO_DATA_OBJECT             |CI$23D     I
  CMSG I GET_COMBO_DATA_OBJECT             |CI$23E
  CMSG V SET_LINE_THICKNESS                |CI$23F     I
  CMSG I GET_LINE_THICKNESS                |CI$240
  CMSG V SET_LINE_OFFSET                   |CI$241     I
  CMSG I GET_LINE_OFFSET                   |CI$242
  CMSG V SET_WINDOW_HANDLE                 |CI$243     I
  CMSG I GET_CONTAINER_HANDLE              |CI$244
  CMSG V SET_HORIZONTAL_STATE              |CI$245     I
  CMSG I GET_HORIZONTAL_STATE              |CI$246
  CMSG V MSG_LOAD_FORM_FROM_PAGE           |CI$247     I                 // 6:36 6/2/98
  CMSG V SET_FORM_GUIWIDTH                 |CI$248     I  I
  CMSG I GET_FORM_GUIWIDTH                 |CI$249     I
  CMSG V SET_FORM_GUIHEIGHT                |CI$24A     I  I
  CMSG I GET_FORM_GUIHEIGHT                |CI$24B     I
  CMSG V SET_FORM_GUIROW                   |CI$24C     I  I
  CMSG I GET_FORM_GUIROW                   |CI$24D     I
  CMSG V SET_FORM_GUICOLUMN                |CI$24E     I  I
  CMSG I GET_FORM_GUICOLUMN                |CI$24F     I
  CMSG V MSG_HSCROLL                       |CI$250     I  I
  CMSG V MSG_EXPORT_CLIPBOARD_DATA         |CI$251
  CMSG V MSG_IMPORT_CLIPBOARD_DATA         |CI$252
  CMSG V SET_FORM_MARGIN                   |CI$253     I  I
  CMSG I GET_FORM_MARGIN                   |CI$254     I
  CMSG V MSG_ENUMERATE_FONTS               |CI$255     S
  CMSG I GET_USER_FONTNAME                 |CI$256     S  I
  CMSG V SET_ICON                          |CI$257     S
  CMSG I GET_PARENT_RATIOS                 |CI$258
  CMSG V SET_BANDING_OBJECT                |CI$259     I
  CMSG I GET_BANDING_OBJECT                |CI$25A
  CMSG V MSG_MAKE_PROPORTIONAL             |CI$25B     I  I
  CMSG I GET_PHYSICAL_FONTSIZE             |CI$25C
  CMSG V MSG_SYSTEM_HELP                   |CI$25D     S  S
  CMSG S GET_DLL_NAME                      |CI$25E
  CMSG V SET_LINE_STYLE                    |CI$25F     I
  CMSG I GET_LINE_STYLE                    |CI$260
  CMSG V MSG_CHOOSE                        |CI$261
  CMSG V SET_TOP_LINE_COLOR                |CI$262     I
  CMSG I GET_TOP_LINE_COLOR                |CI$263
  CMSG V SET_BOTTOM_LINE_COLOR             |CI$264     I
  CMSG I GET_BOTTOM_LINE_COLOR             |CI$265
  CMSG V SET_FOREGROUND_COLOR              |CI$266     I
  CMSG I GET_FOREGROUND_COLOR              |CI$267
  CMSG V SET_BKGRND_COLOR                  |CI$268     I
  CMSG I GET_BKGRND_COLOR                  |CI$269
  CMSG I GET_BRUSH                         |CI$26A
  CMSG V MSG_EXIT_CASCADE                  |CI$26B
  CMSG V MSG_REDIRECT_MESSAGE              |CI$26C
  CMSG V MSG_ACTIVATE_PULL_DOWN            |CI$26D
  CMSG V SET_ACTION_BAR_LOCATION           |CI$26E     I
  CMSG I GET_ACTION_BAR_KEYS_MSG           |CI$26F
  CMSG V SET_ACTION_BAR_KEYS_MSG           |CI$270     I
  CMSG V SET_AUTO_SCALE_FONT_STATE         |CI$271     I
  CMSG I GET_AUTO_SCALE_FONT_STATE         |CI$272
  CMSG V MSG_SCALE_FONTS                   |CI$273
  CMSG V SET_FORM_OPTION                   |CI$274     I  I  I
  CMSG I GET_FORM_OPTION                   |CI$275     I  I
  CMSG V MSG_ADJUST_LOGICALS               |CI$276
  CMSG V SET_PHYSICAL_FONTSIZE             |CI$277     I  I
  CMSG I GET_EXIT_SYSTEM_CONFIRMATION      |CI$278
  CMSG V SET_CAPTION_BAR_HIGHLIGHT         |CI$279     I
  CMSG V MSG_ACTIVATE_SYSMENU              |CI$27A     I
  CMSG V SET_HIGHLIGHT_ROW_TEXT_COLOR      |CI$27b     I
  CMSG I GET_HIGHLIGHT_ROW_TEXT_COLOR      |CI$27c
  CMSG V SET_CURRENT_ITEM_TEXT_COLOR       |CI$27d     I
  CMSG I GET_CURRENT_ITEM_TEXT_COLOR       |CI$27e
  CMSG V SET_ITEM_TEXT_COLOR               |CI$27f     I  I
  CMSG I GET_ITEM_TEXT_COLOR               |CI$280     I
  CMSG I GET_TEXT_EXTENT                   |CI$281     S
  CMSG V MSG_SYSTEM_CONTEXT_HELP           |CI$282     S  I
  CMSG V SET_MOUSE_CAPTURE                 |CI$283
  CMSG I GET_MOUSE_CAPTURE                 |CI$284
  CMSG V MSG_RELEASE_MOUSE_CAPTURE         |CI$285
  CMSG V SET_WINDOW_STYLE                  |CI$286     I  I
  CMSG I GET_WINDOW_STYLE                  |CI$287     I
  CMSG V MSG_COMMAND                       |CI$288     I  I
  CMSG I GET_GUISIZE                       |CI$289
  CMSG V SET_GUISIZE                       |CI$28A     I  I
  CMSG I GET_ABSOLUTE_GUIORIGIN            |CI$28B
  CMSG I GET_WINDOW_HANDLE                 |CI$28C
  CMSG V SET_FONT                          |CI$28D     I
  CMSG V MSG_NOTIFY_FOCUS_CHANGE           |CI$28E     I
  CMSG V MSG_EXIT_MENU                     |CI$28F
  CMSG I GET_CURSOR                        |CI$290
  CMSG V SET_CURSOR                        |CI$291     I
  CMSG I GET_DATA_SET_SERVER               |CI$292     I
  CMSG I GET_DATA_SET_CLIENT               |CI$293     I
  CMSG I GET_DATA_SET_USER_INTERFACE       |CI$294     I
  CMSG I GET_DATA_SET_SERVER_COUNT         |CI$295
  CMSG I GET_DATA_SET_CLIENT_COUNT         |CI$296
  CMSG I GET_DATA_SET_USER_INTERFACE_COUNT |CI$297
  CMSG V SET_ALWAYS_REFRESH_STATE          |CI$298     I
  CMSG I GET_ALWAYS_REFRESH_STATE          |CI$299
  CMSG V MSG_RESET_FILEMODES_FOR_LOCK      |CI$29A
  CMSG V SET_SMART_FILEMODE_STATE          |CI$29B     I
  CMSG I GET_SMART_FILEMODE_STATE          |CI$29C
  CMSG V SET_SMART_FILEMODE_FOR_LOCK       |CI$29D     I
  CMSG I GET_SMART_FILEMODE_FOR_LOCK       |CI$29E
  CMSG V SET_SMART_FILEMODE_FOR_NO_LOCK    |CI$29F     I
  CMSG I GET_SMART_FILEMODE_FOR_NO_LOCK    |CI$2A0
  CMSG V SET_CASCADE_DELETE_STATE          |CI$2A1     I
  CMSG I GET_CASCADE_DELETE_STATE          |CI$2A2
  CMSG I GET_VALIDATE_DELETE_NO_CASCADE    |CI$2A3
  CMSG V MSG_ADD_CLIENT_FILE               |CI$2A4     I
  CMSG V MSG_REMOVE_CLIENT_FILE            |CI$2A5     I
  CMSG I GET_CLIENT_FILE                   |CI$2A6     I
  CMSG I GET_CLIENT_FILE_COUNT             |CI$2A7
  CMSG V MSG_ADD_SERVER_FILE               |CI$2A8     I
  CMSG V MSG_REMOVE_SERVER_FILE            |CI$2A9     I
  CMSG I GET_SERVER_FILE                   |CI$2AA     I
  CMSG I GET_SERVER_FILE_COUNT             |CI$2AB
  CMSG I GET_PARENT_FILE                   |CI$2AC     I
  CMSG I GET_PARENT_FILE_COUNT             |CI$2AD
  CMSG V MSG_OPERATION_NOT_ALLOWED         |CI$2AE     I
  CMSG V MSG_NEW_CURRENT_RECORD            |CI$2AF     I  I
  CMSG V SET_EXTERNAL_CLASS_NAME           |CI$2B0     S  S
  CMSG V SET_EXTERNAL_MESSAGE              |CI$2B1     I  I
  CMSG V MSG_WINDOWS_MESSAGE               |CI$2B2     I  I  I
  CMSG V SET_HEADER_LABEL                  |CI$2B3     I  S
  CMSG S GET_HEADER_LABEL                  |CI$2B4     I
  CMSG V SET_FORM_BITMAP                   |CI$2B5     I  S
  CMSG V SET_HIGHLIGHT_ROW_STATE           |CI$2B6     I
  CMSG I GET_HIGHLIGHT_ROW_STATE           |CI$2B7
  CMSG V SET_HIGHLIGHT_ROW_COLOR           |CI$2B8     I
  CMSG I GET_HIGHLIGHT_ROW_COLOR           |CI$2B9
  CMSG V SET_HEADER_VISIBLE_STATE          |CI$2BA     I
  CMSG I GET_HEADER_VISIBLE_STATE          |CI$2BB
  CMSG V MSG_BEGIN_EVENT                   |CI$2BC     I
  CMSG V MSG_END_EVENT                     |CI$2BD     I
  CMSG V SET_FOCUS                         |CI$2BE     I  I
  CMSG V SET_FORM_STYLE                    |CI$2BF     I  I
  CMSG I GET_FORM_STYLE                    |CI$2C0     I
  CMSG V SET_FORM_EXTENDED_STYLE           |CI$2C1     I  I
  CMSG I GET_FORM_EXTENDED_STYLE           |CI$2C2     I
  CMSG V SET_FORM_BORDER                   |CI$2C3     I  I
  CMSG I GET_FORM_BORDER                   |CI$2C4     I
  CMSG V SET_GRIDLINE_MODE                 |CI$2C5     I
  CMSG I GET_GRIDLINE_MODE                 |CI$2C6
  CMSG V MSG_CREATE_DIALOG                 |CI$2C7     I  I
  CMSG I GET_MAPI_SEND_DOCUMENTS           |CI$2C8     S  S
  CMSG I GET_MAPI_INITMESSAGE              |CI$2C9     S  S
  CMSG I GET_MAPI_SEND_MAIL                |CI$2CA     I
  CMSG I GET_MAPI_ADDRESS_BOOK              |CI$2CB     S  I
  CMSG S GET_MAPI_FIND_NEXT                 |CI$2CC     S  I
  CMSG S GET_MAPI_MESSAGE_SUBJECT          |CI$2CD
  CMSG I GET_MAPI_READMAIL                 |CI$2CE     S  I
  CMSG S GET_MAPI_MESSAGE_SENDERNAME       |CI$2CF
  CMSG S GET_MAPI_MESSAGE_DATERECEIVED     |CI$2D0
  CMSG V MSG_EDIT_TO_MAIL                  |CI$2D1     I
  CMSG V MSG_MAIL_TO_EDIT                  |CI$2D2     I
  CMSG I MSG_NOTIFY                        |CI$2D3     I  I
  CMSG S GET_MAPI_MESSAGE_RECEIVERNAME     |CI$2D4     I
  CMSG V SET_BITMAP_SIZE                   |CI$2D5     I  I
  CMSG V SET_IMAGELIST_SIZE                |CI$2D6     I  I
  CMSG V SET_IMAGELIST_TYPE                |CI$2D7     I
  CMSG V MSG_IMAGELIST_CREATE              |CI$2D8
  CMSG V MSG_IMAGELIST_DESTROY             |CI$2D9
  CMSG V MSG_IMAGELIST_ADD                 |CI$2DA     S
  CMSG V MSG_IMAGELIST_BEGINDRAG           |CI$2DB     I
  CMSG V SET_IMAGELIST_DRAGOBJECT          |CI$2DC     I
  CMSG V MSG_IMAGELIST_DRAGENTER           |CI$2DD     I  I
  CMSG V MSG_IMAGELIST_DRAGMOVE            |CI$2DE     I  I
  CMSG V MSG_IMAGELIST_DRAGLEAVE           |CI$2DF     I
  CMSG V MSG_IMAGELIST_ENDDRAG             |CI$2E0
  CMSG I GET_IMAGELIST_DRAGOBJECT          |CI$2E1
  CMSG V SET_TOOLTIP_STATE                 |CI$2E2     I
  CMSG I GET_TOOLTIP_STATE                 |CI$2E3
  CMSG V SET_TOOLTIP_VALUE                 |CI$2E4     I  S
  CMSG S GET_TOOLTIP_VALUE                 |CI$2E5     I
  CMSG V SET_IMAGELIST                     |CI$2E6     I
  CMSG V SET_FORM_IMAGE_INDEX              |CI$2E7     I  I
  CMSG I GET_FORM_IMAGE_INDEX              |CI$2E8     I
  CMSG V SET_BUTTON_STYLE                  |CI$2E9     I  I
  CMSG I GET_BUTTON_STYLE                  |CI$2EA     I
  CMSG V MSG_AUTO_SIZE                     |CI$2EB     I  I
  CMSG V MSG_AUTO_PAGE                     |CI$2EC     I
  CMSG V SET_TIMEOUT_VALUE                 |CI$2ED     I
  CMSG I GET_TIMEOUT_VALUE                 |CI$2EE
  CMSG V SET_LEFT_MARGIN                   |CI$2EF     I
  CMSG I GET_LEFT_MARGIN                   |CI$2F0
  CMSG V SET_STATUS_LINE_OBJECT            |CI$2F1     I
  CMSG I GET_STATUS_LINE_OBJECT            |CI$2F2
  CMSG V SET_WINDOWS_OVERRIDE_STATE        |CI$2F3     I
  CMSG I GET_WINDOWS_OVERRIDE_STATE        |CI$2F4
  CMSG I GET_MENU_HANDLE                   |CI$2F5
  CMSG V MSG_INITIALIZE_MENU               |CI$2F6     I
  CMSG V MSG_CHANGE_MENU                   |CI$2F7     I  I  I
  CMSG V MSG_UNDO                          |CI$2F8
  CMSG V MSG_DELETE                        |CI$2F9
  CMSG V SET_HEADER_JUSTIFICATION_MODE     |CI$2FA     I  I
  CMSG I GET_HEADER_JUSTIFICATION_MODE     |CI$2FB     I
  CMSG V SET_BITMAP_FORMAT                 |CI$2FC     I
  CMSG I GET_BITMAP_FORMAT                 |CI$2FD
  CMSG V SET_PASSWORD_STATE                |CI$2FE     I  I
  CMSG I GET_PASSWORD_STATE                |CI$2FF     I
  CMSG V SET_MDI_STATE                     |CI$300     I
  CMSG I GET_MDI_STATE                     |CI$301
  CMSG V SET_MDI_LEFT_MARGIN               |CI$302     I
  CMSG I GET_MDI_LEFT_MARGIN               |CI$303
  CMSG V SET_MDI_TOP_MARGIN                |CI$304     I
  CMSG I GET_MDI_TOP_MARGIN                |CI$305
  CMSG V SET_MDI_RIGHT_MARGIN              |CI$306     I
  CMSG I GET_MDI_RIGHT_MARGIN              |CI$307
  CMSG V SET_MDI_BOTTOM_MARGIN             |CI$308     I
  CMSG I GET_MDI_BOTTOM_MARGIN             |CI$309
  CMSG V SET_MDI_WINDOW_PULLDOWN           |CI$30A     I
  CMSG I GET_MDI_WINDOW_PULLDOWN           |CI$30B
  CMSG V MSG_ARRANGE_ICONS                 |CI$30C
  CMSG V MSG_CASCADE_WINDOWS               |CI$30D
  CMSG V MSG_TILE_WINDOWS_HORIZONTAL       |CI$30E
  CMSG V MSG_TILE_WINDOWS_VERTICAL         |CI$30F
  CMSG V MSG_SWITCH_NEXT_VIEW              |CI$310
  CMSG V MSG_SWITCH_PRIOR_VIEW             |CI$311
  CMSG I GET_FORM_WINDOW_HANDLE            |CI$312     I
  CMSG V MSG_NOTIFY_APPLICATION_ACTIVATION |CI$313     I
  CMSG V SET_RESIZE_COLUMN_STATE           |CI$314     I
  CMSG I GET_RESIZE_COLUMN_STATE           |CI$315
  CMSG V SET_AUTOSIZE_HEIGHT_STATE         |CI$316     I
  CMSG I GET_AUTOSIZE_HEIGHT_STATE         |CI$317
  CMSG V SET_CURRENT_ITEM_COLOR            |CI$318     I
  CMSG I GET_CURRENT_ITEM_COLOR            |CI$319
  CMSG V MSG_INITIALIZE_SYSMENU            |CI$31A     I
  CMSG V SET_UNDO_STATE                    |CI$31B     I
  CMSG I GET_UNDO_STATE                    |CI$31C
  CMSG V MSG_RESET_FIND                    |CI$31D
  CMSG V MSG_RESET_REPLACE                 |CI$31E
  CMSG V MSG_APPEND_TEXT                   |CI$31F     S
  CMSG V MSG_SELECT                        |CI$320     I  I
  CMSG I GET_EDIT_BUFFER_COUNT             |CI$321
  CMSG V SET_EDIT_BUFFER_SIZE              |CI$322     I
  CMSG I GET_EDIT_BUFFER_SIZE              |CI$323
  CMSG V SET_TEXT_LIMIT                    |CI$324     I
  CMSG I GET_TEXT_LIMIT                    |CI$325
  CMSG V SET_EDIT_ERRSPACE_MESSAGE         |CI$326     I
  CMSG I GET_EDIT_ERRSPACE_MESSAGE         |CI$327
  CMSG V SET_TABSTOP                       |CI$328     I  I
  CMSG I GET_TABSTOP                       |CI$329     I
  CMSG V SET_FORMAT_ORIGIN                 |CI$32A     I  I  I
  CMSG I GET_FORMAT_ORIGIN                 |CI$32B     I
  CMSG V SET_FORMAT_SIZE                   |CI$32C     I  I  I
  CMSG I GET_FORMAT_SIZE                   |CI$32D     I
  CMSG V SET_HORZ_SCROLL_BAR_VISIBLE_STATE |CI$32E     I
  CMSG I GET_HORZ_SCROLL_BAR_VISIBLE_STATE |CI$32F
  CMSG V MSG_HEADER_NOTIFICATION           |CI$330     I  I
  CMSG I GET_TIMEOUT_REQUEST               |CI$331     I  I
  CMSG V SET_TIMEOUT_MESSAGE               |CI$332     I
  CMSG I GET_TIMEOUT_MESSAGE               |CI$333
  CMSG V MSG_MAPI_ADD_RECEIVER             |CI$334     I  S
  CMSG I GET_CLIENT_SIZE                   |CI$335
  CMSG V SET_EXTENDED_WINDOW_STYLE         |CI$336     I  I
  CMSG I GET_EXTENDED_WINDOW_STYLE         |CI$337     I
  CMSG V SET_DDE_TIMEOUT_VALUE             |CI$338     I
  CMSG I GET_DDE_TIMEOUT_VALUE             |CI$339
  CMSG V SET_DDE_TIMEOUT_OBJECT            |CI$33A     I
  CMSG I GET_DDE_TIMEOUT_OBJECT            |CI$33B
  CMSG V SET_ITEM_COLOR                    |CI$33C     I  I
  CMSG V SET_FORM_MASK                     |CI$33D     I  S
  CMSG S GET_FORM_MASK                     |CI$33E     I
  CMSG V SET_FORM_BUTTON                   |CI$33F     I  I
  CMSG V SET_FORM_BUTTON_VALUE             |CI$340     I  S
  CMSG V SET_OEM_TRANSLATE_STATE           |CI$341     I
  CMSG I GET_OEM_TRANSLATE_STATE           |CI$342
  CMSG S GET_MASKED_VALUE                  |CI$343     I
  CMSG V MSG_MOUSE_NCCHANGE_FOCUS          |CI$344     I
  CMSG V MSG_MOUSE_NCUP                    |CI$345     I  I
  CMSG V MSG_MOUSE_NCUP2                   |CI$346     I  I
  CMSG V MSG_MOUSE_NCUP3                   |CI$347     I  I
  CMSG V MSG_MOUSE_NCCLICK                 |CI$348     I  I
  CMSG V MSG_MOUSE_NCCLICK2                |CI$349     I  I
  CMSG V MSG_MOUSE_NCCLICK3                |CI$34A     I  I
  CMSG V MSG_MOUSE_NCDOWN                  |CI$34B     I  I
  CMSG V MSG_MOUSE_NCDOWN2                 |CI$34C     I  I
  CMSG V MSG_MOUSE_NCDOWN3                 |CI$34D     I  I
  CMSG V MSG_MOUSE_NCDRAG                  |CI$34E     I  I
  CMSG V MSG_MOUSE_NCDRAG2                 |CI$34F     I  I
  CMSG V MSG_MOUSE_NCDRAG3                 |CI$350     I  I
  CMSG V SET_SENTINEL_PROGRAM              |CI$351     S
  CMSG S GET_SENTINEL_PROGRAM              |CI$352
  CMSG I GET_START_SENTINEL_PROGRAM        |CI$353
  CMSG I GET_STOP_SENTINEL_PROGRAM         |CI$354
  CMSG V SET_SENTINEL_RETURN_VALUE         |CI$355     I
  CMSG I GET_SENTINEL_RETURN_VALUE         |CI$356
  CMSG V MSG_NOTIFY_SELECT_STATE           |CI$357     I  I
  CMSG V MSG_SELECT_ALL                    |CI$358
  CMSG V SET_SENTINELDATA                  |CI$359     I  I  I
  CMSG S GET_SENTINELDATA                  |CI$35A     I  I
  CMSG V SET_HOSTDATA                      |CI$35B     I  I  I
  CMSG S GET_HOSTDATA                      |CI$35C     I  I
  CMSG V MSG_ONSENTINELDATACHANGE          |CI$35D     I  I
  CMSG V SET_SENTINELWINDOW                |CI$35E     I
  CMSG I GET_SENTINELWINDOW                |CI$35F
  CMSG V MSG_FORM_BUTTON_NOTIFICATION      |CI$360     I  I
  CMSG I GET_FORM_BUTTON_WINDOW_HANDLE     |CI$361     I
  CMSG V SET_FORM_JUSTIFICATION_MODE       |CI$362     I  I
  CMSG I GET_FORM_JUSTIFICATION_MODE       |CI$363     I
  CMSG V MSG_FORM_BUTTON_MOUSE_DOWN        |CI$364     I
  CMSG V SET_FORM_BUTTON_BITMAP            |CI$365     I  S
  CMSG I MSG_ONDELTAPOS                    |CI$366     I  I
  CMSG V SET_DEFAULT_ICONS                 |CI$367     I  I
  CMSG I GET_DEFAULT_ICONS                 |CI$368
  CMSG V SET_FORM_MASK_VALUE_STATE         |CI$369     I  I
  CMSG I GET_FORM_MASK_VALUE_STATE         |CI$36A     I
  CMSG V SET_MASKED_VALUE                  |CI$36B     I  S
  CMSG V SET_UNMASKED_VALUE                |CI$36C     I  S
  CMSG S GET_UNMASKED_VALUE                |CI$36D     I
  CMSG V SET_MAIN_WINDOW                   |CI$36E     I
  CMSG I GET_MAIN_WINDOW                   |CI$36F
  CMSG V SET_BITMAP_STYLE                  |CI$370     I
  CMSG I GET_BITMAP_STYLE                  |CI$371
  CMSG I GET_BITMAP_WIDTH                  |CI$372
  CMSG I GET_BITMAP_HEIGHT                 |CI$373
  CMSG V SET_TRANSPARENT_STATE             |CI$374     I
  CMSG I GET_TRANSPARENT_STATE             |CI$375
  CMSG I GET_MAPI_RECEIVER_COUNT           |CI$376
  CMSG V SET_MAPI_MESSAGE_RECEIVERNAME     |CI$377     I  S
  CMSG V SET_MAPI_MESSAGE_RECEIVERADRESS   |CI$378     I  S
  CMSG S GET_MAPI_MESSAGE_RECEIVERADRESS   |CI$379     I
  CMSG V SET_MAPI_MESSAGE_RECEIVERTYPE     |CI$37A     I  I
  CMSG I GET_MAPI_MESSAGE_RECEIVERTYPE     |CI$37B     I
  CMSG V SET_MAPI_MESSAGE_SUBJECT          |CI$37C     S
  CMSG V MSG_MAPI_REPLY                    |CI$37D
  CMSG V MSG_MAPI_REMOVE_RECEIVERS         |CI$37E
  CMSG V MSG_MAPI_REMOVE_ATTACHMENTS       |CI$37F
  CMSG V MSG_MAPI_ADD_ATTACHMENT           |CI$380     S  S
  CMSG I GET_MAPI_ATTACHMENT_COUNT         |CI$381
  CMSG S GET_MAPI_ATTACHMENT_PATH          |CI$382     I
  CMSG S GET_MAPI_ATTACHMENT_FILE          |CI$383     I
  CMSG V SET_COMM_DCB                      |CI$384     I
  CMSG V MSG_FILL_DCB                      |CI$385     I
  CMSG V MSG_FILL_COMM_TIMEOUTS            |CI$386     I    // This is really a pointer to a COMMTIMEOUT struct
  CMSG V SET_COMM_TIMEOUTS                 |CI$387     I    // same
  CMSG V MSG_FILL_COMM_PROPERTIES          |CI$388     I    // same
  CMSG V SET_COMM_MASK                     |CI$389     I
  CMSG I GET_COMM_MASK                     |CI$38A
  CMSG I GET_COMM_MODEM_STATUS             |CI$38B
  CMSG V MSG_GENERATE_VIRTUAL_KEY          |CI$38C     I  I
  CMSG V MSG_GENERATE_DF_KEY               |CI$38D     I  I
  CMSG I GET_CURRENT_OFFSET                |CI$38E
  CMSG I GET_CURRENT_SELECTION_RANGE       |CI$38F
  CMSG V MSG_ONKEYUP                       |CI$390     I  I
  CMSG V MSG_ONSYSKEYUP                    |CI$391     I  I
  CMSG V MSG_ADD_POPUP_MENU                |CI$392     I  S
  CMSG I GET_REG_KEY_ENUM                  |CI$393     I  S
  CMSG I GET_REG_INTEGER_VALUE_ENUM        |CI$394     S  I
  CMSG I GET_REG_STRING_VALUE_ENUM         |CI$395     S  S
  CMSG V SET_DDE_SERVER_LINK               |CI$396     I
  // Old internet client and NetMeeting removed...
  CMSG V SET_PSUSERNAME                    |CI$3D7     S
  CMSG S GET_PSUSERNAME                    |CI$3D8
  CMSG V SET_PSPASSWORD                    |CI$3D9     S
  CMSG S GET_PSPASSWORD                    |CI$3DA
  CMSG V SET_PSACCEPTTYPES                 |CI$3DB     S
  CMSG S GET_PSACCEPTTYPES                 |CI$3DC
  CMSG I GET_DESTROY_RUBBER_BAND           |CI$3DD     I
  CMSG I GET_CREATE_RUBBER_BAND            |CI$3DE     I
  CMSG I GET_CREATE_RUBBER_BAND_MANUAL     |CI$3DF     I
  CMSG I GET_TRACK_DF_WINDOW               |CI$3E0     I
  CMSG I GET_TRACK_CURRENT_WINDOW          |CI$3E1
  CMSG I GET_TRACK_NUMBER_OF_BANDS         |CI$3E2
  CMSG I GET_TRACK_GET_RECTANGLE           |CI$3E3     I  I   // second param is actually a pointer
  CMSG I GET_TRACK_SET_POSITION            |CI$3E4     I
  CMSG V SET_BAND_POSITION                 |CI$3E5     I  I
  CMSG V SET_BAND_SIZE                     |CI$3E6     I  I
  CMSG V SET_BAND_TRANSPARENT_FLAG         |CI$3E7     I
  CMSG V SET_BAND_SIZE_MOVE_FLAG           |CI$3E8     I
  CMSG V SET_BAND_SIZE_MOVE_MIN            |CI$3E9     I  I
  CMSG V SET_BAND_MULTISELECT_FLAG         |CI$3EA     I
  CMSG I GET_VIRTUAL_KEY                   |CI$3EB
  CMSG I GET_SHIFT_STATE                   |CI$3EC
  CMSG S GET_OBJECT_LABEL                  |CI$3ED
  CMSG I GET_OBJECT_ACCESS                 |CI$3EE
  CMSG V MSG_HEADER_ENDTRACK               |CI$3EF


  // Message number replacements without parameters.

  //#REPLACE GET_ITEM_OPTIONS                GET_ITEM_OPTIONS@1
  //#REPLACE GET_ITEM_ENTRY_MSG              GET_ITEM_ENTRY_MSG@1
  //#REPLACE GET_ITEM_EXIT_MSG               GET_ITEM_EXIT_MSG@1
  //#REPLACE GET_ITEM_VALIDATE_MSG           GET_ITEM_VALIDATE_MSG@1
  //#REPLACE GET_CHECKBOX_ITEM_STATE         GET_CHECKBOX_ITEM_STATE@1
  //#REPLACE MSG_PASTE                       MSG_PASTE@3
  //#REPLACE MSG_CUT                         MSG_CUT@3
  //#REPLACE MSG_COPY                        MSG_COPY@3


  Define USE_RGB_COLORS // this determines if RGB support is being used

  #IFDEF USE_RGB_COLORS

  CMSG V SET_TextColor                     |CI$0266    I
  CMSG I GET_TextColor                     |CI$0267
  CMSG V SET_Color                         |CI$0268    I
  CMSG I GET_Color                         |CI$0269
  CMSG V SET_CURRENTCELLCOLOR              |CI$0318    I
  CMSG I GET_CURRENTCELLCOLOR              |CI$0319
  CMSG V SET_CURRENTCELLTEXTCOLOR          |CI$027D    I
  CMSG I GET_CURRENTCELLTEXTCOLOR          |CI$027E
  CMSG V SET_ITEMCOLOR                     |CI$033C    I  I
  CMSG I GET_ITEMCOLOR                     |CI$0237    I
  CMSG V SET_ITEMTEXTCOLOR                 |CI$027F    I  I
  CMSG I GET_ITEMTEXTCOLOR                 |CI$0280    I
  CMSG V SET_CURRENTROWCOLOR               |CI$02B8    I
  CMSG I GET_CURRENTROWCOLOR               |CI$02B9
  CMSG V SET_CURRENTROWTEXTCOLOR           |CI$027B    I
  CMSG I GET_CURRENTROWTEXTCOLOR           |CI$027C

  #ENDIF

  CMSG  V  MSG_SETVSCROLLINFO                |CI$04A6    I I I //sav_cur_obj,
  CMSG  V  MSG_SETVSCROLLPOS                 |CI$04A7    I
  CMSG  V  MSG_SETVSCROLLBOX                 |CI$04A8    I I

  // anchor logic added with VDFX
  CMSG  V  SET_PEANCHORS                     |CI$51A
  CMSG  I  GET_PEANCHORS                     |CI$51B
  CMSG  V  SET_PBANCHORCREATED               |CI$51C
  CMSG  I  GET_PBANCHORCREATED               |CI$51D
  CMSG  V  SET_PBANCHORSTATE                 |CI$51E
  CMSG  I  GET_PBANCHORSTATE                 |CI$51F
  CMSG  V  SET_PIANCHORLEFT                  |CI$520
  CMSG  I  GET_PIANCHORLEFT                  |CI$521
  CMSG  V  SET_PIANCHORTOP                   |CI$522
  CMSG  I  GET_PIANCHORTOP                   |CI$523
  CMSG  V  SET_PIANCHORRIGHT                 |CI$524
  CMSG  I  GET_PIANCHORRIGHT                 |CI$525
  CMSG  V  SET_PIANCHORBOTTOM                |CI$526
  CMSG  I  GET_PIANCHORBOTTOM                |CI$527
  CMSG  V  SET_PIMINSIZE                     |CI$528
  CMSG  I  GET_PIMINSIZE                     |CI$529
  CMSG  V  SET_PIMAXSIZE                     |CI$52A
  CMSG  I  GET_PIMAXSIZE                     |CI$52B
  CMSG  I  MSG_DOCREATEANCHORS               |CI$518
  CMSG  I  MSG_DOAPPLYANCHORS                |CI$519
  CMSG  I  GET_GETCONTAINERCLIENTSIZE        |CI$538
  // form button get values exposed
  CMSG  I  GET_FORM_BUTTON                   |CI$052C
  CMSG  I  GET_FORM_BUTTON_VALUE             |CI$052D
  CMSG  I  GET_FORM_BUTTON_BITMAP            |CI$052E

  // added to VDF 8.2
  CMSG  I  GET_PEGRIDLINECOLOR               |CI$0545    // get/sets color of grid lines
  CMSG  I  SET_PEGRIDLINECOLOR               |CI$0546
  CMSG  I  GET_PEDISABLEDTEXTCOLOR           |CI$0547    // get/sets disabled (shadowed) text color
  CMSG  I  SET_PEDISABLEDTEXTCOLOR           |CI$0548
  CMSG  I  GET_PEDISABLEDCOLOR               |CI$0549    // get/sets disabled (shadowed) background color
  CMSG  I  SET_PEDISABLEDCOLOR               |CI$054a
  CMSG  I  GET_PBUSEDISABLEDCOLOR            |CI$054b
  CMSG  I  SET_PBUSEDISABLEDCOLOR            |CI$054c
  CMSG  I  MSG_ONWMMOUSEWHEEL                |CI$054d    // lowlevel mouse event for grids
  // added 10.0
  CMSG  X  MSG_SUSPENDGUI                    |CI$0587
  CMSG  X  MSG_PUMPMSGQUEUE                  |CI$0588
  // added 10.1
  CMSG  X  GET_SELECTCLIENTCERTIFICATE       |CI$058c // http
  CMSG  X  GET_PBSHOWERRORDIALOG             |CI$058d // http
  CMSG  X  SET_PBSHOWERRORDIALOG             |CI$058e // http

//  // Added 11.0 to support combos in grids and rich edit
  CMSG X  SET_COLUMN_COMBO_STATE             |CI$05eb
  CMSG X  GET_COLUMN_COMBO_STATE             |CI$05ec
  CMSG X  MSG_COLUMN_COMBO_ADD_ITEM          |CI$05ed
  CMSG X  MSG_COLUMN_COMBO_DELETE_ITEM       |CI$05ee
  CMSG X  SET_COLUMN_COMBO_SORT_STATE        |CI$05ef
  CMSG X  GET_COLUMN_COMBO_SORT_STATE        |CI$05f0
  CMSG X  SET_COLUMN_COMBO_LISTROWCOUNT      |CI$05f1
  CMSG X  GET_COLUMN_COMBO_LISTROWCOUNT      |CI$05f2
  CMSG X  MSG_COLUMN_COMBO_DELETE_DATA       |CI$05f3
  CMSG X  GET_COLUMN_COMBO_ITEM_COUNT        |CI$05f4
  CMSG X  GET_COLUMN_COMBO_VALUE             |CI$05f5
  CMSG X  GET_COLUMN_COMBO_FIND              |CI$05f6
  CMSG X  MSG_COLUMN_COMBO_REFRESH           |CI$05f7
  CMSG X  SET_COLUMN_COMBO_ENTRY_STATE       |CI$05f8
  CMSG X  GET_COLUMN_COMBO_ENTRY_STATE       |CI$05f9
  CMSG X  SET_PBCOMBONAVIGATION              |CI$05fa
  CMSG X  GET_PBCOMBONAVIGATION              |CI$05fb

  // rich edit messages
  CMSG X   SET_PBBOLD					    |CI$058f
  CMSG X   SET_PBSTRIKEOUT                  |CI$0590
  CMSG X   SET_PBSUPERSCRIPT                |CI$0591
  CMSG X   SET_PBSUBSCRIPT                  |CI$0592
  CMSG X   SET_PBLINK                       |CI$0593
  CMSG X   SET_PBPROTECT                    |CI$0594
  CMSG X   SET_PEPITCHANDFAMILY  		    |CI$0595
  CMSG X   SET_PECHARSET                    |CI$0596
  CMSG X   GET_PBBOLD	    				|CI$0597
  CMSG X   GET_PBSTRIKEOUT                  |CI$0598
  CMSG X   GET_PBSUPERSCRIPT                |CI$0599
  CMSG X   GET_PBSUBSCRIPT                  |CI$059a
  CMSG X   GET_PBLINK                       |CI$059b
  CMSG X   GET_PBPROTECT                    |CI$059c
  CMSG X   GET_PEPITCHANDFAMILY  		    |CI$059d
  CMSG X   GET_PECHARSET                    |CI$059e
  CMSG X   SET_TEXTBACKCOLOR                |CI$059f
  CMSG X   GET_TEXTBACKCOLOR                |CI$05a0

  CMSG X   SET_PEBULLETS			    |CI$05a1
  CMSG X   SET_PIPARAGRAPHINDENT        |CI$05a2
  CMSG X   SET_PIRIGHTMARGIN            |CI$05a3
  CMSG X   SET_PIOFFSETINDENT           |CI$05a4
  CMSG X   SET_PEALIGNMENT              |CI$05a5
  CMSG X   SET_PISPACINGBEFORE          |CI$05a6
  CMSG X   SET_PISPACINGAFTER           |CI$05a7
  CMSG X   SET_PILINESPACING      	    |CI$05a8
  CMSG X   SET_PELINESPACINGTYPE        |CI$05a9
  CMSG X   SET_PIBULLETSTART            |CI$05aa
  CMSG X   SET_PEBULLETSTYLE            |CI$05ab
  CMSG X   SET_PIBULLETTAB              |CI$05ac
  CMSG X   GET_PEBULLETS			    |CI$05ad
  CMSG X   GET_PIPARAGRAPHINDENT        |CI$05ae
  CMSG X   GET_PIRIGHTMARGIN            |CI$05af
  CMSG X   GET_PIOFFSETINDENT           |CI$05b0
  CMSG X   GET_PEALIGNMENT              |CI$05b1
  CMSG X   GET_PISPACINGBEFORE          |CI$05b2
  CMSG X   GET_PISPACINGAFTER           |CI$05b3
  CMSG X   GET_PILINESPACING            |CI$05b4
  CMSG X   GET_PELINESPACINGTYPE        |CI$05b5
  CMSG X   GET_PIBULLETSTART            |CI$05b6
  CMSG X   GET_PEBULLETSTYLE            |CI$05b7
  CMSG X   GET_PIBULLETTAB              |CI$05b8

  CMSG X   GET_PBAUTOURL               |CI$05b9
  CMSG X   SET_PBAUTOURL               |CI$05ba
  CMSG X   SET_PBWRAP                  |CI$05bb
  CMSG X   GET_PBWRAP                  |CI$05bc
  CMSG X   GET_FINDTEXT                |CI$05bd
  CMSG X   GET_REPLACEALL              |CI$05be
  CMSG X   MSG_REPLACESEL              |CI$05bf
  CMSG X   MSG_SETSEL                  |CI$05c0
  CMSG X   GET_SELSTART                |CI$05c1
  CMSG X   GET_SELEND                  |CI$05c2

  CMSG X   GET_PBCANUNDO               |CI$05c3
  CMSG X   MSG_CLEARUNDOBUFFER         |CI$05c4
  CMSG X   GET_FIRSTVISIBLELINE        |CI$05c5
  CMSG X   GET_LINE                    |CI$05c6
  CMSG X   GET_LINEFROMCHAR            |CI$05c7
  CMSG X   GET_FIRSTCHARINLINEPOS      |CI$05c8
  CMSG X   GET_LINELENGTH              |CI$05c9
  CMSG X   MSG_SCROLLLINES             |CI$05ca
  CMSG X   MSG_SCROLLCARET             |CI$05cb
  CMSG X   GET_PBCANPASTE              |CI$05cc
  CMSG X   GET_PBCANREDO               |CI$05cd
  CMSG X   GET_UNDOTYPE                |CI$05ce
  CMSG X   GET_REDOTYPE                |CI$05cf
  CMSG X   GET_SELTEXT                 |CI$05d0
  CMSG X   GET_TEXTRANGE               |CI$05d1
  CMSG X   MSG_HIDESELECTION           |CI$05d2
  CMSG X   MSG_REDO                    |CI$05d3
  CMSG X   MSG_STOPGROUPTYPING         |CI$05d4
  CMSG X   GET_PAVALUE                 |CI$05d5
  CMSG X   SET_PAVALUE                 |CI$05d6

  CMSG X   MSG_ONLINKCLICKED           |CI$05d7

  CMSG X   SET_PBITALICS               |CI$05dd
  CMSG X   GET_PBITALICS               |CI$05de
  CMSG X   SET_PBUNDERLINE             |CI$05df
  CMSG X   GET_PBUNDERLINE             |CI$05e0
  CMSG X   SET_PSTYPEFACE              |CI$05e1
  CMSG X   GET_PSTYPEFACE              |CI$05e2
  CMSG X   SET_PIFONTSIZE              |CI$05e3
  CMSG X   GET_PIFONTSIZE              |CI$05e4
  CMSG X   SET_PIFONTWEIGHT            |CI$05e5
  CMSG X   GET_PIFONTWEIGHT            |CI$05e6

  CMSG X   GET_CHARCOUNT               |CI$05e7
  CMSG X   SET_PIMAXCHARS              |CI$05e8
  CMSG X   GET_PIMAXCHARS              |CI$05e9
  CMSG X   MSG_APPENDTEXT              |CI$05ea
  CMSG X   MSG_ONSELECTIONCHANGED      |CI$05fd

#ENDCOMMAND


#COMMAND Define$BuiltIn$XML$Messages

  CMSG  V SET_XMLINTERFACE                |CI$03F0  I
  CMSG  I GET_XMLINTERFACE                |CI$03F1


  // NODE Properties

  CMSG  I  GET_PHATTRIBUTES                |CI$03F2
  CMSG  S  GET_PSBASENAME                  |CI$03F3
  CMSG  I  GET_PHCHILDNODES                |CI$03F4
  CMSG  I  GET_PHDEFINITION                |CI$03F5
  CMSG  I  GET_PHFIRSTCHILD                |CI$03F6
  CMSG  I  GET_PHLASTCHILD                 |CI$03F7
  CMSG  I  GET_PHNEXTSIBLING               |CI$03F8
  CMSG  S  GET_PSNAMESPACEURI              |CI$03F9
  CMSG  S  GET_PSNODENAME                  |CI$03FA
  CMSG  I  GET_PINODETYPE                  |CI$03FB
  CMSG  S  GET_PSNODETYPESTRING            |CI$03FC
  CMSG  I  GET_PHOWNERDOCUMENT             |CI$03FD
  CMSG  I  GET_PHPARENTNODE                |CI$03FE
  CMSG  I  GET_PBPARSED                    |CI$03FF
  CMSG  S  GET_PSPREFIX                    |CI$0400
  CMSG  I  GET_PHPREVIOUSSIBLING           |CI$0401
  CMSG  I  GET_PBSPECIFIED                 |CI$0402
  CMSG  S  GET_PSTEXT                      |CI$0403
  CMSG  S  GET_PSXML                       |CI$0404

  // Node Read write properties

  CMSG  V  SET_PSDATATYPE                  |CI$0405  S
  CMSG  S  GET_PSDATATYPE                  |CI$0406
  CMSG  V  SET_PVNODETYPEDVALUE            |CI$0407  I  I
  CMSG  I  GET_PVNODETYPEDVALUE            |CI$0408  I
  CMSG  V  SET_PSNODEVALUE                 |CI$0409  S
  CMSG  S  GET_PSNODEVALUE                 |CI$040A

  // Node Methods

  CMSG  I   GET_APPENDCHILD                   |CI$040B  I
  CMSG  I   GET_CLONEINFCNODE                 |CI$040C  I
  CMSG  I   GET_HASCHILDNODES                 |CI$040D
  CMSG  I   GET_INSERTBEFORE                  |CI$040E  I  I
  CMSG  I   GET_REMOVECHILD                   |CI$040F  I
  CMSG  I   GET_REPLACECHILD                  |CI$0410  I  I
  CMSG  I   GET_SELECTNODES                   |CI$0411  S
  CMSG  I   GET_SELECTSINGLENODE              |CI$0412  S

  // Node Collections
  // READONLY PROPERTIES

  CMSG  I   GET_PHITEM                        |CI$0413  I
  CMSG  I   GET_PILENGTH                      |CI$0414

  CMSG  I   GET_ENUMNODELIST                  |CI$0415  I
  CMSG  I   GET_RESET                         |CI$0416

  // Named Node Map

  CMSG  I   GET_NAMEDITEM                     |CI$0417  S
  CMSG  I   GET_QUALIFIEDITEM                 |CI$0418  S  S
  CMSG  I   GET_REMOVENAMEDITEM               |CI$0419  S
  CMSG  I   GET_REMOVEQUALIFIEDITEM           |CI$041A  S  S
  CMSG  I   GET_SETNAMEDITEM                  |CI$041B  I

  // XML DOM Document
  // Read only properties

  CMSG  I   GET_PHDOCTYPE                     |CI$041C
  CMSG  I   GET_PHIMPLEMENTATION              |CI$041D
  CMSG  I   GET_PHPARSEERROR                  |CI$041E
  CMSG  I   GET_PBREADYSTATE                  |CI$041F
  CMSG  S   GET_PSURL                         |CI$0420

  // Read Write Properties

  CMSG  V   SET_PBASYNC                       |CI$0421  I
  CMSG  I   GET_PBASYNC                       |CI$0422
  CMSG  V   SET_PHDOCUMENTELEMENT             |CI$0423  I
  CMSG  I   GET_PHDOCUMENTELEMENT             |CI$0424
  CMSG  V   SET_PBPRESERVEWHITESPACE          |CI$0425  I
  CMSG  I   GET_PBPRESERVEWHITESPACE          |CI$0426
  CMSG  V   SET_PBRESOLVEEXTERNALS            |CI$0427  I
  CMSG  I   GET_PBRESOLVEEXTERNALS            |CI$0428
  CMSG  V   SET_PBVALIDATEONPARSE             |CI$0429  I
  CMSG  I   GET_PBVALIDATEONPARSE             |CI$042A

  // Events

  CMSG  I   MSG_ONDATAAVAILABLE               |CI$042B
  CMSG  I   MSG_ONREADYSTATECHANGE            |CI$042C

  // Methods

  CMSG  I   GET_ABORT                         |CI$042D
  CMSG  I   GET_ELEMENTSBYTAGNAME             |CI$042E  S
  CMSG  I   GET_LOADDOCUMENT                  |CI$042F  S
  CMSG  I   GET_LOADXML                       |CI$0430  S
  CMSG  I   GET_NODEFROMID                    |CI$0431  S
  CMSG  I   GET_SAVEDOCUMENT                  |CI$0432  S

  // Parse Error
  // Read Only Properties

  CMSG  I   GET_PIERRORCODE                   |CI$0433
  CMSG  I   GET_PIFILEPOS                     |CI$0434
  CMSG  I   GET_PILINE                        |CI$0435
  CMSG  I   GET_PILINEPOS                     |CI$0436
  CMSG  S   GET_PSREASON                      |CI$0437
  CMSG  S   GET_PSSRCTEXT                     |CI$0438
  CMSG  S   GET_PSERRORURL                    |CI$0439

  // DOM Implementation
  // Method

  CMSG  I   GET_HASFEATURE                    |CI$043A  S S

  // Methods

  CMSG  S   GET_SUBSTRINGDATA                 |CI$043B  I I
  CMSG  I   GET_APPENDDATA                    |CI$043C  S
  CMSG  I   GET_INSERTDATA                    |CI$043D  I S
  CMSG  I   GET_DELETEDATA                    |CI$043E  I I
  CMSG  I   GET_REPLACEDATA                   |CI$043F  I I S

  // Attributes

  CMSG  S   GET_PSNAME                        |CI$0440

  // Elements
  // Read Only properties

  CMSG  S   GET_PSTAGNAME                     |CI$0441

  // Methods

  CMSG  V   SET_ATTRIBUTEVALUE                |CI$0442  S S
  CMSG  S   GET_ATTRIBUTEVALUE                |CI$0443  S
  CMSG  I   GET_REMOVEATTRIBUTE               |CI$0444  S
  CMSG  I   GET_ATTRIBUTENODE                 |CI$0445  S
  CMSG  V   SET_ATTRIBUTENODE                 |CI$0446  I
  CMSG  I   GET_REMOVEATTRIBUTENODE           |CI$0447  I
  //CMSG  I   GET_ELEMENTSBYTAGNAME             |CI$0448  S

  // DOM Text
  // Methods

  CMSG  I   GET_SPLITTEXT                     |CI$0449  I

  // DOM Processing Instruction
  // Read Only Properties
  CMSG  S   GET_PSTARGET                      |CI$044A

  // DOM Document Type
  CMSG  I   GET_PHENTITIES                    |CI$044B
  CMSG  I   GET_PHNOTATIONS                   |CI$044C

  // DOM Notations

  CMSG  S   GET_PSPUBLICID                    |CI$044D
  CMSG  S   GET_PSSYSTEMID                    |CI$044E
  CMSG  S   GET_PSNOTATIONNAME                |CI$044F

  // added to document

  CMSG  I   GET_CREATEATTRIBUTE               |CI$0450   S
  CMSG  I   GET_CREATECDATASECTION            |CI$0451   S
  CMSG  I   GET_CREATECOMMENT                 |CI$0452   S
  CMSG  I   GET_CREATEDOCUMENTFRAGMENT        |CI$0453
  CMSG  I   GET_CREATEELEMENT                 |CI$0454   S
  CMSG  I   GET_CREATEENTITYREFERENCE         |CI$0455   S
  CMSG  I   GET_CREATENODE                    |CI$0456   I  S  S
  CMSG  I   GET_CREATEPROCESSINGINSTRUCTION   |CI$0457   S  S
  CMSG  I   GET_CREATETEXTNODE                |CI$0458   S

  // added to element (r/w property)

  CMSG  V  SET_PSTEXT                        |CI$0459   S
  CMSG  I  GET_CHANGENODETYPE              |CI$045A   I  I
  CMSG  I  GET_PHELEMENTITEM                 |CI$045B   I

  CMSG  S GET_TRANSFORMNODE                  |CI$04A9    I
  CMSG  A GET_PAXML                          |CI$0502
  CMSG  I GET_LOADXMLFROMADDRESS             |CI$0503    A
  CMSG  I GET_TRANSFORMNODETOADDRESS         |CI$0517
#ENDCOMMAND

#COMMAND Define$BuiltIn$FlexCom2$Messages

  CMSG  S   GET_PSPROGID                |CI$0554
  CMSG  S   SET_PSPROGID                |CI$0555
  CMSG  S   GET_pvComObject             |CI$0556
  CMSG  S   SET_pvComObject             |CI$0557
  CMSG  S   MSG_CREATECOMOBJECT         |CI$0558
  CMSG  S   MSG_RELEASECOMOBJECT        |CI$0559
  CMSG  S   MSG_COMADDREF               |CI$055a
  CMSG  S   GET_COMQUERYINTERFACE       |CI$055b
  CMSG  S   MSG_PREPAREPARAMS           |CI$055c
  CMSG  S   MSG_DEFINEPARAM             |CI$055d
  CMSG  S   GET_INVOKECOMMETHOD         |CI$055e
  CMSG  S   MSG_INVOKECOMMETHOD         |CI$055e
  CMSG  S   GET_COMPROPERTY             |CI$055f
  CMSG  S   SET_COMPROPERTY             |CI$0560
  CMSG  S   MSG_REGISTERCOMEVENT        |CI$0561
  CMSG  S   GET_OLECONTAINER            |CI$0562
  CMSG  S   GET_OLEFRAMECONTAINER       |CI$0563
  CMSG  S   MSG_ONDFFOCUS               |CI$0564
  CMSG  S   MSG_DISPLAYPROPERTYSHEET    |CI$0565
  CMSG  S   MSG_CREATECOMOBJECTFROMFILE |CI$0566
  CMSG  S   MSG_SAVETOFILE              |CI$0567
  CMSG  S   MSG_SAVETORESOURCEFILE      |CI$0568
  CMSG  S   GET_PSRESOURCEFILE          |CI$0569
  CMSG  S   SET_PSRESOURCEFILE          |CI$056a
  CMSG  S   GET_PSRESOURCENAME          |CI$056b
  CMSG  S   SET_PSRESOURCENAME          |CI$056c
  CMSG  S   SET_PSRESOURCEDATA          |CI$056d
  CMSG  S   GET_PEAUTOCREATE            |CI$056e
  CMSG  S   SET_PEAUTOCREATE            |CI$056f
  CMSG  S   GET_PSLICENSEKEY            |CI$0570
  CMSG  S   SET_PSLICENSEKEY            |CI$0571
  CMSG  S   MSG_REGISTERPROPERTYCHANGEEVENT |CI$0572
  CMSG  S   GET_PHDISPATCHDRIVER        |CI$0573
  CMSG  S   MSG_CLEARDISPATCHDRIVER     |CI$0574
  CMSG  S   MSG_ONCREATE                |CI$0575
  CMSG  S   MSG_ONINPLACEACTIVATE       |CI$0576
  CMSG  S   GET_COMLOADPICTURE          |CI$0577
  CMSG  S   GET_COMACTIVEOBJECT         |CI$0578
  CMSG  S   GET_PSEVENTID               |CI$057C
  CMSG  S   SET_PSEVENTID               |CI$057D
  CMSG  S   GET_PABASE64RESOURCEFROMFILE |CI$0644 // internal - added for 12.0 migration

#ENDCOMMAND

#COMMAND Define$BuiltIn$Transfer$Messages
  // ftp and http transfer

  CMSG  S   GET_PSREMOTEHOST                  |CI$045C
  CMSG  V   SET_PSREMOTEHOST                  |CI$045D   S
  CMSG  S   GET_PSAGENT                       |CI$045E
  CMSG  V   SET_PSAGENT                       |CI$045F   S
  CMSG  S   GET_PSPROXY                       |CI$0460
  CMSG  V   SET_PSPROXY                       |CI$0461   S
  CMSG  I   GET_PIREMOTEPORT                  |CI$0462
  CMSG  V   SET_PIREMOTEPORT                  |CI$0463   I
  CMSG  I   GET_PETRANSFERFLAGS               |CI$0464
  CMSG  V   SET_PETRANSFERFLAGS               |CI$0465   I
  CMSG  I   GET_PIBUFFERSIZE                  |CI$0466
  CMSG  V   SET_PIBUFFERSIZE                  |CI$0467   I
  CMSG  I   GET_ROOTHANDLE                    |CI$0468
  CMSG  I   GET_LASTERRORCODE                 |CI$0469

  CMSG  I   GET_FILESIZE                      |CI$046A   S
  CMSG  I   GET_FILEATTRIBUTES                |CI$046B   S
  CMSG  I   GET_PETRANSFERTYPE                |CI$046C
  CMSG  V   SET_PETRANSFERTYPE                |CI$046D   I
  CMSG  I   GET_PBPASSIVEMODE                 |CI$046E
  CMSG  V   SET_PBPASSIVEMODE                 |CI$046F   I
  CMSG  I   GET_CONNECTIONHANDLE              |CI$0470
  CMSG  I   GET_CONNECT                       |CI$0471
  CMSG  I   GET_DISCONNECT                    |CI$0472
  CMSG  S   GET_CURRENTDIRECTORY              |CI$0473
  CMSG  I   GET_CHANGEDIRECTORY               |CI$0474   S
  CMSG  I   GET_UPLOADFILE                    |CI$0475   S  S
  CMSG  I   GET_DOWNLOADFILE                  |CI$0476   S  S
  CMSG  I   GET_CREATEFTPDIRECTORY            |CI$0477   S
  CMSG  I   GET_REMOVEFTPDIRECTORY            |CI$0478   S
  CMSG  I   GET_RENAMEFTPFILE                 |CI$0479   S  S
  CMSG  I   GET_DELETEFTPFILE                 |CI$047A   S
  CMSG  S   GET_FINDFIRSTFTPFILE              |CI$047B   S
  CMSG  S   GET_FINDNEXTFTPFILE               |CI$047C
  CMSG  V   MSG_ENDFTPFILEFIND                |CI$047D
  CMSG  I   GET_FTPFILEEXIST                  |CI$047E   S
  CMSG  V   MSG_DIRECTORYLIST                 |CI$047F   S
  CMSG  V   MSG_CANCELTRANSFER                |CI$0480
  CMSG  V   MSG_ONTRANSFERSTATUS              |CI$0481   I  I
  CMSG  V   MSG_ONDIRECTORYLIST               |CI$0482   S  I

  CMSG  S   GET_PSPROTOCOLVERSION             |CI$0483
  CMSG  V   SET_PSPROTOCOLVERSION             |CI$0484   S
  CMSG  S   GET_PSSAVEASFILE                  |CI$0485
  CMSG  V   SET_PSSAVEASFILE                  |CI$0486   S
  CMSG  I   GET_ADDHEADER                     |CI$0487   S S
  CMSG  V   MSG_CLEARHEADERS                  |CI$0488
  CMSG  I   GET_HTTPGETREQUEST                |CI$0489   S
  //SF - The arguments are not used, see command cmsg for definition,
  //nowadays it just makes a replace, so we simply supply bogus arguments
  CMSG  X   GET_HTTPPOSTADDRREQUEST           |CI$048A
  CMSG  X   GET_HTTPPUTADDRREQUEST            |CI$048B
  CMSG  X   MSG_ONDATARECEIVED                |CI$048C
  // added to 10.0
  CMSG  X   GET_RESPONSEHEADER                |CI$0589
  CMSG  X   GET_RESPONSESTATUSCODE            |CI$058a


#ENDCOMMAND


#COMMAND Define$BuiltIn$WAS$Messages
  CMSG  V  MSG_START_WEBAPP_SESSION          |CI$048D
  CMSG  V  MSG_OUTPUTHTML                    |CI$048E  S
  CMSG  V  MSG_OUTPUTPLAINTEXT               |CI$048F  S
  CMSG  V  MSG_LOGEVENT                      |CI$0490  I S
  CMSG  S  GET_HTMLFORMVALUE                 |CI$0491  S
  CMSG  S  GET_HTMLQUERYSTRING               |CI$0492  S
  CMSG  V  MSG_OUTPUTIMAGE                   |CI$0493  S
  CMSG  V  MSG_OUTPUTTEXTFILE                |CI$0494  S
  CMSG  V  MSG_REQUESTFILERECORDS            |CI$0495  I
  CMSG  V  MSG_REQUESTFILEFIELDVALUES        |CI$0496  I
  CMSG  S  GET_HTTPCOOKIE                    |CI$0497  S S
  CMSG  V  SET_HTTPCOOKIE                    |CI$0498   V
  CMSG  V  SET_HTTPCOOKIEATTRIB              |CI$0499   V
  CMSG  S  GET_HTTPSERVERVARIABLE            |CI$049A   S
  CMSG  V  MSG_ONSETFILERECORDID             |CI$049B   V
  CMSG  V  MSG_ONSETFILEFIELDVALUE           |CI$049C   V
  CMSG  S  GET_ONDDVALUE                     |CI$049D   V
  CMSG  I  GET_ONREQUESTDELETE               |CI$049E   S S
  CMSG  I  GET_ONREQUESTFIND                 |CI$049F   V
  CMSG  I  GET_ONREQUESTSAVE                 |CI$04A0   S S
  CMSG  I  GET_ONDOPROCESS                   |CI$04A1   V
  CMSG  I  GET_ONREQUESTCLEAR                |CI$04A2   V
  CMSG  I  GET_ONDFFUNC                      |CI$04A3   S S
  CMSG  I  GET_ONREQUESTFINDBYRECID          |CI$04A4   V
  CMSG  I  GET_ONREQUESTDDUPDATE             |CI$04A5   V



  CMSG  V MSG_ONATTACHSESSION                |CI$0500
  CMSG  V MSG_ONDETACHSESSION                |CI$0501
  CMSG  I GET_DOCALL                         |CI$0504    A
  CMSG  S GET_INTERFACEMESSAGENAME           |CI$0505    S
  CMSG  I GET_INTERFACEMESSAGEID             |CI$0506    I
  CMSG  S GET_INTERFACEMESSAGEPARAMS         |CI$0507    S
  CMSG  S GET_INTERFACEMESSAGECOMMENT        |CI$0508    S
  CMSG  I GET_FINDSERVICEINDEX               |CI$0509    S
  CMSG  I GET_FINDMESSAGEID                  |CI$050A    S
  CMSG  V MSG_REGISTERSIMPLEINTERFACE        |CI$050B    V
  CMSG  V MSG_REMOVEINTERFACE                |CI$050C    I
  CMSG  V MSG_REMOVEALLINTERFACES            |CI$050D
  CMSG  V SET_PHOWEBSERVICEIMPLEMENTOR       |CI$050E    I
  CMSG  I GET_PHOWEBSERVICEIMPLEMENTOR       |CI$050F
  CMSG  V MSG_REGISTERINTERFACE              |CI$0510    V
  CMSG  I GET_MIMICCALL                      |CI$0511    V
  CMSG  I GET_INTERFACEMESSAGECOUNT          |CI$0512
  CMSG  I GET_WEBREQUESTARGUMENTCOUNT        |CI$0513
  CMSG  S GET_WEBREQUESTSERVICENAME          |CI$0514
  CMSG  S GET_WEBREQUESTARGUMENT             |CI$0515    I
  CMSG  I GET_INTERFACEMESSAGEISEXTENDED     |CI$0516    I
  // added to 10.0 for Webservice support
  CMSG  X GET_DESERIALIZEXML                 |CI$057e
  CMSG  X GET_SERIALIZEXML                   |CI$057f
  CMSG  X MSG_DISPOSEOBJECT                  |CI$0580
  CMSG  X MSG_WEBSERVICEEXCEPTION            |CI$058B

  CMSG  X GET_INTERFACEMESSAGEPARAMCOUNT     |CI$0581
  CMSG  X GET_INTERFACEMESSAGEPARAMTYPE      |CI$0582
  CMSG  X GET_INTERFACEMESSAGEPARAMTYPENAME  |CI$0583
  CMSG  X GET_INTERFACEMESSAGEPARAMDIMCOUNT  |CI$0584
  CMSG  X GET_INTERFACEMESSAGEPARAMNAME      |CI$0585
  CMSG  X GET_INTERFACETYPEDEFINITIONS       |CI$0586
  CMSG  X GET_INTERFACEMESSAGEPARAMBYREF     |CI$05fc



  CMSG  X GET_CURRENTROWID                   |CI$05d8
  CMSG  X GET_HASRECORD                      |CI$05d9
  CMSG  X MSG_ONNEWCURRENTRECORD             |CI$05da
  CMSG  X MSG_FINDBYROWID                    |CI$05db
  CMSG  X MSG_READBYROWID                    |CI$05dc

  CMSG  X GET_DFSTRICMP                      |CI$05fe

  // File Drag&Drop Support: added to 12.0
  CMSG  X  GET_PBACCEPTDROPFILES             |CI$0648
  CMSG  X  SET_PBACCEPTDROPFILES             |CI$0649
  CMSG  X  MSG_ONFILEDROPPED                 |CI$064a
  CMSG  X  MSG_ONFILEDROPPEDINTERNAL         |CI$064b

  // Send EnableNewModalityLogic turns on and off the new modality logic which determines if
  // disabling the main_window also disables windows in other ownerless top level windows. By default this
  // is True and it should only be changed with the greatest of care and reset ASAP. This is used to make
  // the old winprint viewer work.
  CMSG  X  MSG_ENABLENEWMODALITYLOGIC        |CI$64e

  // Support for cIdleHandler added 12.1
  CMSG  X  SET_PBENABLED                     |CI$601
  CMSG  X  GET_PBENABLED                     |CI$61f
  CMSG  X  MSG_ONIDLE                        |CI$61c
  // added to all UI objects to better support menus
  CMSG  X  GET_CANUNDO                       |CI$67a
  CMSG  X  GET_CANCOPY                       |CI$67b
  CMSG  X  GET_CANDELETE                     |CI$67c
  CMSG  X  GET_CANCUT                        |CI$67d
  CMSG  X  GET_CANPASTE                      |CI$67e
  CMSG  X  GET_CANSELECT                     |CI$67f
  CMSG  X  GET_CANREDO                       |CI$680

  // added 14.0

  CMSG  X  MSG_SETHSCROLLBOX                 |CI$0685
  CMSG  X  Get_pbSizeToClientArea            |CI$68E
  CMSG  X  Set_pbSizeToClientArea            |CI$68F
  CMSG  X  Get_GuiWindowSize                 |CI$690
  CMSG  X  Get_DialogToGui                   |CI$691
  CMSG  X  Get_GuiToDialog                   |CI$692
  // this is the same as get_client_size. We added another name
  // and will be considering the old name to be obsolete. This one
  // is clearer
  CMSG  X  Get_GuiClientSize                 |CI$335

  // added in 15.1 for MSXML6 support
  CMSG X Get_psDomSecondLevelProperty       |CI$06a1
  CMSG X Set_psDomSecondLevelProperty       |CI$06a2
  CMSG X Get_pbDomSecondLevelProperty       |CI$06a3
  CMSG X Set_pbDomSecondLevelProperty       |CI$06a4
  CMSG X Get_piDomSecondLevelProperty       |CI$06a5
  CMSG X Set_piDomSecondLevelProperty       |CI$06a6
  CMSG X Get_AddExternalSchemaFile          |CI$06a7
  CMSG X Get_AddExternalSchemaDocument      |CI$06a8
  CMSG X Get_ValidateDocument               |CI$06a9
  CMSG X Get_piErrorCount                   |CI$06aa
  CMSG X Get_ErrorItem                      |CI$06ab
  CMSG X Get_psErrorXPath                   |CI$06ac

  // added 16.1
  CMSG X Get_PARENT_CHANGED_STATE           |CI$06b5

#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//     Object ObjectName IS [A|AN] ObjectClass {ImageName} {SubImageNames...}
//
//   Parameters:
//     ObjectName is a string.
//     ObjectClass is an integer.
//     ImageName is a string.
//
//   Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

// JJT-5.1
//#COMMAND OBJECT R "IS" "A""AN" RVD#I
//  #IF (!0<5)                // if no image try to aquire one
//    OBJECT !1 !2 !3 !4 !1
//  #ELSE
//    #DATA               // start up the data stream
//    #PUSH !Zj               // save the unique object label
//    #PUSH !b                // save current definition state
//    #IF (!b = 4)            // if in procedure and not class
//      #SET ZJ$ 0                // do not inc z
//    #ELSE
//      #SET ZJ$ !ZB          // assign the next object id
//    #ENDIF
//    #PUSH !Zb               // save this level on stack
//    #IFDEF !4.AGG           // was this a class with sub objects?
//      #SET ZB$ !4.AGG           // sub objects will begin at the
//    #ELSE               // next object after superclass
//      #SET ZB$ 0                // base classes start at 0
//    #ENDIF
//    #SET ZI$ !ZI                // count this object at the current level
//    #PUSH !Zi               // and push the level
//    #IF (!b > 0)            // if (in_object | in_class)
//      #IF (!b & 2)              // obj_flag == in_class?
//        #IF (!b & 1)              // obj_flag == in_Object?
//        #ELSE           // No Name for Subobject in constructor
//          #REPLACE !$.!1.OBJ |CI-!Zj  // object_name = -current_object
//        #ENDIF
//      #ENDIF
//// (LS) removed setting of ZJ; it is NOT being used.
//// (Removed when max lines increased > 32k)
////      #SET ZJ$ (32766-!a)           // a very unique label for this object
//      #DPUSH |CS".!1"           // make name from parent and child
//    #ELSE               // global object name
//      #DPUSH |CS"!1"            // assign an absolute name to object
//    #ENDIF
//    #CHECK U_!4 _U          // does class exist?
//    #DPUSH U_!4             // define then class the class id
//    GET$OBJ$IMAGE !5            // define the objects image
//    #IF ((!b & 3) = 2)          // if in_class & !in_object
//      #DPUSH !$.!1.OBJ          // pick the assigned dependant number
//    #ELSE               //
//      #IF (!b = 0)          // A global object must assign #
//        #IFDEF !1.OBJ           // Is the symbol defined, name_object?
//          #DPUSH |CI0           // pick the next dependant number
//        #ELSE
//          #DPUSH |CI!Zj         // force the dependant number
////          #SET ZJ$ ($1000+!Zj)       // mark as global object
//          #SET ZJ$ ($10000000+!Zj)   // using 32-bit ids now
//          #REPLACE !1.OBJ |CI!Zj        // Assign an ID to this object
//        #ENDIF
//      #ELSE
//        #DPUSH |CI0         // pick the next dependant number
//      #ENDIF
//    #ENDIF
//    REGISTER_OBJECT !1
//    #DPUSH GET_!1
//    #SET B$ (!b | 1)            // we are in a object definition
//    !A [] OBJ$CREATE |VL        // create the object now

//    #IFDEF !1.OBJ
//      #IFCLASS !1.OBJ V$        // does this object have a global?
//        MOVE CURRENT_OBJECT TO !1.OBJ   // Move the object id to its global
//      #ENDIF
//    #ENDIF

//    #SPUSH   //save the old class name
//    #SET $$ !4
//    #IFSUB '!$$SC' // if flex-defined class
//      #IFSUB '!$$SM' // if begin-instance macro exists
//        !$$SM !$ !5 !6 !7 !8 !9
//      #ELSE
//        FORWARD_BEGIN_CONSTRUCT !$ !5 !6 !7 !8 !9
//      #ENDIF
//    #ELSE
//      ADD$IMAGE$ARGS MSG_CONSTRUCT_OBJECT !5 !6 !7 !8 !9  //else use default
//    #ENDIF
//  #ENDIF
//#ENDCOMMAND

#COMMAND GET$OBJ$IMAGE          // identify the image type
  #IFDEF !1             // is it a int (dynamic?)
    #DPUSH !1
  #ELSE
    #IFDEF !1.N             // try typical naming scheme
      #DPUSH !1.N
    #ELSE
      #DPUSH |CI0           // not found, make it dynamic
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND ADD$IMAGE$ARGS         // pass sub image args to constructor
  #IF (!0>0)                // while there are args to process
    #IFDEF !1               // image name a int?
      #IFSAME !1 MSG_CONSTRUCT_OBJECT   // a special flag to get it going
        #DATA               // start the data stream
      #ENDIF
      #DPUSH !1             // save the message or image id
    #ELSE
      #IFDEF !1.N           // typical image name
        #DPUSH !1.N
      #ELSE
        #DPUSH |CI0         // dynamic image name
      #ENDIF
    #ENDIF
    ADD$IMAGE$ARGS !2 !3 !4 !5 !6 !7 !8 !9
  #ELSE
    !A [] OBJ$SEND CURRENT_OBJECT |VL
  #ENDIF
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//  Register_Object Object_Name
//
//   Parameters:
//
//   Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

// JJT-5.1
//#COMMAND REGISTER_OBJECT R
//  #IFDEF UI.EXISTS
//  #ELSE
//    USE UI
//  #ENDIF
//  #IFDEF GET_!1
//  #ELSE
//    #REPLACE GET_!1 |CI!ZH
//    #FREG GET_!1 RETURNS INTEGER
//  #ENDIF
//#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//     ITEM_LIST
//
//   Parameters:
//     None.
//
//   Description:
//     This is the startment that markes the beginning of a list of
//     items to be attached to the current object.  A list class object
//     can not have a item list.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

// JJT-5.1
//#COMMAND ITEM_LIST .
//  #PUSH !Zg
//  #PUSH !Zj
//  #SET ZJ$ !a
//  #PUSH !Zj
//  #SET ZG$ 0              // Set the item counter to zero.  This is used to
//                         // count and assign ID's to the items.
//  !A [] OBJ$ILIST |CI0   // Create the command to save the item count,
//  #FREF OBJ$!Zj$INUM !a    // and tell flex to update it later.
//#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//    ON_Item {Value} {[SEND Message {TO Object} | BEGIN_PULL_DOWN Pull_Down_Name {Pull_Down_Image}]}
//
//   Parameters:
//     Value is a string.
//     Message is a integer.
//     Object is a integer.
//
//   Description:
//     The ITEM command adds the next item to the current object list.
//     The Message is the value which will be passed to the handler
//     if this item is selected.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

//#COMMAND ON_ITEM NDI """SEND""BEGIN_PULL_DOWN"
//  #IF (!0<2)
//    #IF (!0<1)
//      ON_ITEM '' SEND MSG_NONE
//    #ELSE
//      ON_ITEM !1 SEND MSG_NONE
//    #ENDIF
//  #ELSE
//    #IFSAME !1 SEND
//      ON_ITEM '' !1 !2 !3 !4 !5 !6 !7 !8 !9
//    #ELSE
//      #IFSAME !2 SEND
//        #SET ZG$ !ZG                   // Increment the item counter
//        #IFSAME !4 TO
//          #CHECK !6 .
//          #DATA
//          #IFDEF !3
//            #DPUSH !3           // Push the (variable) message
//          #ELSE
//            #IFDEF MSG_!3
//              #DPUSH MSG_!3     // Push the constant message
//            #ELSE
//              #DPUSH |CI0
//              #FREF MSG_!3 !a,0     // Forward fef the message
//            #ENDIF
//          #ENDIF
//          #IFDEF !5
//            #DPUSH !5           // Push the (expression, var) dest object
//          #ELSE
//            #IFDEF !5.OBJ
//              #DPUSH !5.OBJ     // Push the global object
//            #ELSE
//              #DPUSH |CI0
//              #FREF !5.OBJ !a,1     // Forward ref the object
//            #ENDIF
//          #ENDIF
//          !A [] OBJ$ITEM_EXEC !1 |VL
//        #ELSE
//          #IF (!0 > 3)
//            #CHECK !4 "TO"
//          #ENDIF
//          #IFDEF MSG_!3
//            !A [] OBJ$ITEM MSG_!3 !1       // Create the item passing name and value.
//          #ELSE
//            #IFDEF !3
//              !A [] OBJ$ITEM !3 !1         // Create the item passing name and value.
//            #ELSE
//              !A [] OBJ$ITEM |CI0 !1       // Create the item passing name and value.
//              #FREF MSG_!3 !a              // fix value later with procedure address
//            #ENDIF
//          #ENDIF
//        #ENDIF
//      #ELSE
//        #IFSAME !2 BEGIN_PULL_DOWN
//          #CHECK !3 _R
//          REGISTER_OBJECT !3
//          ON_ITEM !1 SEND ACTIVATE_PULL_DOWN TO (!3(CURRENT_OBJECT))
//          #IFSUB 'END_MENU'
//            CREATE_MENU !3 SUB_LOCATION !4 !5 !6 !7 !8 !9
//          #ELSE
//            #ERROR DFERR_COMP_INVALID_ARGUMENT "BEGIN_PULL_DOWN" REQUIRES MENU_SYSTEM PACKAGE
//          #ENDIF
//        #ENDIF
//      #ENDIF
//    #ENDIF
//  #ENDIF
//#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//      Repeat_Item Count# TIMES {Item_Syntax}
//
//   Parameters:
//
//   Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND REPEAT_ITEM _RNDE "TIMES"
  ON_ITEM !3 !4 !5 !6 !7 !8 !9
  #SET Q$ (!1-1)
  #IF (!q>0)
    REPEAT_ITEM !q TIMES !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//  Entry_Item File.Field {Entry_Options}
//
//   Parameters:
//
//   Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

// JJT-5.1
//#COMMAND ENTRY_ITEM R
//  #SET ZG$ !ZG
//  #DATA
//  #IFCLASS !1 "EC"
//    #ENTOPT {$C0A0=!1,$C002,$C003,!2}
//  #ELSE
//    #ENTOPT {$C0A0=!1,!2}
//  #ENDIF
//  !A [] OBJ$ENTRY$ITEM |CI0 |VL
//#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//     END_ITEM_LIST
//
//   Parameters:
//     None.
//
//   Description:
//     The END_ITEM_LIST command marks the end of a list of items.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

// JJT-5.1
//#COMMAND END_ITEM_LIST .
//  #POP ZJ$
//  #REPLACE OBJ$!Zj$INUM |CI!Zg     // Update the count in the ITEM_LIST cmd.
//  !A [] OBJ$ENDILIST OBJ$!Zj$INUM         // Tell runtime this is the end of list.
//  #POP ZJ$
//  #POP ZG$
//#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//  END_PULL_DOWN
//
//   Parameters:
//  None.
//
//   Description:
//      Ends the structure of an ON_ITEM ... BEGIN_PULL_DOWN ... as used by
//      Menu_System package.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND END_PULL_DOWN .
  #IFSUB 'END_MENU'
    END_ITEM_LIST
    END_OBJECT
  #ELSE
    #ERROR DFERR_COMP_INVALID_ARGUMENT "BEGIN_PULL_DOWN" REQUIRES MENU_SYSTEM PACKAGE
  #ENDIF
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//  On_Key KeyName SEND Message {TO Object} {PRIVATE}
//
//   Parameters:
//     KeyName is a valid hot key name.
//     Message is valid message name.
//     Object is the a valid object name.
//
//   Description:
//     The ON_KEY command tells the menu manager to pass the
//     specified Message code to the specified Object when the
//     KeyNAme is pressed.  If no Object name is passed, the current
//     object is used.  Passing MSG_NONE for Message causes the key to do
//     nothing, passing MSG_DEFAULT_KEY will restore the default key definition.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

//#COMMAND ON_KEY RULGBO#SDN "SEND" RLGBO#SDN """TO""PRIVATE" _DNOB """PRIVATE" .
//  #IFSAME !4 PRIVATE
//    ON_KEY !1 !2 !3 TO |CI-1 PRIVATE
//  #ELSE
//    #DATA
//    #DPUSH !1
//    #IFSAME !4 TO
//      #IFDEF !5
//        #DPUSH !5
//      #ELSE
//        #IFDEF !5.OBJ
//          #DPUSH !5.OBJ
//        #ELSE
//          #DPUSH |CI0
//          #FREF !5.OBJ !a,1
//        #ENDIF
//      #ENDIF
//    #ELSE
//      #DPUSH |CI-1
//    #ENDIF
//    #IFSAME !6 PRIVATE
//      #DPUSH |CI1
//    #ENDIF
//    #IFDEF !3
//      !A [] OBJ$ONKEY !3 |VL
//    #ELSE
//      #IFDEF MSG_!3
//        !A [] OBJ$ONKEY MSG_!3 |VL
//      #ELSE             // else the command is defined in flex code
//        !A [] OBJ$ONKEY |CI0 |VL        // get flex to fix the fwd ref
//        #FREF MSG_!3 !a
//      #ENDIF
//    #ENDIF
//  #ENDIF
//#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//     END_OBJECT
//
//   Parameters:
//     None required
//
//   Description:
//     END_OBJECT tells the manager we are done defining an object.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

// JJT-5.1
//#COMMAND END_OBJECT
//  //
//  // The following section was added 01-08-90 by SAL to support inheritable
//  // end-instance macros for classes
//  //
//  #IFSUB '!$$SC'  //if flex-defined class
//    #IFSUB '!$$EM'  //if end-instance macro defined for class,
//      !$$EM !$ !1 !2 !3 !4 !5 !6 !7 !8 !9
//    #ELSE
//      FORWARD_END_CONSTRUCT !$ !1 !2 !3 !4 !5 !6 !7 !8 !9
//    #ENDIF
//  #ELSE
//    DEFAULT_END_OBJECT  //else use default
//  #ENDIF
//  #SPOP           //restore old class name
//  //
//  // end of addition 01-08-90 by SAL
//  //
//#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//     DEFAULT_END_OBJECT
//
//   Parameters:
//     NONE
//
//   Description:
//     This command terminates an object declaration
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND DEFAULT_END_OBJECT .
  !A [] OBJ$END //Mark the end of the object list.
  #POP ZI$              //restore sub_obj_count
  #POP ZB$              //restore current_dep
  #POP B$               //restore obj_flag
  #POP ZJ$              //restore temp label
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//  Start_Ui {Object}
//
//   Parameters:
//     NONE
//
//   Description:
//  This command will dispatch io to the current focus.  it will
//  remain in this routine until a non-zero return code is received.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND START_UI
  #IF (!0>0)
    SEND ACTIVATE TO !1
  #ENDIF
  !A [] OBJ$IODISPATCH |CI0 |CI0
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//  UI_ACCEPT Object {GROUP | OBJECT} TO ReturnValue
//
//   Parameters:
//
//   Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND UI_ACCEPT RSDGBO#L RDGBO#L RDGBO#L _CEL#BOG .
  #IFSAME !2  GROUP OBJECT
    #CHECK !3 "TO"
    #DATA
    #IFSAME !2 GROUP
      #DPUSH |CI1
    #ELSE
      #IFSAME !2 OBJECT
        #DPUSH |CI0
      #ENDIF
    #ENDIF
    #DPUSH !4
    #IFDEF !1
      !A [] OBJ$ACCEPT !1 |VL
    #ELSE
      #IFDEF !1.OBJ
        !A [] OBJ$ACCEPT !1.OBJ |VL
      #ELSE
        !A [] OBJ$ACCEPT |CI0 |VL
        #FREF !1.OBJ !a
      #ENDIF
    #ENDIF
  #ELSE
    UI_ACCEPT !1 OBJECT !2 !3 !4 !5 !6 !7
  #ENDIF
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//  SET Property {OF Object} {ITEM #} TO Value {...}
//
//   Parameters:
//
//   Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SET
  GET$SET SET !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//  GET Property {OF Object} {ITEM #} TO Value {...}
//
//   Parameters:
//
//   Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND GET
  GET$SET GET !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//  FORWARD {GET | SET | SEND} Property {...}
//
//   Parameters:
//
//   Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND FORWARD "GET""SET""SEND"
//  #REPLACE __@INSIDE_FORWARD@__
  MOVE 1 TO FORWARD$MESSAGE
  !1 !2 !3 !4 !5 !6 !7 !8 !9
//  #UNDEF __@INSIDE_FORWARD@__     // Leaving function/proc.
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//  DELEGATE {GET | SET | SEND} Property {...}
//
//   Parameters:
//
//   Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND DELEGATE "GET""SET""SEND"
//  #REPLACE __@INSIDE_DELEGATE@__
  MOVE 8 TO FORWARD$MESSAGE
  !1 !2 !3 !4 !5 !6 !7 !8 !9
//  #UNDEF __@INSIDE_DELEGATE@__     // Leaving function/proc.
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//  BROADCAST {RECURSIVE | RECURSIVE_UP} {IGNORE_RETURN} {GET | SET | SEND} Property {...}
//
//   Parameters:
//
//   Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND BROADCAST "GET""SET""SEND""RECURSIVE""RECURSIVE_UP""NO_STOP"
  #IFSAME !1 RECURSIVE RECURSIVE_UP
    #CHECK !2 '"GET""SET""SEND""NO_STOP"'
    #IFSAME !1 RECURSIVE
      MOVE 20 TO FORWARD$MESSAGE    // broadcast + recursive_down
    #ELSE
      MOVE 68 TO FORWARD$MESSAGE    // broadcast + recursive_up
    #ENDIF
    #IFSAME !2 NO_STOP
      #CHECK !3 '"GET""SET""SEND"'
      MOVE (FORWARD$MESSAGE+128) TO FORWARD$MESSAGE // no stop on non-0 return
      !3 !4 !5 !6 !7 !8 !9
    #ELSE
      !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ELSE
    MOVE 4 TO FORWARD$MESSAGE       // broadcast
    #IFSAME !1 NO_STOP
      #CHECK !2 '"GET""SET""SEND"'
      MOVE (FORWARD$MESSAGE+128) TO FORWARD$MESSAGE // + no_stop
      !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND BROADCAST_FOCUS "GET""SET""SEND""RECURSIVE""RECURSIVE_UP""NO_STOP"
  #IFSAME !1 RECURSIVE RECURSIVE_UP
    #CHECK !2 '"GET""SET""SEND""NO_STOP"'
    #IFSAME !1 RECURSIVE
      MOVE 52 TO FORWARD$MESSAGE    // broadcast + focus + recursive_down
    #ELSE
      MOVE 100 TO FORWARD$MESSAGE   // broadcast + focus + recursive_up
    #ENDIF
    #IFSAME !2 NO_STOP
      #CHECK !3 '"GET""SET""SEND"'
      MOVE (FORWARD$MESSAGE+128) TO FORWARD$MESSAGE // no stop on non-0 return
      !3 !4 !5 !6 !7 !8 !9
    #ELSE
      !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ELSE
    MOVE 36 TO FORWARD$MESSAGE      // broadcast + focus
    #IFSAME !1 NO_STOP
      #CHECK !2 '"GET""SET""SEND"'
      MOVE (FORWARD$MESSAGE+128) TO FORWARD$MESSAGE // + no_stop
      !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//  Procedure {Set} Message {FOR Class} {{Type Argument} ...}
//
//   Parameters:
//
//   Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND PROCEDURE R
  // The interface to handle$message is slightly different in the mangling system.
  // The set is not concatenated with the symbol, because the mangling will generate its own symbol later.
  #IFSAME !1 SET
    #IFDEF MANGLE_NAMES
       HANDLE$MESSAGE SET !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
       HANDLE$MESSAGE SET_!2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ELSE
    #IFDEF MANGLE_NAMES
       HANDLE$MESSAGE MSG !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      HANDLE$MESSAGE MSG_!1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF
#ENDCOMMAND


#COMMAND MESSAGE$ADDRESS
  #IFDEF !1
  #ELSE             // assign the next message number now
    #SET ZC$ !ZC
    #IF (!Zc>$0FFFFFFF) // using 32-bit msg ids now (256M total allowed)
      #ERROR DFERR_COMP_TOO_MANY_MESSAGES Maximum number of message/property definitions exceeded
    #ELSE
//      #XREF Message !1 as |CI!Zc was defined on line !a
      #REPLACE !1 |CI!Zc      // this will cause all fwd refs to be fixed.
    #ENDIF
  #ENDIF
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//  Register_Procedure Message {FOR Class} {{Type Argument} ...}
//
//   Parameters:
//
//   Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


#COMMAND REGISTER_PROCEDURE R
  #IFDEF UI.EXISTS
  #ELSE
    USE UI
  #ENDIF
  #IFSAME GLOBAL !2 !3 // procedure or procedure set
    #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION GLOBAL PROCEDURES CANNOT BE REGISTERED
  #ELSE
    #IFSAME !1 SET
      // Error if already defined as global
      #IFDEF SET_!2
        #IF (SET_!2<0)
          #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION Set !2 is already defined as a global message
        #ENDIF
      #ENDIF

      // Make sure the argument list is correct
      CHECK$METHOD$ARGUMENT$LIST !3 !4 !5 !6 !7 !8 !9
      // Even if there were errors parsing the argument list, try to make the symbol so that we resolve fwd refs correctly.
      #IFDEF MANGLE_NAMES
        // For mangling, #MARG is used to read the line and parse the argument list.
        #IFSAME OVERLOADED !3 !4 !5 !6 !7 !8 !9
          #IFDEF SET_!2
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined As Non-Overloaded
          #ENDIF
          // #MARG returns the mangled name in !? which gets new message number.
          // we don't support Byref with overloading
          #IFSAME BYREF !3 !4 !5 !6 !7 !8 !9
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION "BYREF not allowed in overloaded methods"
          #ENDIF
          #MARG SET_!2 !3 !4 !5 !6 !7 !8 !9
          MESSAGE$ADDRESS !?
          // only create overloaded symbol if first time
          #IFNDEF SET_!2_OVERLOADED
            #REPLACE SET_!2_OVERLOADED   |CI1
          #ENDIF
        #ELSE
          #IFDEF SET_!2_OVERLOADED
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined As Overloaded
          #ENDIF
          MESSAGE$ADDRESS SET_!2
        #ENDIF
      #ELSE
        MESSAGE$ADDRESS SET_!2
      #ENDIF
    #ELSE
      // check for already defined as global
      #IFDEF MSG_!1
        #IF (MSG_!1<0)
          #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION MSG !1 is already defined as a global message
        #ENDIF
      #ENDIF
      // Check the argument list first
      CHECK$METHOD$ARGUMENT$LIST !2 !3 !4 !5 !6 !7 !8 !9
      // Likewise for messages with MSG prefix. #MARG is again used to parse the register_procedure line.
      #IFDEF MANGLE_NAMES
        #IFSAME OVERLOADED !2 !3 !4 !5 !6 !7 !8 !9
          #IFDEF MSG_!1
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined As Non-Overloaded
          #ENDIF
          // #MARG returns the mangled name in !? which gets new message number.
          // we don't support Byref with overloading
          #IFSAME BYREF !2 !3 !4 !5 !6 !7 !8 !9
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION "BYREF not allowed in overloaded methods"
          #ENDIF
          #MARG MSG_!1 !2 !3 !4 !5 !6 !7 !8 !9
          MESSAGE$ADDRESS !?
          // only create overloaded symbol if first time
          #IFNDEF MSG_!1_OVERLOADED
            #REPLACE MSG_!1_OVERLOADED   |CI1
          #ENDIF
        #ELSE
          #IFDEF MSG_!1_OVERLOADED
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined As Overloaded
          #ENDIF
          MESSAGE$ADDRESS MSG_!1
        #ENDIF
      #ELSE
        MESSAGE$ADDRESS MSG_!1
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND


// Argument list validation rules:
//
// The expected format is
//
//    type1 id1 type2 id2 ... typen idn
//
//    Functions have "Returns TypeReturn" at the end of the line.
//    The keyword OVERLOADED cannot be placed between the ids or types.
//    The keyword Global can proceed the list of parameters
//

//    Here are a list of the possible parsing errors.

#COMMAND CHECK$ARGUMENT$LIST$ERROR1
  #ERROR DFERR_COMP_INVALID_METHOD_SYNTAX TYPE FOLLOWS TYPE IN DECLARATION
#ENDCOMMAND

#COMMAND CHECK$ARGUMENT$LIST$ERROR2
  #ERROR DFERR_COMP_INVALID_METHOD_SYNTAX MISSING TYPE IN METHOD DECLARATION
#ENDCOMMAND

#COMMAND CHECK$ARGUMENT$LIST$ERROR3
  #ERROR DFERR_COMP_INVALID_METHOD_SYNTAX KEYWORD OVERLOADED CANNOT BE BETWEEN A TYPE AND AN IDENTIFIER
#ENDCOMMAND

#COMMAND CHECK$ARGUMENT$LIST$ERROR4
  #ERROR DFERR_COMP_INVALID_METHOD_SYNTAX RETURNS MUST BE FOLLOWED BY A RETURN TYPE
#ENDCOMMAND

#COMMAND CHECK$ARGUMENT$LIST$ERROR5
  #ERROR DFERR_COMP_INVALID_METHOD_SYNTAX MISSING IDENTIFIER BEFORE RETURNS KEYWORD
#ENDCOMMAND

#COMMAND CHECK$ARGUMENT$LIST$ERROR6
  #ERROR DFERR_COMP_INVALID_METHOD_SYNTAX MISSING TYPE IN METHOD DECLARATION
#ENDCOMMAND

#COMMAND CHECK$ARGUMENT$LIST$ERROR7
  #ERROR DFERR_COMP_INVALID_METHOD_SYNTAX MISSING RETURN TYPE AFTER KEYWORD RETURNS IN METHOD DECLARATION
#ENDCOMMAND

#COMMAND CHECK$ARGUMENT$LIST$ERROR8
  #ERROR DFERR_COMP_INVALID_METHOD_SYNTAX UNEXPECTED SYMBOL ENCOUNTERED AFTER RETURN TYPE IN METHOD DECLARATION
#ENDCOMMAND

#COMMAND CHECK$ARGUMENT$LIST$ERROR9
  #ERROR DFERR_COMP_INVALID_METHOD_SYNTAX EXPECTING IDENTIFIER AFTER TYPE IN METHOD DECLARATION
#ENDCOMMAND

#COMMAND CHECK$ARGUMENT$LIST$ERROR10
  #ERROR DFERR_COMP_INVALID_METHOD_SYNTAX UNEXPECTED DIMENSION SIZE SPECIFIER IN ARRAY TYPE DECLARATION
#ENDCOMMAND

// Validation code is like this:
//
// CHECK$METHOD$ARGUMENT$LIST is called in register_function, register_procedure, and external$function
//

#COMMAND CHECK$METHOD$ARGUMENT$LIST$FOR$ID   // This is called after a type is read.
  #IFADIM !1
    //Make sure it has no specified dimension size
    #SPUSH
    #DIMSTRIP !1
    #IFSAME !$ 0 |CI0
      CHECK$METHOD$ARGUMENT$LIST$FOR$ID !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      CHECK$ARGUMENT$LIST$ERROR10
    #ENDIF
    #SPOP
  #ELSE
    #IFSAME !1 BYREF
      CHECK$METHOD$ARGUMENT$LIST$FOR$ID2 !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      CHECK$METHOD$ARGUMENT$LIST$FOR$ID2 !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF
#ENDCOMMAND


#COMMAND CHECK$METHOD$ARGUMENT$LIST$FOR$ID2   // This is called after a type is read.
  #IF (!0>0)
    #IFSAME !1 OVERLOADED                       // Check for Overloaded between type and variable name
      CHECK$ARGUMENT$LIST$ERROR3
    #ELSE
      #IFSAME !1 RETURNS                 // Check if missing identifier before returns
        CHECK$ARGUMENT$LIST$ERROR5
      #ELSE
        #IFSAME !1 BYREF                 // Check for additional byref before identifier
          CHECK$ARGUMENT$LIST$ERROR9
        #ELSE
          // Parse now for the next type.
          CHECK$METHOD$ARGUMENT$LIST !2 !3 !4 !5 !6 !7 !8 !9
        #ENDIF
      #ENDIF
    #ENDIF
  #ELSE
    CHECK$ARGUMENT$LIST$ERROR9  // Missing identifier after type.
  #ENDIF
#ENDCOMMAND


#COMMAND CHECK$FOR$BOGUS$TRAILING$STUFF
  #IF (!0>0)
    #IFADIM !1
      //Array type
      //Make sure it has no specified dimension size
      #SPUSH
      #DIMSTRIP !1
      #IFSAME !$ 0 |CI0
        CHECK$FOR$BOGUS$TRAILING$STUFF !2
      #ELSE
        CHECK$ARGUMENT$LIST$ERROR10
      #ENDIF
      #SPOP
    #ELSE
      CHECK$ARGUMENT$LIST$ERROR8  // Garbage trailing on line
    #ENDIF
  #ENDIF
#ENDCOMMAND

// Return type must follow Returns Keyword
#COMMAND CHECK$FOR$RETURN$TYPE
  #IF (!0=0)
     CHECK$ARGUMENT$LIST$ERROR7  // Error: Missing return type after keyword RETURNS
  #ELSE
    #DTYPE Q$ !1 // only check if there is a valid data type
    #If (!q=-1) // Check for the various types. If we find them, parse for an identifier with CHECK$METHOD$ARGUMENT$LIST$FOR$ID
      #ERROR DFERR_COMP_INVALID_DATATYPE (!1)
    #ELSE
      CHECK$FOR$BOGUS$TRAILING$STUFF !2                 // Ok, look for garbage at end of line.
    #ENDIF
  #ENDIF
#ENDCOMMAND

// Check list of arguments.
//
// Expected line could start with OVERLOADED or RETURNS.
// Otherwise it will start with a list of type, identifier ordered pairs.

#COMMAND CHECK$METHOD$ARGUMENT$LIST
  #PUSH !q
  #IF (!0>0)
    #IFSAME !1 OVERLOADED
      // Start parse from the beginning (just ignores OVERLOADED)
      CHECK$METHOD$ARGUMENT$LIST !2 !3 !4 !5 !6 !7 !8 !9
    #ElSE
      #IFSAME !1 RETURNS
        // Look for return type that must follow it.
        CHECK$FOR$RETURN$TYPE !2 !3 !4 !5 !6 !7 !8 !9
      #ELSE
        #DTYPE Q$ !1 // only check if there is a valid data type
        #If (!q>-1) // Check for the various types. If we find them, parse for an identifier with CHECK$METHOD$ARGUMENT$LIST$FOR$ID
            CHECK$METHOD$ARGUMENT$LIST$FOR$ID !2 !3 !4 !5 !6 !7 !8 !9
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
  #POP Q$
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//  CALL RoutineName {Parameters ...}
//
//   Parameters:
//
//   Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND CALL RGBO#L
  SEND !1 TO DESKTOP !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//  SUB_PAGE NewPage FROM FromPage ;
//      { (WindowNumber) | ;
//      ({VERTICAL|HORIZONTAL} FromWindow ForWindows) | ;
//      (RECTANGULAR FromWindow NumColumns NumRows) } {...}
//
//   Parameters:
//
//   Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SUB_PAGE RT "FROM" RGBO#L
  #PUSH !Zg             // h is the number of windows on
  #SET ZG$ 0                // the sub page.
  #DATA                 // start up the arguments
  #IFDEF !3
    #DPUSH !3               // based on variable page number
  #ELSE
    #CHECK !3.N _U
    #DPUSH !3.N             // based on absolute page number
  #ENDIF
  SUB$IMAGE$DEFINE !4 !5 !6 !7 !8 !9    // loop thru the passed arguments
  #DPUSH |CI!Zg             // store the number of windows
  #IFDEF !1.N
    #IFCLASS !1.N "C"
      #ERROR DFERR_COMP_DUPLICATE_PAGE_NAME SUB_PAGE !1 ALREADY DEFINED AS A PHYSICAL IMAGE
    #ELSE
      !A [] REDEFINE$SUB$PAGE !1.N |VL    // create the sub image
    #ENDIF
  #ELSE
    INTEGER !1.N            // create a int to place page # into
    !A [] CREATE$SUB$PAGE !1.N |VL  // create the sub image
  #ENDIF
  #POP ZG$              // restore our general counter
#ENDCOMMAND

#COMMAND SUB$IMAGE$DEFINE
  #IF (!0>0)
    #IFSAME !1 VERTICAL         // define a vertical set of windows
        #DPUSH |CI-1          // vertical flag
        #DPUSH !2             // push the start window number
        #DPUSH !3             // and the number of windows
        #SET ZG$ (!Zg+!3)         // how many was that?
        SUB$IMAGE$DEFINE !4 !5 !6 !7 !8 !9    // one more time
    #ENDIF
    #IFSAME !1 HORIZONTAL     // horzontal (contiguous) windows
        #DPUSH |CI-2            // horizontal flag
        #DPUSH !2           // push the start window number
        #DPUSH !3           // and the number of windows
        #SET ZG$ (!Zg+!3)           // how many was that?
        SUB$IMAGE$DEFINE !4 !5 !6 !7 !8 !9  // one more time
    #ENDIF
    #IFSAME !1 RECTANGULAR      // a rectangular array of windows
        #DPUSH |CI-3          // the rect. flag
        #DPUSH !2         // push the start window number
        #DPUSH !3         // number of windows per row
        #DPUSH !4         // number of rows
        #SET ZG$ (!Zg+(!3*!4))        // not bad huh
        SUB$IMAGE$DEFINE !5 !6 !7 !8 !9   // and again
    #ENDIF
    #IFSAME !1 VERTICAL RECTANGULAR HORIZONTAL // May look strange, but reduces
    #ELSE                                      // use of #if stack levels.
        #DPUSH !1         // its just a single window def
        #SET ZG$ !ZG          // just add one
        SUB$IMAGE$DEFINE !2 !3 !4 !5 !6 !7 !8 !9  // recurse
    #ENDIF
  #ENDIF
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//
//   Parameters:
//
//   Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND MOVE_SUB_PAGE _RDOBR "TO" _RDOBRU
  #IFDEF !1
    !A [] MOVE$SUB$PAGE !1 !3
  #ELSE
    #CHECK !1.N _U
    !A [] MOVE$SUB$PAGE !1.N !3
  #ENDIF
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//  USE PackageName | UI
//
//   Parameters:
//
//   Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#COMMAND USE R
  #IFSAME !1 UI
    #IFSUB '!1.EXISTS'
    #ELSE
      #REPLACE !1.EXISTS |CI!a
      INITIALIZE_INTERFACE
       Define$BuiltIn$DF$Messages   // Define built in DF messages
       Define$BuiltIn$VDF$Messages  // Define built in VDF messages
       Define$BuiltIn$WAS$Messages  // Define built in Web App messages
       Define$BuiltIn$XML$Messages  // Define built in XML messages
       Define$BuiltIn$Transfer$Messages  // For FTP and HTTP classes
       Define$BuiltIn$Flexcom2$Messages  // flexcom2
    #ENDIF
  #ELSE
    #USE !1
  #ENDIF
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//
//   Parameters:
//
//   Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND VFIND R R R .
  MOVE !2 TO INDEX_NUMBER
  #IFSAME !3 $0 $1 $2 $3 $4
    #SET Q$ !3
    !A [] $CC !1 |CI!q
  #ELSE
    !A [] $CC !1 !3
  #ENDIF
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//
//   Parameters:
//
//   Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SCREEN_OPTIMIZE RL .
  #IFSAME !1 $0 $1
    #PUSH !Zg
    #SET ZG$ !1
    !A [] SCREEN$OPT |CI!Zg
    #POP ZG$
  #ELSE
    !A [] SCREEN$OPT !1
  #ENDIF
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//     FORWARD_BEGIN_CONSTRUCT ClassName { <argument> ... }
//
//   Parameters:
//     ClassName is the name of the class which owns the macro that is
//         forwarding.
//     <argument> is any argument required
//
//   Description:
//     This command allows the instance-creation macros defined for classes
//     to 'inherit' the instance-creation macro(s) defined by their
//     superclass(es).
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND FORWARD_BEGIN_CONSTRUCT R //<currentClassName> { <arg> ... }
  #IFSUB '!1$SC' // if flex-defined class
    #SPUSH
    #SET $$ !1$SC  //get superclass name
    #IFSUB '!$$SM' //if class defines start macro
      !$$SM !$ !2 !3 !4 !5 !6 !7 !8 !9   //invoke it
    #ELSE          //else not defined
      FORWARD_BEGIN_CONSTRUCT !$ !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
    #SPOP
  #ELSE
    ADD$IMAGE$ARGS MSG_CONSTRUCT_OBJECT !2 !3 !4 !5 !6 !7 !8 !9  //use default
  #ENDIF
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//     FORWARD_END_CONSTRUCT ClassName { <argument> ... }
//
//   Parameters:
//     ClassName is the name of the class which owns the macro that is
//       forwarding.
//     <argument> is any argument required
//
//   Description:
//     This command allows the instance-ending macros defined for classes
//     to 'inherit' the instance-ending macro(s) defined by their
//     superclass(es).
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND FORWARD_END_CONSTRUCT R //<currentClassName> { <arg> ... }
  #IFSUB '!1$SC' // if flex-defined class
    #SPUSH       // note: #SPUSH with no arg it pushes !$ (with no replacement). Don't pass arguments (obsolete technique as of 11.1)
    #SET $$ !1$SC  //get superclass name
    #IFSUB '!$$EM' //if end-instance macro defined,
      !$$EM !$ !2 !3 !4 !5 !6 !7 !8 !9  //use it
    #ELSE
      FORWARD_END_CONSTRUCT !$ !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
    #SPOP       // note: #SPOP always pops to $$ - it never takes an argument
  #ELSE
    DEFAULT_END_OBJECT  //else use default
  #ENDIF
#ENDCOMMAND

#COMMAND SET_DEFERRED &R .
  !A [] $460 !1
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//     NAME_ITEM <object_name> item names...
//
//   Description:
//      Gives names to items of objects in the form: object.item
//      Assumes item number has already been set.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#COMMAND NAME_ITEM RT#L R
  #IFDEF !2
    #CHECK !2 _#LUVFEWNSG
    #SET Q$ !2
    NAME_ITEM !1 !3 !4 !5 !6 !7 !8 !9
  #ELSE
    #IFSAME !2 ITEM
      NAME_ITEM !1 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      #IFSAME !2 COLUMN
        NAME_COLUMN !1 !3 !4 !5 !6 !7 !8 !9
      #ELSE
        #IFSAME !2 PROPERTY
          NAME_PROPERTY !1 !3 !4 !5 !6 !7 !8 !9
        #ELSE
          #REPLACE !1.!2 !1.OBJ ITEM !q
          #SET Q$ (!q+1)
          #IF !0>2
              NAME_ITEM !1 !3 !4 !5 !6 !7 !8 !9
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//     NAME_COLUMN <object_name> item names...
//
//   Description:
//      Gives names to items of objects in the form: object.item
//      Just like name_item except item numbers are relative to
//      base_item.
//      Assumes item number has already been set.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#COMMAND NAME_COLUMN RT#L R
  #IFDEF !2
    #CHECK !2 _#LUVFEWNSG
    #SET Q$ !2
    NAME_COLUMN !1 !3 !4 !5 !6 !7 !8 !9
  #ELSE
    #IFSAME !2 ITEM
      NAME_ITEM !1 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      #IFSAME !2 COLUMN
        NAME_COLUMN !1 !3 !4 !5 !6 !7 !8 !9
      #ELSE
        #IFSAME !2 PROPERTY
          NAME_PROPERTY !1 !3 !4 !5 !6 !7 !8 !9
        #ELSE
          #REPLACE !1.!2 !1.OBJ ITEM (BASE_ITEM(!1.OBJ)+!q)
          #SET Q$ (!q+1)
          #IF !0>2
            NAME_COLUMN !1 !3 !4 !5 !6 !7 !8 !9
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//     NAME_PROPERTY <object_name> property names...
//
//   Description:
//      Gives names to property of objects in the form: object.item
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND NAME_PROPERTY RT#L RT
  #IFSAME !2 ITEM
    NAME_ITEM !1 !3 !4 !5 !6 !7 !8 !9
  #ELSE
    #IFSAME !2 COLUMN
      NAME_COLUMN !1 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      #IFSAME !2 PROPERTY
        NAME_PROPERTY !1 !3 !4 !5 !6 !7 !8 !9
      #ELSE
        #REPLACE !1.!2 (!2(!1.OBJ))
        #IF !0>2
          NAME_PROPERTY !1 !3 !4 !5 !6 !7 !8 !9
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//     NAME_OBJECT <object_name> ACCESS item names...
//          ACCESS = CHILD, GLOBAL, COLUMN, PROPERTY, ITEM or ACCESS METHOD.
//
//   Description:
//      Gives names to objects in the form: object.obj
//      and allows items, properties and COLUMNs to be defined.
//      Inits item number to zero and assumes item names follow.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND NAME_OBJECT RT#L R
  #SET Q$ 0
  #IFDEF !2
    #CHECK !2 _R#LSD
    #REPLACE !1.OBJ !2
    #IF !0>2
      NAME_ITEM !1 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ELSE
//    #CHECK !2 "CHILD""ITEM""GLOBAL""COLUMN""PROPERTY"
    #IFSAME !2 CHILD
      REGISTER_OBJECT !1
      #IFDEF !3
        NAME_OBJECT !1 (!1(!3))  !4 !5 !6 !7 !8 !9
      #ELSE
        #CHECK !3.OBJ _#LU
        NAME_OBJECT !1 (!1(!3.OBJ))  !4 !5 !6 !7 !8 !9
      #ENDIF
    #ELSE
      #IFSAME !2 GLOBAL
        #IFDEF !1.OBJ
          #CHECK !1.OBJ _NSDFW#L
        #ELSE
          INTEGER !1.OBJ
        #ENDIF
        #IFCLASS !1.OBJ V$
          #IF (!b & 1)
            MOVE CURRENT_OBJECT TO !1.OBJ
          #ELSE
            #IF (!b)
              #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT NAME_OBJECT MUST PRECEDE CLASS OR PROCEDURE
            #ELSE
              MOVE 1023 TO !1.OBJ
            #ENDIF
          #ENDIF
        #ENDIF
        #IF !0>2
          NAME_ITEM !1 !3 !4 !5 !6 !7 !8 !9
        #ENDIF
      #ELSE
        NAME_!2 !1 !3 !4 !5 !6 !7 !8 !9
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND ITEM_GROUP .
  #PUSH !Zd
  #PUSH !Ze
  #SET ZD$ 0
  !A [] $462 |CI0        //create new item group; size is fwd-ref'd
  #SET ZE$ !a
  #FREF ITEM$GROUP!Ze !a
#ENDCOMMAND

#COMMAND END_ITEM_GROUP .
  #REPLACE ITEM$GROUP!Ze |CI!Zd  //define size of item group
  #POP ZE$
  #POP ZD$
#ENDCOMMAND

#COMMAND DEPENDENT_ITEM R
  #IFSAME !2 ITEM    //if ITEM is second arg, item name replacement was used
    #IFDEF !1
      !A [] $463 !1 !3 //add obj#,item# pair to current item group
    #ELSE
      !A [] $463 !1.OBJ !3 //add obj#,item# pair to current item group
    #ENDIF
    #SET ZD$ !ZD         //increment element counter
    #IF (!0>3)
      DEPENDENT_ITEM !4 !5 !6 !7 !8 !9
    #ENDIF
  #ELSE
    #IFDEF !1
      !A [] $463 !1 !2 //add obj#,item# pair to current item group
    #ELSE
      !A [] $463 !1.OBJ !2 //add obj#,item# pair to current item group
    #ENDIF
    #SET ZD$ !ZD         //increment element counter
    #IF (!0>2)
      DEPENDENT_ITEM !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//  IMPORT_CLASS_PROTOCOL Source Dest {Msg | ALL} {Flag}
//
//   Description:
//  This command will copy the message definitions of the Source
//  class to the Dest class.  The program may choose to copy ALL
//  of the messages or only one of the messages from the Source.
//  The program has the option to stop any message that would overwrite
//  and to stop the copying of messages not directly defined in the
//  Source class.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND IMPORT_CLASS_PROTOCOL _RSNDLOB# _SNDLOB#
  #IF (!0<2)
    IMPORT_CLASS_PROTOCOL !1 CURRENT_CLASS
  #ELSE
    #DATA       // Begining of data
    #IFDEF !1       // class is variable (integer) or constant
      #DPUSH !1     // defined_in
    #ELSE
      #IFDEF U_!1
        #DPUSH U_!1   // class is normal symbol type (integer)
      #ELSE
        #ERROR DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT UNDEFINED CLASS U_!1
      #ENDIF
    #ENDIF
    #IFDEF !2       // is the destination defined?
      #DPUSH !2     // add to class
    #ELSE
      #IFSAME !2 CURRENT_CLASS  // use this symbol for "current class"
        #DPUSH U_!$     // cc is in this symbol (set by class)
      #ELSE
        #IFDEF U_!2
          #DPUSH U_!2     // another standard class id
        #ELSE
          #ERROR DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT UNDEFINED CLASS U_!2
        #ENDIF
      #ENDIF
    #ENDIF
    #IF (!0>2)      // message or all specified
      #IFSAME !3 ALL    // copy all messages
        #DPUSH |CI0 // 0 is all
      #ELSE
        #IFDEF !3
          #DPUSH !3 // message name, note full name required
        #ELSE
          #IFDEF MSG_!3
            #DPUSH MSG_!3
          #ELSE
            #IFDEF SET_!3
              #DPUSH SET_!3
            #ELSE
              #IFDEF GET_!3
                #DPUSH GET_!3
              #ELSE
                #ERROR DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT UNDEFINED MESSAGE NAME !3
              #ENDIF
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
      #IF (!0>3)
        #SET Q$ 0
        CHAIN$HELP !4 !5    // NO_INHERIT and NO_OVERWRITE
        #DPUSH |CI!q    // flags
      #ELSE
        #DPUSH |CI0 // no flags
      #ENDIF
    #ELSE
      #DPUSH |CI0   // all messages
      #DPUSH |CI0   // overwrite and superclasses
    #ENDIF
    !A [] $0465 |CI0 |VL
  #ENDIF
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      LOGOUT {Driver Name {Server Name}}
//
//  Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND LOGOUT
  !A [] $4c6 !1 !2
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      SET_TRANSACTION_RETRY
//
//  Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SET_TRANSACTION_RETRY "TO" &#LGRBOUSD .
  !A [] $4c8 !2
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      GET_TRANSACTION_RETRY
//
//  Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND GET_TRANSACTION_RETRY "TO" R .
  !A [] $4c9 !2
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      COPY_DB
//
//  Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND COPY_DB RNDI#G_ "TO" RN_DI#G
  COPY$DB$CALLBACK 0
  COPY$DB$COMPRESSION DF_FILE_COMPRESS_NONE DFFALSE
  #IF ( !0 > 3 )
    #IF ( !0 > 5 )
      #IFSAME !4 !6
        #ERROR DFERR_COMP_INVALID_ARGUMENT PARAMETER DUPLICATION !4 !6
      #ELSE
        #IFSAME !6 COMPRESSION
          COPY$DB$COMPRESSION !7 DFTRUE
        #ELSE
          #IFSAME !6 CALLBACK
            COPY$DB$CALLBACK !7
          #ELSE
            #ERROR DFERR_COMP_INVALID_ARGUMENT INVALID PARAMETER !6
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
    #IFSAME !4 COMPRESSION
      COPY$DB$COMPRESSION !5 DFTRUE
    #ELSE
      #IFSAME !4 CALLBACK
        COPY$DB$CALLBACK !5
      #ELSE
        #ERROR DFERR_COMP_INVALID_ARGUMENT INVALID PARAMETER !4
      #ENDIF
    #ENDIF
  #ENDIF
  !A [] $0e3 !1 !3
#ENDCOMMAND

#COMMAND COPY$DB$CALLBACK R .
  !A [] $0e4 !1
#ENDCOMMAND

#COMMAND COPY$DB$COMPRESSION R R .
  !A [] $0e5 !1 !2
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      DECLARE_DATAFILE logicalFileName*n
//
//  Description:
//      Include the .FD for the named file and define any related symbols,
//      e.g., FILE.FILE_NUMBER
//
//  Parameter
//      logicalFileName
//          Base name of the .FD file, e.g., for PERSON.FD, it would be
//          PERSON.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

//#COMMAND DECLARE_DATAFILE L#GT
//  #IF (!0>0)
//    #IFDEF !1.RECNUM
//      #IFDEF !1.FILE_NUMBER
//      #ELSE
//        #SET Q$ !1.RECNUM
//        #REPLACE !1.FILE_NUMBER |CI!q
//      #ENDIF
//    #ELSE
//      #INCLUDE !1.FD
//      #SET Q$ !1.RECNUM
//      #REPLACE !1.FILE_NUMBER |CI!q
//    #ENDIF
//    DECLARE_DATAFILE !2 !3 !4 !5 !6 !7 !8 !9
//  #ENDIF
//#ENDCOMMAND

// Newer files may include the file_number symbol within the fd file. The rules should be:
// 1. If file has a recnum, it must define recnum in the file and it must NOT define file_number
//    (we don't define file_number so these fd files will be compatible with older DFs). In this case, file_number
//    will be defined in this command.
// 2. If file is new and does not support recnum, we define File_number but not recnum. Recnum will not
//    be defined at all.
// Therefore, by the end of this command, file_number is always defined and recnum is defined only if it exists

#COMMAND DECLARE_DATAFILE L#GT
  #IF (!0>0)
    #IFNDEF !1.RECNUM
      #IFNDEF !1.FILE_NUMBER
          // if neither file_number or recnum is defined, we must include the fd file
          #INCLUDE !1.FD
      #ENDIF
    #ENDIF
    // if file_number does not exist at this point we have an FD that does not
    // directly define it (i.e., pre rowID FD or table that suports recnum). Create the symbol
    #IFNDEF !1.FILE_NUMBER
      #SET Q$ !1.RECNUM
      #REPLACE !1.FILE_NUMBER |CI!q
    #ENDIF
    DECLARE_DATAFILE !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      SET_FILE_FIELD fileNum fieldNum
//      SET_FILE_INDEX fileNum indexNum
//
//  Description:
//      Used by API commands requiring more than 2 parameters. Assigns
//      the fileNum and field or index number. Two commands were provided
//      to allow improve readability of code.
//
//  Parameters:
//      fileNum:
//          The number of the file.
//      fieldNum:
//      indexNum:
//          The number of the field or index ( depending on the command.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SET_FILE_FIELD ULG# ULG# .
    !A [] $502 !1 !2
#ENDCOMMAND

#COMMAND SET_FILE_INDEX ULG# ULG# .
    !A [] $502 !1 !2
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      SET_SEGMENT_MISC segmentNum miscNum
//
//  Description:
//      Used by API commands requiring more than 2 parameters. Assigns
//      the segmentNum and miscNum.
//
//  Parameters:
//      segmentNum:
//          The number of the segment of an index
//      miscNum:
//          A command dependent numeric value.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SET_SEGMENT_MISC ULG# ULG# .
    !A [] $503 !1 !2
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      SET_LENGTH_OFFSET length offset
//
//  Description:
//      Used by API commands requiring additional length and offset
//      parameters.
//
//  Parameters:
//      length:
//          Typically in bytes.
//      offset:
//          Typically in bytes.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SET_LENGTH_OFFSET ULG# ULG# .
    !A [] $52E !1 !2
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//     GET_ATTRIBUTE attribute;
//         {OF fileNum {fieldNum|(indexNum {segmentNum})} "TO" VARIABLE
//
//  Description:
//     Get a global, file, field, or index attribute.
//
//  Parameters
//      attribute
//          Attribute id (as defined by API) to be set
//      fileNum
//          Optional handle for either a file or a structure
//      fieldNum
//          Optional field to be interrogated
//      indexNum
//          Optional index to be interrogated
//      segmentNum
//          Num of segment in index to be interrogated
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND GET_ATTRIBUTE RLGU#
  #IFSAME !2 TO
    #CHECK !3 _RLGUC#
    #CHECK !4 .
    SET_FILE_FIELD |CI0 |CI0
    SET_SEGMENT_MISC |CI0 |CI0
    !A [] $501 !1 !3
  #ELSE
    #IFSAME !2 OF
    #ELSE
      #ERROR DFERR_COMP_INVALID_MESSAGE_SYNTAX Missing keyword "OF"
    #ENDIF
    #IFSAME !4 TO
      #CHECK !3 _RLGU#
      #CHECK !5 _RLGU#
      #CHECK !6 .
      SET_FILE_FIELD !3 |CI0
      SET_SEGMENT_MISC |CI0 |CI0
      !A [] $501 !1 !5
    #ELSE
      #IFSAME !5 TO
        #CHECK !3 _RLGU#
        #CHECK !4 _RLGU#
        #CHECK !6 _RCLGU#
        #CHECK !7 .
        SET_FILE_FIELD !3 !4
        SET_SEGMENT_MISC |CI0 |CI0
        !A [] $501 !1 !6
      #ELSE
        #IFSAME !6 TO
          #CHECK !3 _RLGU#
          #CHECK !4 _RLGU#
          #CHECK !5 _RLGU#
          #CHECK !7 _RCLGU#
          #CHECK !8 .
          SET_FILE_FIELD !3 !4
          SET_SEGMENT_MISC !5 |CI0
          !A [] $501 !1 !7
        #ELSE
          #ERROR DFERR_COMP_INVALID_MESSAGE_SYNTAX Missing keyword "TO"
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND


//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//     SET_ATTRIBUTE attribute;
//         {OF fileNum {fieldNum|(indexNum {segmentNum})} "TO" VARIABLE
//
//  Description:
//     Get a global, file, field, or index attribute.
//
//  Parameters
//      attribute
//          Attribute id (as defined by API) to be set
//      fileNum
//          Optional handle for either a file or a structure
//      fieldNum
//          Optional field to be modified
//      indexNum
//          Optional index to be modified
//      segmentNum
//          Num of segment in index to be modified
//
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SET_ATTRIBUTE RLG#
  #IFSAME !2 TO
    #CHECK !3 _RLGU#
    #CHECK !4 .
    SET_FILE_FIELD |CI0 |CI0
    SET_SEGMENT_MISC |CI0 |CI0
    !A [] $504 !1 !3
  #ELSE
    #IFSAME !2 OF
    #ELSE
      #ERROR DFERR_COMP_INVALID_MESSAGE_SYNTAX Missing keyword "OF"
    #ENDIF
    #IFSAME !4 TO
      #CHECK !3 _RLGU#
      #CHECK !5 _RLGU#
      #CHECK !6 .
      SET_FILE_FIELD !3 |CI0
      SET_SEGMENT_MISC |CI0 |CI0
      !A [] $504 !1 !5
    #ELSE
      #IFSAME !5 TO
        #CHECK !3 _RLGU#
        #CHECK !4 _RLGU#
        #CHECK !6 _RLGU#
        #CHECK !7 .
        SET_FILE_FIELD !3 !4
        SET_SEGMENT_MISC |CI0 |CI0
        !A [] $504 !1 !6
      #ELSE
        #IFSAME !6 TO
          #CHECK !3 _RLGU#
          #CHECK !4 _RLGU#
          #CHECK !5 _RLGU#
          #CHECK !7 _RLGU#
          #CHECK !8 .
          SET_FILE_FIELD !3 !4
          SET_SEGMENT_MISC !5 |CI0
          !A [] $504 !1 !7
        #ELSE
          #ERROR DFERR_COMP_INVALID_MESSAGE_SYNTAX Missing keyword "TO"
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//     STRUCTURE_START fileNum driverName
//
//  Description:
//     This function begins creation of a new file or modification of
//     an existing file.
//
//  Parameters:
//     fileNum:
//         The number for an existing file. It must be 0 if starting a
//         new file or the number of a file being modified. In either
//         case, a handle to the structure is written back into fileNum
//         so that attributes of the new structure can be queried.
//
//     driverName:
//         Name of the driver to use when creating a new file.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND STRUCTURE_START RLG#U INDLG#U .
    !A [] $505 !1 !2
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      STRUCTURE_ABORT structureHandle
//
//  Description:
//      Terminates a file structure operation without completing it.
//
//  Parameters:
//      structureHandle
//          Handle from the structure_start.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND STRUCTURE_ABORT RLG#U .
    !A [] $508 !1
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      STRUCTURE_END fileNum {restructureOptions {tempDir {callBackObject}}}
//
//  Description:
//      This function commits a structure operation, performing restructure
//      on the file if necessary.
//
//  Parameters:
//      fileNum:
//          The number of the file ( or handle returned by STRUCTURE_START
//          for a new file ) which a STRUCTURE_START has been done on.
//
//      restructureOptions:
//          The IAND'ing of the following API attributes:
//              DF_STRUCTEND_OPT_NONE
//              DF_STRUCTEND_OPT_FORCE
//              DF_STRUCTEND_OPT_RECOMPRESS
//              DF_STRUCTEND_OPT_INPLACE
//
//      tempDir:
//          A temporary directory to be used in not restructuring in place.
//
//      callBackObject:
//          An object id which will receive MSG_CALLBACK during the restructure
//          operation. This the first parameter of this message is a string
//          containing progress information.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND STRUCTURE_END RLUG# LUG# NDILUG# LUG# .
    !A [] $506 !1 !2
    !A [] $507 !3 !4
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//        STRUCTURE_COPY fromFileNumber TO toFileNumber
//
//  Descriptiion:
//        Copies structure of one file to another
//
//  Parameters:
//        fromFileNumber:
//            File Number of the file from where the structure is to be copied
//
//        toFileNumber:
//            Number of the file to which the structure is to be copied
//
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


#COMMAND STRUCTURE_COPY RLUG# "TO" RLUG# .
    !A [] $51C !1 !3
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//        FILL_FIELD FileNumber fieldNumber { "WITH" <Fill_Type> }
//
//  Description:
//        Fill a field with the highest or lowest value ot the type.
//  Fill_type:
//         DF_HIGH or DF_LOW. For example for a numeric field, DF_HIGH is
//         all 9's and lowest being all 0's
//
//  Parameters:
//         FileNumber:
//            Number of the file
//
//         Field Number:
//            Number of the field which is to be filled
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND FILL_FIELD RLUG# RLUG#  "WITH" RLUG# .
    !A [] $51D !1
    !A [] $51E !2 !4
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      CREATE_FIELD fileNum {"AT" fieldNum}
//
//  Description:
//      Creates a new field. If fieldNum is ommitted or 0,
//      field is appended to record. Actual fieldNum assigned
//      to new field is returned in fieldNum. fileNum must
//      be the number of a file currently being restructured or
//      created.
//
//  Parameter:
//      fileNum
//          Handle for either a file or a structure
//      fieldNum
//          Field to be modified
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND CREATE_FIELD RLUG# "AT""" LUG# .
    !A [] $509 !1 !3
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      DELETE_FIELD fileNum fieldNum
//
//  Description:
//      Delete the field described by fieldNum and fileNum. NOTE:
//      the fileNum handle must be for a file that has had a STRUCTURE_START
//      done on it.
//
//  Parameter:
//      fileNum
//          Handle for either a file or a structure
//      fieldNum
//          Field to be modified
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND DELETE_FIELD R R .
    !A [] $50b !1 !2
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      CREATE_INDEX fileNum {"AT" indexNum}
//
//  Description:
//      Creates a new index for file fileNum. STRUCTURE_START must have
//      been called for fileNum. IndexNum will contain the number of
//      the index created; any value in it prior to the call is ignored.
//
//  Parameter:
//      indexNum
//          Handle for either a file or a structure
//      fieldNum
//          Field to be modified
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND CREATE_INDEX RLUG# "AT" RLUG#C .
    !A [] $50a !1 !3
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      DELETE_INDEX fileNum indexNum
//
//  Description:
//      Delete the index described by indexNum and fileNum. NOTE:
//      the fileNum handle must be for a file that has had a
//      STRUCTURE_START done on it.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND DELETE_INDEX RLUG# RLUG# .
    !A [] $50c !1 !2
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      VARIABLE_FILE_COMMAND command [fileSymbol|fileNum]
//
//  Description:
//      This command allows the execution of any other command,
//      handling both file numbers ( 102 ) and file symbols
//      ( PERSON )
//
//  Parameters:
//      command:
//          The DataFlex command number
//      fileSymbol:
//          The symbol used to load the .FD file; the logical name of the file.
//      fileNum:
//          The number of the file ( obviously ).
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND VARIABLE_FILE_COMMAND
  //#IFSAME !2 |FS0,0& |FN0,0& |FD0,0&
  // This supports both Indirect_file and Indirect_file.Recnum -JJT
  #IFSAME !2.FILE_NUMBER |FS0,0& |FN0,0& |FD0,0& |FS0,0&.RECNUM
    !A [] !1 |CI0 !3
  #ELSE
    #IFCLASS !2 SNDIECWVF
        !A [] !1 !2 !3
    #ELSE
        DECLARE_DATAFILE !2
        !A [] !1 !2.FILE_NUMBER !3
    #ENDIF
  #ENDIF
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      OPEN {fileName AS} [logicalName|fileNum|] {MODE fileMode} index
//
//  Description:
//      Open a DataFile using the specified filename of filenumber.
//
//  Parameters:
//      fileName:
//          A string containing the physical name of the file
//      logicalName:
//          The symbolic name used to find the .FD file.
//      fileNum:
//          A number which will be used to open the file. If using the "AS"
//          form, fileNum may be a variable containing a 0. In that case,
//          filelist will be searched for an entry with a logical name
//          matching fileName; the number of the first entry matching will
//          be used as the number to open the file and will be written
//          back to the variable used for fileNum.
//      fileMode:
//          The mode to open the file in ( e.g., DF_EXCLUSIVE ).
//      index:
//          Index to buffer, may be either a number or an index symbol (INDEX.1)
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND API_OPEN RLG#
  #IFSAME !2 AS
    //#IFSAME !3 |FS0,0& |FN0,0& |FD0,0&
    // This supports both Indirect_file and Indirect_file.Recnum -JJT
    #IFSAME !3.FILE_NUMBER |FS0,0& |FN0,0& |FD0,0& |FS0,0&.RECNUM
        #SET Q$ $516 // Open indirect
    #ELSE
        #SET Q$ $50d // Open normally
    #ENDIF
    #IFSAME !4 MODE
      #CHECK !5 _RLUG#
      !A [] $517 !5 !6
      VARIABLE_FILE_COMMAND !q !3 !1
    #ELSE
      !A [] $517 DF_SHARE !4
      VARIABLE_FILE_COMMAND !q !3 !1
    #ENDIF
  #ELSE
    //#IFSAME !1 |FS0,0& |FN0,0& |FD0,0&
    // This supports both Indirect_file and Indirect_file.Recnum -JJT
    #IFSAME !1.FILE_NUMBER |FS0,0& |FN0,0& |FD0,0& |FS0,0&.RECNUM
        #SET Q$ $516 // Open indirect
    #ELSE
        #SET Q$ $50d // Open normally
    #ENDIF
    #IFSAME !2 MODE
      #CHECK !3 _RLUG#
      !A [] $517 !3 !4
      VARIABLE_FILE_COMMAND !q !1 |CS""
    #ELSE
      !A [] $517 DF_SHARE !2
      VARIABLE_FILE_COMMAND !q !1  |CS""
    #ENDIF
  #ENDIF
#ENDCOMMAND

// Removed for 11.0 - only works with recnum tables. This was never documented and never designed to be used.
// The Old_xxx commands were created when the API was added and probably left here for testing.
// Anyone using the direct old command value (e.g. $c4 for relate) will only work with recnum tables. It is
// very unikely anyone is using the actual command codes (a very bad practice that this not at all supported).
//#COMMAND OLD_OPEN
//  #IFSAME !2 AS
//    DECLARE_DATAFILE !3
//    #CHECK !3 _TR
//    #CHECK !1 _#LG
//    #CHECK !5 .
//    #CHECK !3.RECNUM _URW#LG
//    #IF (!0>3)
//      #CHECK !4 _DGLOBU#
//      MOVEINT !4 TO FIELDNUMBER
//      !A [] $182 !3.RECNUM !1
//    #ELSE
//      MOVEINT |CI0 TO FIELDNUMBER
//      !A [] $182 !3.RECNUM !1
//    #ENDIF
//  #ELSE
//    #CHECK !3 .
//    DECLARE_DATAFILE !1
//    #CHECK !1.RECNUM _URW#LG
//    #IF (!0>1)
//      #CHECK !2 _FWSNDELG#U
//      !A [] $180 !1.RECNUM !2
//    #ELSE
//      !A [] $180 !1.RECNUM |CI0
//    #ENDIF
//  #ENDIF
//#ENDCOMMAND

#COMMAND OPEN
    API_OPEN !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      CLEAR {logicalName|fileNum}*n
//
//  Description:
//      Clear the current record in the file.
//
//  Parameters:
//      logicalName:
//          The name used to identify the file in a DataFlex program.
//      fileNum:
//          The number used to open the file.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND API_CLEAR RLG#
  VARIABLE_FILE_COMMAND $50e !1
  #IF (!0>1)
    API_CLEAR !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

// see Old_open command for notes on this removal
//#COMMAND OLD_CLEAR CVWR#LGE
//  #IFDEF !1
//    !A [] $C1 !1
//  #ELSE
//    #CHECK !1.RECNUM _CVWLR#GU
//    !A [] $C1 !1.RECNUM
//  #ENDIF
//  #IF !0>1
//    OLD_CLEAR !2 !3 !4 !5 !6 !7 !8 !9
//  #ENDIF
//#ENDCOMMAND

#COMMAND CLEAR
    #IFSAME !1 DF_ALL
        !A [] $52C
    #ELSE
        API_CLEAR !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      NewRecord {logicalName|fileNum}*n
//
//  Description:
//      Sets the record buffer to inactive while retaining all existing data (w/ exception of recnum which is 0ed)
//
//  Parameters:
//      logicalName:
//          The name used to identify the file in a DataFlex program.
//      fileNum:
//          The number used to open the file.
//
// added as of 12.0 - This is the recommended way to "inactivate" a record so it can be saved as a new record.
// if recnum is used, this always moves 0 to recnum.
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND NEWRECORD RLG#
  VARIABLE_FILE_COMMAND $531 !1
  #IF (!0>1)
    NEWRECORD !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND



// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      CLOSE {logicalName|fileNum}*n
//
//  Description:
//      Closes the file.
//
//  Parameters:
//      logicalName:
//          The name used to identify the file in a DataFlex program.
//      fileNum:
//          The number used to open the file.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND API_CLOSE RLG#
  VARIABLE_FILE_COMMAND $50f !1
  #IF (!0>1)
    API_CLOSE !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

// see Old_open command for notes on this removal
//#COMMAND OLD_CLOSE RTE
//  #CHECK !1.RECNUM _CVWLR#GU
//  !A [] $181 !1.RECNUM
//  #IF (!0>1)
//    OLD_CLOSE !2 !3 !4 !5 !6 !7 !8 !9
//  #ENDIF
//#ENDCOMMAND

#COMMAND CLOSE
    #IFSAME !1 DF_ALL
       !A [] $52D !2
    #ELSE
       API_CLOSE !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      GET_FIELD_VALUE fileNum fieldNum "TO" destVariable;
//          {"LENGTH" iLength {"OFFSET" iOffset}}
//
//  Description:
//      Gets the value of a field into the destVariable doing any
//      type conversion necessary.
//
//  Parameters:
//      fileNum:
//          The number used to open the file.
//      fieldNum:
//          The number of the field.
//      destVariable:
//          Where the fields value will be put.
//      iLength:
//          The length of the data to be used. By default, all
//          data (or as much as can be) is written into the field.
//          A length of 0 causes all data to be written.
//      iOffset:
//          The first byte in the field where data will be written, from 0.
//          Default is that data will be written into the field starting at
//          byte 0.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND GET$FIELD$VALUE$HELP RLGU# RLGU# "TO" CRLGU# "LENGTH" RLGU# "OFFSET" RLGU# .
  SET_FILE_FIELD !1 !2
  SET_LENGTH_OFFSET !6 !8
  !A [] $510 !4
#ENDCOMMAND

#COMMAND GET_FIELD_VALUE RLGU# RLGU# "TO" CRLGU#
  #IF (!0=4)
    GET$FIELD$VALUE$HELP !1 !2 !3 !4 LENGTH 0 OFFSET 0
  #ELSE
    #IF (!0=6)
      GET$FIELD$VALUE$HELP !1 !2 !3 !4 !5 !6 OFFSET 0
    #ELSE
      GET$FIELD$VALUE$HELP !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      SET_FIELD_VALUE fileNum fieldNum "TO" newValue;
//          {"LENGTH" iLength {"OFFSET" iOffset {noTruncateFlag}}}
//
//  Description:
//      Sets the value of a field to newValue doing any type conversion
//      necessary.
//
//  Parameters:
//      fileNum:
//          The number used to open the file.
//      fieldNum:
//          The number of the field.
//      newValue:
//          The value to be put into the field.
//      iLength:
//          The length of the data to be used. By default, all
//          data (or as much as can be) is written into the field.
//          A length of 0 causes all data to be written.
//      iOffset:
//          The first byte in the field where data will be written, from 0.
//          Default is that data will be written into the field starting at
//          byte 0.
//      noTruncateFlag:
//          Flag which signifies whether existing data in the field
//          following data that is edited will be truncated or not. By
//          default, all old data following new data written is truncated.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SET$FIELD$VALUE$HELP$2 "LENGTH" RLGU# "OFFSET" RLGU# .
    SET_LENGTH_OFFSET !2 !4
#ENDCOMMAND

#COMMAND SET$FIELD$VALUE$HELP RLGU# RLGU# "TO" RLGU# RLGU# .
  SET_FILE_FIELD !1 !2
  !A [] $511 !4 !5
#ENDCOMMAND

#COMMAND SET_FIELD_VALUE RLGU# RLGU# "TO" RLGU#
  #IF (!0=4)
    SET$FIELD$VALUE$HELP$2 LENGTH 0 OFFSET 0
    SET$FIELD$VALUE$HELP !1 !2 !3 !4 DFFALSE
  #ELSE
    #IF (!0=6)
      SET$FIELD$VALUE$HELP$2 !5 !6 OFFSET 0
      SET$FIELD$VALUE$HELP !1 !2 !3 !4 DFFALSE
    #ELSE
      #IF (!0=8)
        SET$FIELD$VALUE$HELP$2 !5 !6 !7 !8
        SET$FIELD$VALUE$HELP !1 !2 !3 !4 DFFALSE
      #ELSE
        SET$FIELD$VALUE$HELP$2 !5 !6 !7 !8
        SET$FIELD$VALUE$HELP !1 !2 !3 !4 !9
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      SAVERECORD {logicalName|fileNum}*n
//
//  Description:
//      Saves the current record in the specified files.
//
//  Parameters:
//      logicalName:
//          The name used to identify the file in a DataFlex program.
//      fileNum:
//          The number used to open the file.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND API_SAVERECORD RLG#
  VARIABLE_FILE_COMMAND $512 !1
  #IF !0>1
    API_SAVERECORD !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

// see Old_open command for notes on this removal
//#COMMAND OLD_SAVERECORD CVWR#LGE
//  #IFDEF !1
//    !A [] $C2 !1
//  #ELSE
//    #CHECK !1.RECNUM _CVWLR#GU
//    !A [] $C2 !1.RECNUM
//  #ENDIF
//  #IF !0>1
//    OLD_SAVERECORD !2 !3 !4 !5 !6 !7 !8 !9
//  #ENDIF
//#ENDCOMMAND

#COMMAND SAVERECORD
    API_SAVERECORD !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      ATTACH {logicalName|fileNum}*n
//
//  Description:
//      Updates all fields in the current record which relate to another file
//      with the values of those fields in the parent ( or related-to) files.
//
//  Parameters:
//      logicalName:
//          The name used to identify the file in a DataFlex program.
//      fileNum:
//          The number used to open the file.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND API_ATTACH RLG#
    VARIABLE_FILE_COMMAND $513 !1
    #IF !0>1
       API_ATTACH !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
#ENDCOMMAND

// see Old_open command for notes on this removal
//#COMMAND OLD_ATTACH CVWR#LGE
//  #IFDEF !1
//    !A [] $C5 !1
//  #ELSE
//    #CHECK !1.RECNUM _CVWLR#GU
//    !A [] $C5 !1.RECNUM
//  #ENDIF
//  #IF !0>1
//    OLD_ATTACH !2 !3 !4 !5 !6 !7 !8 !9
//  #ENDIF
//#ENDCOMMAND

#COMMAND ATTACH
    API_ATTACH !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      SAVE {logicalName|fileNum}*n
//
//  Description:
//      Save the contents of the currently active record, updating the
//      records with any data in parent files from related fields (as per
//      attach).
//
//  Parameters:
//      logicalName:
//          The name used to identify the file in a DataFlex program.
//      fileNum:
//          The number used to open the file.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND API_SAVE RLG#
  ATTACH !1
  SAVERECORD !1
  #IF (!0>1)
    API_SAVE !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

// see Old_open command for notes on this removal
//#COMMAND OLD_SAVE CVWR#LGE
//  #IFDEF !1
//    !A [] $C5 !1
//    !A [] $C2 !1
//  #ELSE
//    #CHECK !1.RECNUM _CLVWLR#GU
//    !A [] $C5 !1.RECNUM
//    !A [] $C2 !1.RECNUM
//  #ENDIF
//  #IF !0>1
//    OLD_SAVE !2 !3 !4 !5 !6 !7 !8 !9
//  #ENDIF
//#ENDCOMMAND

#COMMAND SAVE
    API_SAVE !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      DELETE {fileNum|logicalName}*n
//
//  Description:
//      Delete the currently active record from the datafile
//
//  Parameters:
//      logicalName:
//          The name used to identify the file in a DataFlex program.
//      fileNum:
//          The number used to open the file.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

// see Old_open command for notes on this removal
//#COMMAND OLD_DELETE CVWR#LGE
//  #IFDEF !1
//    !A [] $C3 !1
//  #ELSE
//    #CHECK !1.RECNUM _CVWLR#GU
//    !A [] $C3 !1.RECNUM
//  #ENDIF
//  #IF !0>1
//    OLD_DELETE !2 !3 !4 !5 !6 !7 !8 !9
//  #ENDIF
//#ENDCOMMAND

#COMMAND API_DELETE RLG#
  VARIABLE_FILE_COMMAND $514 !1
  #IF !0>1
    API_DELETE !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

#COMMAND DELETE
    API_DELETE !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      RELATE {fileNum|logicalName}*n
//
//  Description:
//      Moves all related fields into the parent files and then performs a
//      find in the parents using the main index of the first (or primary)
//      related field for each parent.
//
//  Parameters:
//      logicalName:
//          The name used to identify the file in a DataFlex program.
//      fileNum:
//          The number used to open the file.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

// see Old_open command for notes on this removal
//#COMMAND OLD_RELATE CVWR#LGR
// $c4 is not public anywhere now. It only works with recnum (e.g. |fnXxxx,00). If anyone one is actually using
// $c4 in their code (highly unlikely) this will only work with recnum tables
//  #IFDEF !1
//    !A [] $C4 !1
//  #ELSE
//    #CHECK !1.RECNUM _CVWLR#GU
//    !A [] $C4 !1.RECNUM
//  #ENDIF
//  #IF !0>1
//    OLD_RELATE !2 !3 !4 !5 !6 !7 !8 !9
//  #ENDIF
//#ENDCOMMAND

#COMMAND API_RELATE RLG#
  VARIABLE_FILE_COMMAND $515 !1
  #IF !0>1
    API_RELATE !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

#COMMAND RELATE
    API_RELATE !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      REREAD {fileNum|logicalName}*n
//
//  Description:
//      Locks all files and then re-finds the current record in each file
//      specified as an argument to the command. If no files are specified,
//      then all files are reread.
//
//  Parameters:
//      logicalName:
//          The name used to identify the file in a DataFlex program.
//      fileNum:
//          The number used to open the file.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

// see Old_open command for notes on this removal
//#COMMAND OLD_REFRESH T  // Re-find all files listed by record identity
//  #CHECK !1.RECNUM _RUWG
//  !A [] $C0 !1.RECNUM |CI2         // FIND command
//  !A [FINDERR] $047 |CI25 |CS"!1" // ERROR command
//  #IF !0>1
//    OLD_REFRESH !2 !3 !4 !5 !6 !7 !8 !9
//  #ENDIF
//#ENDCOMMAND

// see Old_open command for notes on this removal
//#COMMAND OLD_REREAD
//  #IF !0=0
//    !A [] $0C9 // REREAD command
//  #ELSE
//    !A [] $0C7 // LOCK command
//    [MULTIUSER] OLD_REFRESH !1 !2 !3 !4 !5 !6 !7 !8 !9
//  #ENDIF
//#ENDCOMMAND

// private. Does a reread for passed file using GetRowId function
#COMMAND VARIABLE_ROWKEY_REFRESH_COMMAND
  // This supports both Indirect_file and Indirect_file.Recnum
  #IFSAME !1.FILE_NUMBER |FS0,0& |FN0,0& |FD0,0& |FS0,0&.RECNUM
      // if someone is doing a Reread and passing indirect_file, then they need to support recnum
      // tables. This technique is not recommended and I doubt if anyone is actually doing this!
      !A [] $CC |CI0 |CI2
  #ELSE
    // the old api_refresh used index_number this so we can safely use this variable (it is not used)
    #IFCLASS !1 SNDIECWVF
        Move (FindByRowId(!1,GetRowId(!1))) to Index_number
    #ELSE
        DECLARE_DATAFILE !1
        Move (FindByRowId(!1.FILE_NUMBER,GetRowId(!1.FILE_NUMBER))) to Index_number
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND API_REFRESH
  #IF (!0>0)
    #CHECK !1 _LG#
    // uses GetRowId function to do the reread
    VARIABLE_ROWKEY_REFRESH_COMMAND !1
    #IFCLASS !1 SNDIECWV
      [FINDERR] ERROR 25 !1
    #ELSE
      [FINDERR] ERROR 25 |CS"!1"
    #ENDIF
    API_REFRESH !2 !3 !4 !5 !6 !7 !8 !9
    // the old api_refresh used index_number and set it to zero. We do this to
    // in the unlikely event that someone is counting on this being zero outside of the command
    MOVE 0 to INDEX_NUMBER
  #ENDIF
#ENDCOMMAND


//#COMMAND API_REFRESH
//  #IF (!0>0)
//    #CHECK !1 _LG#
//    MOVE 0 to INDEX_NUMBER
//    VARIABLE_FILE_COMMAND $CC !1 |CI2
//    #IFCLASS !1 SNDIECWV
//      [FINDERR] ERROR 25 !1
//    #ELSE
//      [FINDERR] ERROR 25 |CS"!1"
//    #ENDIF
//    API_REFRESH !2 !3 !4 !5 !6 !7 !8 !9
//  #ENDIF
//#ENDCOMMAND

#COMMAND API_REREAD
  #IF (!0=0)
    !A [] $0C9 // REREAD ALL
  #ELSE
    !A [] $0C7 // LOCK
    [MULTIUSER] API_REFRESH !1 !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

#COMMAND REREAD
    API_REREAD !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      ZEROFILE {fileNum|logicalName}
//
//  Description:
//      Erases all data within the file.
//
//  Parameters:
//      logicalName:
//          The name used to identify the file in a DataFlex program.
//      fileNum:
//          The number used to open the file.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

// see Old_open command for notes on this removal
//#COMMAND OLD_ZEROFILE $RT .
//  #IFDEF !1.RECNUM
//    #SET Q$ !1.RECNUM
//    !A [] $308 |CI!q
//  #ELSE
//    #CHECK !1 _SG#L
//    !A [] $308 !1
//  #ENDIF
//#ENDCOMMAND

#COMMAND API_ZEROFILE RLG# .
  VARIABLE_FILE_COMMAND $308 !1
#ENDCOMMAND

#COMMAND ZEROFILE
  API_ZEROFILE !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      VCONSTRAIN fileNum RELATES fileNum2
//      VCONSTRAIN fileNum AS boolExpression
//      VCONSTRAIN fileNum fieldNum mode expression
//      VCONSTRAIN fileNum fieldNum mode fileNum2 fieldNum2
//
//  Description:
//      This command allows a variable constraint to be created.
//
//  Parameters:
//      fileNum
//          Num of the file to be constrained
//      fieldNum
//          Num of the field to be constrained
//      boolExpression
//          An expression which is treated as FALSE if it evaluates to zero,
//          TRUE if non-zero
//      expression
//          Any DataFlex expression
//      fileNum2
//          Num of the file to be constrained to
//      fieldNum2
//          Num of the field to be constrained to
//      mode
//          Either the symbols LT, LE, EQ, NE, GT, GE, CONTAINS, and MATCHES,
//          or an expression that corresponds to their symbolic value.
//          MATCHES = 6, CONTAINS = 7.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND CONSTRAIN R
  #IFSAME !2 AS
    #CHECK !3 _CFLVNSWG#
    #CHECK !1.FILE_NUMBER _R#ULWV
    #SET Q$ !1.FILE_NUMBER
    !A [] $DB |CI!q !3        // FILE AS (BOOL-EXP)
  #ELSE
    #IFSAME !2 BETWEEN      // FIELD BETWEEN A AND B
      #CHECK !4 "AND"
      CONSTRAIN !1 GE !3
      CONSTRAIN !1 LE !5
    #ELSE
      #IFSAME !2 RELATES
        #CHECK !3 "TO"
        #IFDEF !1
          #IFDEF !4
            !A [] $D9 !1 !4        // FILE RELATES TO FILE
          #ELSE
            !A [] $D9 !1 !4.FILE_NUMBER // FILE RELATES TO FILE
          #ENDIF
        #ELSE
          #IFDEF !4
            !A [] $D9 !1.FILE_NUMBER !4
          #ELSE
            !A [] $D9 !1.FILE_NUMBER !4.FILE_NUMBER
          #ENDIF
        #ENDIF
      #ELSE
        #CHECK !1 _R#LWVCEBG
        #IF !0>1
          #IFSAME !2 MATCHES
            #SET Q$ 6
          #ELSE
            #IFSAME !2 CONTAINS
              #SET Q$ 7
            #ELSE
              #CHECK !2 _U
              #SET Q$ !2
            #ENDIF
          #ENDIF
          MOVE |CI!q TO INDEX_NUMBER
          #IFCLASS !3 "F"
            !A [] $D2 !1 !3 // FILE MODE FILE
          #ELSE
            !A [] $D1 !1 !3 // FILE MODE VALUE
          #ENDIF
        #ELSE
          #CHECK !1 _CVW#GRE
          !A [] $D3 !1 // FIELD ONLY
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

// Handles comparing file.field to expression|file.field.
#COMMAND VCONSTRAIN_COMPARE #LGUR #LGUR LR #LGUR #LGU .
  !A [] $E7 !1 !2 // Store fileNum fieldNum
  #IFSAME !3 MATCHES CONTAINS $0 $1 $2 $3 $4 $5 $6 $7
    #IFSAME !3 MATCHES
      #SET Q$ 6
    #ELSE
      #IFSAME !3 CONTAINS
        #SET Q$ 7
      #ELSE
        #CHECK !3 _U
        #SET Q$ !3
      #ENDIF
    #ENDIF
    !A [] $E8 |CI!q    // Store comparison mode
  #ELSE
    !A [] $E8 !3    // Store comparison mode
  #ENDIF
  #IF (!0>4)
    !A [] $E9 !4 !5 // fileNum2 fieldNum2
  #ELSE
    !A [] $EA !4    // Expression
  #ENDIF
#ENDCOMMAND

#COMMAND VCONSTRAIN_AS #LGUR "AS" #LGUR .
  !A [] $DB !1 !3
#ENDCOMMAND

#COMMAND VCONSTRAIN_RELATE #LGUR "RELATES" #LGUR .
  !A [] $D9 !1 !3
#ENDCOMMAND

#COMMAND VCONSTRAIN
  #IFSAME !2 RELATES
    VCONSTRAIN_RELATE !1 !2 !3 !4 !5 !6 !7 !8 !9
  #ELSE
    #IFSAME !2 AS
      VCONSTRAIN_AS !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      VCONSTRAIN_COMPARE !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      SORT fileNum {indexNumbers {options {callBackObject}}}
//
//  Description:
//
//  Parameters:
//      logicalName:
//          The name used to identify the file in a DataFlex program.
//      fileNum:
//          The number used to open the file.
//      indexNumbers:
//          Optional string listing all index numbers to sort.
//      callBackObject:
//          An object id which will receive MSG_CALLBACK during the restructure
//          operation. This the first parameter of this message is a string
//          containing progress information.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#COMMAND SORT R#LGU #LGU #LUG #LGU .
    !A [] $519 !3 !4
    !A [] $518 !1 !2
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      OUTPUT_AUX_FILE fileType FOR fileNum {NUMBER logicalNum} {TO optPath}
//
//  Description:
//      Output a database related file.
//
//  Parameters:
//      fileNum:
//          The number used to open the file.
//      logicalNum:
//          The logical number to be used to create the file. Only used if the
//          file to be created is a new file (thus has no set file number).
//      fileType:
//          The type of file to be created, e.g., DF_AUX_FILE_FD or
//          DF_AUX_FILE_DEF.
//      optPath:
//          Optional filename/sequential device where output will be written.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND OUTPUT_AUX_FILE_HELP "NUMBER" L#GU "TO" L#GUIND .
  !A [] $51A !2 !4
#ENDCOMMAND

#COMMAND OUTPUT_AUX_FILE R#LGU "FOR" R#LGU
  #IF (!0>5)
    #IFSAME !6 NUMBER
      OUTPUT_AUX_FILE_HELP !6 !7 !4 !5 !8 !9
    #ELSE
      OUTPUT_AUX_FILE_HELP !4 !5 !6 !7 !8 !9
    #ENDIF
  #ELSE
    #IF (!0>3)
      #IFSAME !4 NUMBER
        OUTPUT_AUX_FILE_HELP !4 !5 TO |CS"" !6 !7 !8 !9
      #ELSE
        #IFSAME !4 TO
           OUTPUT_AUX_FILE_HELP NUMBER |CI0 !4 !5 !6 !7 !8 !9
        #ELSE // Something is wrong, compiler will say what
           OUTPUT_AUX_FILE_HELP !4 !5 !6 !7 !8 !9
        #ENDIF
      #ENDIF
    #ELSE
      OUTPUT_AUX_FILE_HELP NUMBER |CI0 TO |CS""
    #ENDIF
  #ENDIF
  !A [] $51B !1 !3
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      OUTPUT_DEF_FILE fileNum {NUMBER logicalNum} {TO optPath}
//
//  Description:
//      Output a .DEF file.
//
//  Parameters:
//      fileNum:
//          The number used to open the file.
//      logicalNum:
//          The logical number to be used to create the file. Only used if the
//          file to be created is a new file (thus has no set file number).
//      optPath:
//          Optional filename/sequential device where output will be written.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND OUTPUT_DEF_FILE
    OUTPUT_AUX_FILE DF_AUX_FILE_DEF FOR !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      OUTPUT_FD_FILE fileNum {NUMBER logicalNum} {TO optPath}
//
//  Description:
//      Output an FD file.
//
//  Parameters:
//      fileNum:
//          The number used to open the file.
//      logicalNum:
//          The logical number to be used to create the file. Only used if the
//          file to be created is a new file (thus has no set file number).
//      optPath:
//          Optional filename/sequential device where output will be written.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND OUTPUT_FD_FILE
    OUTPUT_AUX_FILE DF_AUX_FILE_FD FOR !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      DELETE_DB fileNumber | logicalNameString {IGNORE_ERRORS}
//
//  Description:
//      Deletes a dGatafile. If IGNORE_ERRORS is passed, all errors
//      are suppressed. This should be used when deleting a file that
//      may or may not exist.
//
//  Parameters:
//      fileNumber:
//          Number of file to delete. File can be open but does not have
//          to be
//      logicalNameString:
//          String containing the logical name of the file to delete.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND DELETE_DB RL#G """IGNORE_ERRORS" .
  #IFSAME !2 IGNORE_ERRORS
    !A [] $0e2 !1 |CI1
  #ELSE
    !A [] $0e2 !1 |CI0
  #ENDIF
#ENDCOMMAND

//-=-=-=-==-==--=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// Command:
//      COPY_RECORDS FileNumber1 TO fileNumber2 {NoOfRecords};
//          {USING indexNum} {CALLBACK callback_id}
//
// Description:
//      Copies NoOfRecords from fileNumber1 to fileNumber2. If USING is not
//      specified, recnum is used otherwise records are copied using the
//      specified indexNum. If CALLBACK is specified, the callback function
//      in the object callback_id is called. FileNumber1 AND FileNumber2
//      should have identical fields.
//
// Parameters:
//      FileNumber1:
//            Number of file FROM where  records are to be copied.
//      FileNumber2:
//            Number of fiel TO which recordsare to be copied.
//      NoOfRecords:
//            Number of records to be copied.
//      indexNum:
//            Index Number. If not specified, files are copied in the order of recnum.
//      callback_id:
//            Object id of the object containing the callback function.
//
//-=-=-=-==-==--=-=-=-=-=--=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND COPY$RECORD$HELP "USING" #RLUG "CALLBACK" #RLUG .
     !A [] $521 !2 !4
#ENDCOMMAND

#COMMAND COPY_RECORDS #RLUG "TO" #RLUG
  #IF (!0 > 3)
    #IFSAME !4 USING CALLBACK
        !A [] $522 |CI0
        #IFSAME !4 USING
            #IF (!0>5)
                COPY$RECORD$HELP !4 !5 !6 !7 !8 !9
            #ELSE
                COPY$RECORD$HELP !4 !5 CALLBACK |CI0 !7 !8 !9
            #ENDIF
        #ELSE
            #IFSAME !4 CALLBACK
                COPY$RECORD$HELP USING |CI0 !4 !5 !6 !7 !8 !9
            #ELSE
                COPY$RECORD$HELP !4 !5 !6 !7 !8 !9
            #ENDIF
        #ENDIF
    #ELSE
        !A [] $522 !4
        #IF (!0>4)
            #IFSAME !5 USING
                #IF (!0>6)
                    COPY$RECORD$HELP !5 !6 !7 !8 !9
                #ELSE
                    COPY$RECORD$HELP !5 !6 CALLBACK |CI0 !7 !8 !9
                #ENDIF
            #ELSE
                #IFSAME !5 CALLBACK
                    COPY$RECORD$HELP USING |CI0 !5 !6 !7 !8 !9
                #ELSE
                    COPY$RECORD$HELP !5 !6 !7 !8 !9
                #ENDIF
            #ENDIF
        #ELSE
            COPY$RECORD$HELP USING |CI0 CALLBACK |CI0
        #ENDIF
    #ENDIF
 #ELSE
    !A [] $522 |CI0
    COPY$RECORD$HELP USING |CI0 CALLBACK |CI0
 #ENDIF
 !A [] $524 !1 !3
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// Command:
//     FIELD_MAP FileNumber <field_name> "TO" FieldNumber
//
// Description:
//     converts <field_name> into field number and puts it in FieldNumber
// Parameters:
//      FileNumber:
//            No of the file containing the fields.
//      field_name:
//            name of the field to be converted into number.
//      FieldNumber:
//            Value returned by FIELD_MAP
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=---=-=-=-=-=-=--=-=-=-=-

#COMMAND FIELD_MAP #RLUG #RLI "TO" #RLUG .
   !A [] $525 !1 !2
   !A [] $526 !4
#ENDCOMMAND


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// Command:
//      LOAD_DRIVER driver_name
//
// Description:
//      Loads a database driver
//
// Parameter:
//      driver_name:
//          Name of the database driver.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND LOAD_DRIVER #RLI .
   !A [] $527  !1
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// Command:
//      UNLOAD_DRIVER driver_name
//
// Description:
//      Loads a database driver
//
// Parameter:
//      driver_name:
//          Name of the database driver.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND UNLOAD_DRIVER #RlI .
   !A [] $528  !1
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      READ_HEX {CHANNEL channelNum} varName {numHexBytes}
//
//  Description:
//      Read a stream of hex bytes from the sequential channel chosen. The
//      stream must be in the form of a string containing two byte printable
//      hex numbers, e.g., "616263" would correspond the the string "abc".
//      The value is converted into ASCII before it is store in varName.
//
//  Parameters:
//      channelNum:
//          The number of the sequential device channel to be read from. If
//          not specified, the currently active input channel is read from.
//      varName:
//          The variable to read the bytes into.
//      numHexBytes:
//          The number of two digit hex codes to read in, e.g., "616263" is
//          3 hex codes (even though it is actually 6 bytes). If ommitted or
//          zero, READ_HEX will read until it encounters the end of the line.
//          If data is read which cannot be converted from hex to ascii,
//          READ_HEX stops at that point.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND READ_HEX
  #IFSAME !1 CHANNEL
    !A [] $10A |CI0 !2
    #IF !0>2
      #CHECK !3 _ULE
      #CHECK !4 _RU
      !A [] $110 !3 !4
    #ENDIF
  #ELSE
    #CHECK !1 _ULEC
    #CHECK !2 _RU
    !A [] $110 !1 !2
  #ENDIF
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      WRITE_HEX {CHANNEL channelNum} {value}*n
//
//  Description:
//      Writes any set of values (expressions, variables, etc.) to the chosen
//      sequential channel in the form of a stream of two digit hex codes,
//      e.g., the string "abc" would be written as "616263".
//
//  Parameters:
//      channelNum:
//          The number of the sequential device channel to be read from. If
//          not specified, the currently active input channel is read from.
//      value:
//          Any variable, expression, etc. to be written out. The value is
//          evaluated and converted to a string before being written, e.g.,
//          a value of (1 + 1) would be converted to the string "2" and
//          then written out as "50" which is the hex code corresponding to
//          the character '2'.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND WRITE$HEX$HELP
  #IF (!0>0)
    !A [] $10F !1
    WRITE$HEX$HELP !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

#COMMAND WRITE_HEX
  #IFSAME !1 CHANNEL
    !A [] $10A |CI1 !2
    #IF !0>2
      WRITE$HEX$HELP !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ELSE
    WRITE$HEX$HELP  !1 !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      GET_CURSOR_VISIBLE
//
//  Description:
//      Returns 0 if the cursor is hidden, non-zero if it is visible. NOTE:
//      this only reflects whether the cursor will be shown during the next
//      user input action, not whether it is currently shown.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND GET_CURSOR_VISIBLE R#LGUC .
    !A [] $154 !1
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      SET_CURSOR_VISIBLE visibleFlag
//
//  Description:
//      Sets the cursor hidden or displayable. NOTE: this only affects
//      whether the cursor will be shown during the next user input action,
//      not whether it is currently shown.
//
//  Parameters:
//      visibleFlag
//          If this value is non-zero, the cursor will be displayed. If zero,
//          the cursor will be hidden.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SET_CURSOR_VISIBLE R#LGU .
    !A [] $155 !1
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 //
//  Command:
//      COMPUTE_SCREEN_CRC {startX startY endX endY "TO"} crcVariable
//
//  Description:
//      Returns a CRC for a region of the screen. This can be used by
//      automated testing programs to verify that the screen has the
//      expected display.
//
//  Parameters:
//      startX, startY, endX, endY
//          Starting and ending coordinates of the region to be CRC'd. If
//          not given, the whole screen is checked.
//      crcVariable
//          A variable which will contain the CRC.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND COMPUTE$CRC$HELP R#LGU R#LGU R#LGU R#LGU "TO" R#LGUC
  !A [] $151 !1 !2
  !A [] $152 !3 !4
  !A [] $153 !6
#ENDCOMMAND

#COMMAND COMPUTE_SCREEN_CRC
  #IFSAME !1 TO
    COMPUTE$CRC$HELP |CI-1 |CI-1 |CI-1 |CI-1 !1 !2 !3 !4 !5 !6 !7 !8 !9
  #ELSE
    COMPUTE$CRC$HELP !1 !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      CALL_DRIVER fileNumber driverName;
//          FUNCTION driverFunction CALLBACK objectID;
//          PASSING aString aString2 aLong RESULT returnValue
//
//   Descrtiption:
//      A function call used directly access driver specific functions.
//
//   Parmeters:
//       fileNumber
//           Number of the file
//       driverName
//           Name of the driver
//       driverFunction
//           Numeric value corresponding to a driver specific function
//       returnValue
//           Value returned by CALL_DRIVER
//       aString
//           A string
//       aString2
//           Another string
//       aLoing
//           A long
//       objectID
//           Object id for an object that will be sent the GET_CALLBACK
//           message
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND CALL$DRIVER$1 #RLUG #RLDNIGU "FUNCTION" #RGUL "CALLBACK" #RGUL .
    !A [] $529 !1 !2
    !A [] $52A !4 !6
#ENDCOMMAND

#COMMAND CALL$DRIVER$2 "PASSING" #CRUG #CRUG #RLUG "RESULT" #RLUG .
    !A [] $530 !4
    !A [] $52B !2 !3
    !A [] $082 STRMARK !6
#ENDCOMMAND

#COMMAND CALL_DRIVER
    CALL$DRIVER$1 !1 !2 !3 !4 !5 !6
    CALL$DRIVER$2 !7 !8 !9
#ENDCOMMAND


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//       LOAD_DEF defName ONTO structureHandle
//
//   Descrtiption:
//       Will load the file definition from defName on top of the structure
//       defined by structureHandle. While the structure may be for an
//       existing file, no structure operations (other than STRUCTURE_START)
//       should be performed on structureHandle prior to calling LOAD_DEF.
//
//   Parmeters:
//       structureHandle
//           Handle to an new or modified structure.
//       defName
//           Name of the sequential device which contains the .DEF
//           specification.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND LOAD_DEF #RLUG "ONTO" #RLUG .
    !A [] $52F !1 !3
#ENDCOMMAND


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//       SET_FILELIST newName
//
//   Descrtiption:
//       Sets the filelist.cfg file to the name specified. If the specified
//       file cannot be opened, the current filelist file remains unchanged.
//
//   Parmeters:
//       newName
//           The name of the file to use as filelist.cfg
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SET_FILELIST RL#UGDNI .
    SET_ATTRIBUTE DF_FILELIST_NAME TO !1
#ENDCOMMAND


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//       GET_FILELIST Name
//
//   Descrtiption:
//       Gets the name of the current filelist file.
//
//   Parmeters:
//       Name
//           The name of the file being used as filelist.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND GET_FILELIST RL#UGDNI .
    GET_ATTRIBUTE DF_FILELIST_NAME TO !1
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      LOGIN ServerName UserName Password {DriverName}
//
//  Description:
//      Login to the specified server using the passed user and password.
//
//  Parameters
//      ServerName
//          Name of the server (driver specific) to be logged into
//
//      UserName
//          Name of the user to be used for the login
//
//      Password
//          Password to use for the login
//
//      DriverName
//          Optional database driver to use for the login. API defaults
//          to attempting a login with all drivers.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND LOGIN #ULGR$ #ULGR$ #ULGR$ #ULG$ .
  !A [] $4c4 !1 !4
  !A [] $4c5 !2 !3
#ENDCOMMAND


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Commands:
//       ENUM_LIST, DEFINE, and END_ENUM_LIST
//
//   Descrtiption:
//       Altogether, these commands can be used to enumerate symbol
//       replacements for lists of symbols.
//
//       DEFINE outside of an ENUM/ENUM_LIST block can be used to define
//       individual symbolic replacements, and to define "flags". (However,
//       there is no UNDEFINE. Sorry.)
//
//   Parmeters:
//       ENUM_LIST and END_ENUM_LIST take no parameters.
//       DEFINE supports several syntaxes:
//
//       DEFINE symbol
//          If outside an enum list, defines a symbolic replacement named
//          symbol as |CI1 (to be used with #IFDEF compiler directive).
//
//       DEFINE symbol1 symbol2 ...
//          If within an enum list, defines a symbolic replacement named
//          symbol1 as a constant integer one greater than the previous
//          symbolic replacement in the enum list (and symbol2 and each
//          additional parameter are defined one greater than the symbol
//          before it).
//
//       DEFINE symbol FOR originalSymbol
//          If outside an enum list, defines a symbolic replacement named
//          symbol for originalSymbol. In this instance, originalSymbol may
//          be any valid symbol name or constant value.
//
//       DEFINE symbol FOR constInt
//          If within an enum list, defines a symbolic replacement named
//          symbol for the constant integer constInt. Only constant integers
//          can be used for constInt with the AS syntax option within enum
//          lists.
//
//  Examples:
//
//  enumeration_list
//      define ddd          // starts at 0 by default
//      define eee          // 1
//      define fff ggg hhh  // 2 3 4
//  end_enumeration_list
//
//  enum_list
//      define rrr for 5     // start at 5
//      define sss          // 6
//      define ttt for 21    // jump to 21
//      define uuu          // 22
//  end_enum_list
//
//  define aaa for ttt       // generic symbolic replacements
//  define aaa for "Hello"
//
//  define zzz              // defines zzz as |CI1 (to be used with #IFDEF)
//
// Note: Defining multiple "flags" (define sss ttt) is not allowed in order
// to allow proper type-checking. (The compiler's preprocessor substitutes
// the symbols too early; therefore, it becomes impossible to differentiate
// the allowable syntaxes if multiple arguments are allowed.)
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND ENUMERATION_LIST .
  #IF (!Zs=1)
    #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT ENUMERATION LISTS CANNOT BE BE NESTED
  #ENDIF
  #SET ZS$ 1 // enum_flag
  #SET ZT$ 0 // initial enum_value
#ENDCOMMAND

// Define with better protections against alias datatype naming
#COMMAND DEFINE R
  #IFSAME !2 FOR
    #IF (!Zs=0)     // if not enum
      #IFDEF !1     // ignore redefinition of symbols (only if not enum)
        // if def'ed it means that !1 is a constant (has already been defined). If we are trying to turn this
        // into a datatype, we know that this is wrong and we should warn the developer. So check if replacement is a variable name.
        // Note in all cases, alias types will get converted to one of these real names.
        #IFSAME !3  STRING  NUMBER  DATE  INTEGER  REAL  BIGINT  BOOLEAN  ADDRESS  TIME  DATETIME  FLOAT  CHAR  UCHAR  SHORT  USHORT  UINTEGER  UBIGINT  CURRENCY  TIMESPAN  DECIMAL  VARIANT
          #ERROR DFERR_COMP_SYMBOL_ALREADY_DEFINED "Attempt to redefine a constant as a data type"
        #ELSE
           // if not a data type, we ignore the redefinition and assume all is OK
        #ENDIF
      #ELSE
        #IFSAME !1 $0     // ignore redefinition if already defined as FALSE
        #ELSE
          #IFSAME !1 $1   // ignore redefinition if already defined as TRUE
          #ELSE
            #IFSAME !1  STRING  NUMBER  DATE  INTEGER  REAL  BIGINT  BOOLEAN  ADDRESS  TIME  DATETIME  FLOAT  CHAR  UCHAR  SHORT  USHORT  UINTEGER  UBIGINT  CURRENCY  TIMESPAN  DECIMAL  VARIANT
              // if here this must be an alias datatype that has already been defined. Either this is a duplicate
              // definition (which we ignore) or a new definition (which is an error)
              #IFSAME !1 !3 // if same ok..redefinition
                // #REM define datatype ok
              #ELSE
                #ERROR DFERR_COMP_SYMBOL_ALREADY_DEFINED "Attempt to redefine a data type"
              #ENDIF
            #ELSE
              #CHECK !4 .
              #IFSAME !1 !3 // ignore self definitions. e.g. define cat for cat
                // #REM define to .self. is dumb but ok
              #ELSE
                #REPLACE !1 !3
              #ENDIF
            #ENDIF
          #ENDIF
        #ENDIF
      #ENDIF
    #ELSE           // else enum
      // check that symbol to be replaced is not a datatype or alias datatype
      #IFSAME !1  STRING  NUMBER  DATE  INTEGER  REAL  BIGINT  BOOLEAN  ADDRESS  TIME  DATETIME  FLOAT  CHAR  UCHAR  SHORT  USHORT  UINTEGER  UBIGINT  CURRENCY  TIMESPAN  DECIMAL  VARIANT
        #ERROR DFERR_COMP_SYMBOL_ALREADY_DEFINED "Attempt to redefine a data type"
      #ELSE
        #IFTYPE !3 "I"
          #IFCLASS !3 "C"
            #CHECK !4 .
            #REPLACE !1 !3
            #SET ZT$ (!3+1)
          #ELSE
            #ERROR DFERR_COMP_CONSTANT_EXPECTED ENUMERATION VALUE MUST BE A CONSTANT
          #ENDIF
        #ELSE
          #ERROR DFERR_COMP_CONSTANT_EXPECTED ENUMERATION VALUE MUST BE A CONSTANT
        #ENDIF
      #ENDIF
    #ENDIF
  #ELSE             // not "FOR"
    // check that symbol to be replaced is not a datatype or alias datatype
    #IFSAME !1  STRING  NUMBER  DATE  INTEGER  REAL  BIGINT  BOOLEAN  ADDRESS  TIME  DATETIME  FLOAT  CHAR  UCHAR  SHORT  USHORT  UINTEGER  UBIGINT  CURRENCY  TIMESPAN  DECIMAL  VARIANT
      #ERROR DFERR_COMP_SYMBOL_ALREADY_DEFINED "Attempt to redefine a data type"
    #ELSE
      #IF (!Zs=0)     // if not enum
        #CHECK !2 .
        #IFDEF !1     // define for |CI1 if they were previously undefined
          #IFSAME !1 |CI1
          #ELSE
            #ERROR DFERR_COMP_SYMBOL_ALREADY_DEFINED "ATTEMPT TO REDEFINE SYMBOL FOR DIFFERENT VALUE"
          #ENDIF
        #ELSE
          #IFSUB '!1'
            #ERROR DFERR_COMP_SYMBOL_ALREADY_DEFINED "ATTEMPT TO REDEFINE SYMBOL FOR DIFFERENT VALUE"
          #ELSE
            #REPLACE !1 |CI1
          #ENDIF
        #ENDIF
      #ELSE
        #REPLACE !1 |CI!Zt
        #SET ZT$ !ZT
        #IF (!0>1)
          DEFINE !2 !3 !4 !5 !6 !7 !8 !9
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND



#COMMAND END_ENUMERATION_LIST .
  #IF (!Zs=0)     // if not enum
    #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT END_ENUMERATION_LIST WITHOUT ENUMERATION_LIST COMMAND
  #ELSE
    #SET ZS$ 0 // reset enum_flag
  #ENDIF
#ENDCOMMAND


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//       ENTRY_NAME_ITEM itemName file.field ...
//
//   Description:
//      Just like Entry_Item except the first parameter is a (global) Item
//      Name.
//
//   Parameters:
//       itemName
//           The (global) name of the item being defined/created.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND ENTRY_NAME_ITEM R R
  #IFDEF !1            // Already exists?
    #IFTYPE !1 "CI"    // If a constant integer
      #IF (!1=!Zg)     // of the correct value...all is well.
      #ELSE            // Else, It is a duplicate item.
        #ERROR DFERR_COMP_SYMBOL_ALREADY_DEFINED DUPLICATE ITEM NAME
      #ENDIF
    #ELSE              // else defined as something else.
      #ERROR DFERR_COMP_SYMBOL_ALREADY_DEFINED NAME ALREADY DEFINED
    #ENDIF
  #ELSE                // this names the item (!Zg is the trick)
    #REPLACE !1 !Zg
  #ENDIF               // now a regular entry_Item
  ENTRY_ITEM !2 !3 !4 !5 !6 !7 !8  !9
#ENDCOMMAND


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//       ON_NAME_ITEM itemName itemValue ...
//
//   Description:
//      Just like On_Item except the first parameter is a (global) Item
//      Name.
//
//   Parameters:
//       itemName
//           The (global) name of the item being defined/created.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND ON_NAME_ITEM R
  #IFDEF !1            // Already exists?
    #IFTYPE !1 "CI"    // If a constant integer
      #IF (!1=!Zg)     // of the correct value...all is well.
      #ELSE            // Else, It is a duplicate item.
        #ERROR DFERR_COMP_SYMBOL_ALREADY_DEFINED DUPLICATE ITEM NAME
      #ENDIF
    #ELSE              // else defined as something else.
      #ERROR DFERR_COMP_SYMBOL_ALREADY_DEFINED NAME ALREADY DEFINED
    #ENDIF
  #ELSE                // this names the item (!Zg is the trick)
    #REPLACE !1 !Zg
  #ENDIF               // now a regular entry_Item
  ON_ITEM !2 !3 !4 !5 !6 !7 !8  !9
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      BEGIN_TRANSACTION
//
//  Description:
//      Starts a transaction on any open files.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND BEGIN_TRANSACTION .
  #SET N$ !N
  #PUSH !R
  #XPUSH !n $INIT  // Init IF/ELSE stack at this nesting level.
  #IFIND //INCLUDE JUMPS IF INDICATORS ON LINE.
    // GOTO BEGIN$TRAN$!r
    !A [] $041 |CI0
    #FREF BEGIN$TRAN$!r !a
    #$ !A 0 0 0 $041 |CL0
    #FREF END$TRAN$!r !a
  #ENDIF
  #$ BEGIN$TRAN$!r:
  #$ BEGIN$!r:
  #$ !A [0 0 0] $0C7 |CI0
  #FREF END$TRAN$!r !a
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      END_TRANSACTION
//
//  Description:
//      Attempts to commit all operations in the current transaction.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND END_TRANSACTION .
  #POP S$
  !A [] $0C8
  #IFDEF WHILE$!s
    !A [] $041 WHILE$!s
  #ENDIF
  END$!s:
  END$TRAN$!s:
  #SET N$ !n-1
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      ABORT_TRANSACTION
//
//  Description:
//      Aborts any currently active transactions, unlocking the files.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND ABORT_TRANSACTION .
  !A [] $0EB
#ENDCOMMAND


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//   Command:
//       SET_RESOURCE_LIBRARY newName
//
//   Description:
//       Tells the program to look in the specified file when opening
//       resources (with the DIRECT_INPUT command). Specifying "" (the empty
//       string) as the newName resets the resource library to look in the
//       currently executing program for resources. The new library must be a
//       properly compiled DataFlex program; all commands and non-resource
//       data in the program/library are ignored. The filename MUST include
//       the extension, but is not required to be .FLX. If the specified
//       file cannot be opened, an error occurs and the current resource
//       library continues to be used.
//
//       Note: Any resources that are currently open when the resource
//       library is changed remain open; i.e. you may continue to read from
//       them. The setting of the resource library only affects the
//       DIRECT_INPUT command when opening resources.
//
//   Parameters:
//       newName
//           The name of the file to use as the library of resources.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SET_RESOURCE_LIBRARY #RLUGOB .
  !A [] $113 !1
#ENDCOMMAND


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      GET_RESOURCE_NAME resourceName|resourceId TO stringVariable
//
//   Description:
//      A command to retrieve the name of a resource at runtime. For the first
//      parameter, you may pass either the resource name (not in quotes) (I
//      know that sounds strange, and you'd probably never do it, but it WILL
//      work) or the integer value of the resource id.
//
//   Parameters:
//       resourceId
//            Integer value of a resource id.
//       stringVariable
//            Variable to return the resource name to.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND GET_RESOURCE_NAME R#LG "TO" RL#OBUGDNI .
  #IFDEF !1
    !A [] $114 !1 !3
  #ELSE
    !A [] $114 !1.RSC !3
  #ENDIF
#ENDCOMMAND


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      ADD value TO variable
//
//   Description:
//      Adds the specified value to the target variable.
//
//   Parameters:
//       value:
//            Any expression
//       variable
//            Any window, variable, etc. that can receive a value
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND ADD R#OBLG "TO" UR#OLGC .
  Move (!3 + !1) to !3
#ENDCOMMAND


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      SUBTRACT value FROM variable
//
//   Description:
//      Subtracts the specified value to the target variable.
//
//   Parameters:
//       value:
//            Any expression
//       variable
//            Any window, variable, etc. that can receive a value
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SUBTRACT R#OBLG "FROM" UR#OLGC .
  Move (!3 - !1) to !3
#ENDCOMMAND


//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      BREAK [BEGIN|END]
//
//   Description:
//      Exit or jump to start of a control loop (WHILE, REPEAT, FOR). Default
//      action is to exit if no argument supplied.
//
//   Parameters:
//      BEGIN:
//          Jump to start of loop.
//      END:
//          Jump to end of loop and exit.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND BREAK "BEGIN""END""" .
  #POP S$
  #PUSH !s
  #IFSAME !1 BEGIN
    Goto BEGIN$!s
  #ELSE
    Goto END$!s
  #ENDIF
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      HARD$EXIT <integer>
//
//  THIS COMMAND IS INTENDED FOR INTERNAL DAC TESTING USE ONLY
//  USE WITHIN AN APPLICATION WILL PROBABLY CAUSE SYSTEM INTEGRITY
//  PROBLEMS!
//
//  This command causes the runtime to do an exit(#) without
//  any internal cleanup.  It is intended for testing server
//  transaction support.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND HARD$EXIT R#LG  .
    !A [] $54 !1
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      netware_get_tts_flag <path name> to <integer boolean>
//
//  THIS COMMAND IS INTENDED FOR INTERNAL DAC TESTING USE ONLY!
//
//  This command returns the state of the TTS flag of a file (by path name),
//  returns false (0) if not a tts volume.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND NETWARE_GET_TTS_FLAG R#LG "TO" RL#OBUGD .
    !A [] $30D !1 !3
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      netware_set_tts_flag <path name> to <integer boolean>
//
//  THIS COMMAND IS INTENDED FOR INTERNAL DAC TESTING USE ONLY!
//
//  This command sets the state of the TTS flag of a file (by path name),
//  returns [FOUND] if status could be set.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND NETWARE_SET_TTS_FLAG R#LG "TO" RL#OBUGD .
    !A [] $30E !1 !3
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      netware_get_available <integer boolean>
//
//  THIS COMMAND IS INTENDED FOR INTERNAL DAC TESTING USE ONLY!
//
//  This command returns non-zero if netware is loaded.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND NETWARE_GET_AVAILABLE RL#OBUGD .
    !A [] $30F !1 |CI0
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      VALID_DRIVE driveLetter retVal
//
//  Description:
//      This command returns non-zero if the drive is a valid drive letter
//      This command is only useful under dos/os2/windows
//
//  Parameters:
//      driveLetter
//             Drive letter to check if valid. Must be a letter.
//      retVal
//             Integer results of command
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND VALID_DRIVE R R
   !A [] $581 !1 !2
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      SET_DIRECTORY directory
//
//  Description:
//      Sets the current directory. The directory argument may contain a drive
//      letter to set the current directory on a particular drive.
//
//  Parameters:
//      directory
//          The new current directory to be set. The directory argument may
//          contain a drive letter to set the current directory on a particular
//          drive.
//
//  NOTE: This command will be removed for final VDF 4.0 release. A new message
//        will be added to provide replacement functionality. KCR
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SET_DIRECTORY R
   !A [] $58C !1
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      FILE_EXIST fileName result
//
//  Description:
//      Returns non-zero if the specified file exists.
//
//  Parameters:
//      fileName
//          The name of the file to check the existance of.
//      result
//          Non-zero if the file exists or zero if does not exist.
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND FILE_EXIST R R
   !A [] $58D !1 !2
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      GET_DIRECTORY {drive} currentDirectory
//
//  Description:
//      Returns the current directory.
//
//  Parameters:
//      {drive}
//          The drive letter to get the current directory for. If drive is
//          not specifed then the current drive is assumed.
//      currentDirectory
//          The current directory for the appropriate drive.
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND GET_DIRECTORY R
    #IF (!0 > 1)
        !A [] $58E !1 !2
    #ELSE
        !A [] $58E |CS"" !1
    #ENDIF
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      MAKE_DIRECTORY directory {permissions}
//
//  Description:
//      Makes a directory on the current drive. Uses the optional permissions
//      value for the directory if it is specified.
//
//  Parameters:
//      directory
//          The name of the new directory to be made.
//      {permissions}
//          The access permissions of the new directory. If this is not
//          specified then the default is DF_FLEX_ALL_RIGHTS.
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND MAKE_DIRECTORY R
    #IF !0 < 2
        !A [] $58F !1 |CI2047
    #ELSE
        !A [] $58F !1 !2
    #ENDIF
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      REMOVE_DIRECTORY directory
//
//  Description:
//      Removes the specified directory.
//
//  Parameters:
//      directory
//          The name of the directory to be removed.
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND REMOVE_DIRECTORY R
   !A [] $590 !1
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      MAKE_TEMP_FILE tempExtension tempFile
//
//  Description:
//      Makes a temporary file with a unique name with the specified extension
//      and returns the unique name that was generated.
//
//  Parameters:
//      tempExtension
//          The extension to use when making the temporary file.
//      tempFile
//          The name of the temporary file that is returned.
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND MAKE_TEMP_FILE R R .
   !A [] $591 !1 !2
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      GET_FILE_MOD_TIME fileName "TO" date {hour} {minute} {second}
//
//  Description:
//      Returns the file modified date/time stamp for the specified file.
//
//  Parameters:
//      fileName
//          The file to get the date/time stamp for.
//      date
//          The date the file was last modifed.
//      {hour}
//          The hour of the day that the file was last modified.
//      {minute}
//          The minute that the file was last modified.
//      {second}
//          The second that the file was last modified.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND GET_FILE_MOD_TIME R "TO" R
    !A [] $592  !1 !3

    #IF !0 > 3
        !A [] $593 !4
    #ENDIF

    #IF !0 > 4
        !A [] $594  !5
    #ENDIF

    #IF !0 > 5
        !A [] $595 !6
    #ENDIF

#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      SET_FILE_MOD_TIME fileName "TO" date {hour} {minute} {second}
//
//  Description:
//      Sets the file modified date/time stamp for the specified file.
//
//  Parameters:
//      fileName
//          The file to set the date/time stamp for.
//      date
//          The new date that the file was modified.
//      {hour}
//          The new hour that the file was modified.
//      {minute}
//          The new minute that the file was modified.
//      {second}
//          The new second that the file was modified.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SET_FILE_MOD_TIME R "TO" R
    !A []   $597 !1 !3  //Date

    #IF (!0 > 3)
        !A [] $598 !4   //Hour
    #ENDIF

    #IF (!0 > 4)
        !A [] $599 !5   //Minutes
    #ENDIF

    #IF (!0 > 5)
        !A [] $59A !6   //Seconds
    #ENDIF

    !A []   $596 !1
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      SET_VIDEO_MODE
//      GET_VIDEO_MODE
//
//  Description:
//      Video Modes for DOS
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=


#COMMAND SET_VIDEO_MODE "TO" _RUSD#
  !A [] $150 !2
#ENDCOMMAND

#COMMAND GET_VIDEO_MODE "TO" _RUSD#
  !A [] $14F !2
#ENDCOMMAND


// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      DEFINE_SYMBOL
//
//  Description:
//      Like #REPLACE except it checks if the symbol exists first.
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND DEFINE_SYMBOL R "FOR" R
  #IFDEF !1
  #ELSE
    #REPLACE !1 !3
  #ENDIF
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      GET_DATE_ATTRIBUTE
//
//  Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND GET_DATE_ATTRIBUTE R "TO" R .
    !A [] $2E1 !1 !3
#ENDCOMMAND

// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      SET_DATE_ATTRIBUTE
//
//  Description:
//
// =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SET_DATE_ATTRIBUTE R "TO" R .
    !A [] $2E2 !1 !3
#ENDCOMMAND

#IFDEF IS$WINDOWS
#ELSE

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//      SET_GROUP_ID groupId
//
//  Description:
//      This command sets the group id to be used.
//
//  Parameters:
//      groupId
//           The group id to set as the current group id
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SET_GROUP_ID R
    !A []   $582    !1
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      SET_USER_ID userId
//
//  Description:
//      This command sets the user id to be used.
//
//  Parameters:
//      userId
//           The user id to set as the current user id
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SET_USER_ID R
    !A []   $583    !1
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      GET_GROUP_ID retVal
//
//  Description:
//      This command returns the current group id.
//
//  Parameters:
//      retVal
//           the value returned is the current user group id
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND GET_GROUP_ID R
    !A []   $584    !1
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      GET_EFFECTIVE_GROUP_ID retVal
//
//  Description:
//      This command returns the current effective group id. This may be
//      different from the actual group id if, say, the user has become
//      superuser under unix.
//
//  Parameters:
//      retVal
//           the value returned is the current effective user group id
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND GET_EFFECTIVE_GROUP_ID R
    !A []   $585    !1
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      GET_USER_ID retVal
//
//  Description:
//      This command returns the current user id.
//
//  Parameters:
//      retVal
//           the value returned is the current user id
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND GET_USER_ID R
    !A []   $586    !1
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      GET_EFFECTIVE_USER_ID retVal
//
//  Description:
//      This command returns the current effective user id. This may be
//      different from the actual user id if, say, the user has become
//      superuser under unix.
//
//  Parameters:
//      retVal
//           the value returned is the current effective user group id
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND GET_EFFECTIVE_USER_ID R
    !A []   $587    !1
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      GET_PERMISSION fileName "TO" retVal
//
//  Description:
//      This command returns the current access privledeges for the specified
//      file
//
//  Parameters:
//      fileName
//          The name of the file to check the permissions for
//      retVal
//          An value containing all the permission bits for the file
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND GET_PERMISSION R "TO" R
    !A []   $588    !1 !3
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      SET_PERMISSION fileName "TO" permissions
//
//  Description:
//      This command sets the access privledeges for the specified file.
//      The various permissions must be and'ed together to form one argument
//
//  Parameters:
//      fileName
//          The name of the file to set the permissions for
//      permissions
//          An value containing all the permission bits for the file and'ed
//          together to form one integer value
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SET_PERMISSION R "TO" R
    !A []   $589    !1 !3
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      ADD_PERMISSION fileName permissions
//
//  Description:
//      This command adds the requested access privledeges for the specified
//      file to the access permissions already set for this file.
//      The various permissions must be and'ed together to form one argument.
//      These permission bits will then be and'ed together with the existing
//      permission bits for the file.
//
//  Parameters:
//      fileName
//          The name of the file to add the permissions for
//      permissions
//          An value containing the permission bits to be changed for the file
//          and'ed together to form one integer value
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND ADD_PERMISSION R R
    !A []   $58A    !1 !2
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      DELETE_PERMISSION fileName permissions
//
//  Description:
//      This command removes the requested access privledeges for the specified
//      file from the access permissions already set for this file.
//      The various permissions must be and'ed together to form one argument
//
//  Parameters:
//      fileName
//          The name of the file to remove the permissions for
//      permissions
//          An value containing the permission bits to be removed for the file
//          and'ed together to form one integer value
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND DELETE_PERMISSION R R
    !A []   $58B    !1 !2
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      SET_FILE_OWNER fileName "TO" owner {group}
//
//  Description:
//      Sets the file owner of the specifed file and optionally sets the
//      group id of the file.
//
//  Parameters:
//      fileName
//          The file to set the owner for.
//      owner
//          The new owner for the file.
//      {group}
//          The new group id for the file.
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND SET_FILE_OWNER R "TO" R
    #IF (!0 > 3)
        !A [] $59D !3 !4
    #ELSE
        !A [] $59D !3  0
    #END

    !A [] $59C !1
#ENDCOMMAND

//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
//  Command:
//
//      GET_FILE_OWNER fileName "TO" owner {group}
//
//  Description:
//      Gets the file owner of the specifed file and optionally gets the
//      group id of the file.
//
//  Parameters:
//      fileName
//          The file to get the owner for.
//      owner
//          The owner of the file.
//      {group}
//          The group id of the file.
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#COMMAND GET_FILE_OWNER R "TO" R
    !A [] $59B !1 !3

    #IF (!0 > 3)
        !A [] $59C !4
    #ENDIF
#ENDCOMMAND

#ENDIF

// JJT-5.1
// Changed commands

#COMMAND COMPILER_DESKTOP_METHOD_WARNINGS "ON""OFF"
  #IFSAME !1 ON
    #SET ZL$ (!Zl | 4) // add bit 3
  #ELSE
    #SET ZL$ (!Zl & 3)  // strip bit 3 - the default fir 8.3, will change in future
    #REM AMBIGUOUS .DESKTOP. METHODS ARE ALLOWED (THIS IS .NOT. RECOMMENDED)
  #ENDIF
#ENDCOMMAND

#COMMAND COMPILER_WARNINGS "ON""OFF""OLD""OLDOFF"
  #IFSAME !1 ON
    #SET ZL$ (!Zl & 6) // strip bit 1
    #REM STRICT COMPILER WARNINGS ON
  #ELSE
    #IFSAME !1 OFF
      #SET ZL$ (!Zl | 1)  // add bit 1
      #REM STRICT COMPILER WARNINGS OFF
    #ELSE
      #IFSAME !1 OLD
        #SET ZL$ (!Zl | 2)  // add bit 2
        #REM OLD STYLE COMPILER CHECKING ON (written to .prn file)
      #ELSE
        #SET ZL$ (!Zl & 5) // strip bit 2
        #REM OLD STYLE COMPILER CHECKING OFF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

// changes: 1. declare an error if not within a procedure or function
//          2. Check for mismatched Begin/End blocks.
//          3. Check for child objects within end_object
//
#COMMAND END_PROCEDURE .
  // This tracks number of nested objects in method.
  // !Zn is the level of !n when the proc/funct started. Upon
  // completion !n should be that value. If not error.
  // If error, compiler stack is messed up
  #IF (!Zn = !n)
  #ELSE
    #ERROR DFERR_COMP_UNRESOVLED_CONTROL_BLOCK Mismatch in Method
    #SET B$ (!b | 4) // stack is screwed up..we have no idea if we are in proc
  #ENDIF

  // When Proc started we set !Zm to 0. It counts nested objects. It
  // should be zero. If not we have an error.
  // If error, compiler stack is messed up
  #IF (!Zm > 0)
    #ERROR DFERR_COMP_MISSING_END_OBJECT Mismatch in Method
    #SET B$ (!b | 4) // stack is screwed up..we have no idea if we are in proc
  #ENDIF

#IFDEF MANGLE_NAMES
  // Let NUM_ARGUMENTS get referenced again in the code, if it has been turned off.
  #ALLOW  NUM_ARGUMENTS
  #UNDEF __@INSIDE_FUNCTION@__     // Leaving function/proc.

#ENDIF

  #IF (!b & 4)              // are we within a Procedure
    #SET B$ (!b & 3)        // reset flag to in_procedure
    #POP U$
    #REPLACE OBJ$!Za$LNUM |CI!Zg     // Update the count in the local cmd.
    //  !A [] OBJ$END$HANDLER |CI0
    !A [] $0455 |CI0
    #REPLACE OBJ$!Za$ENDPROC !a
    #POP U$
    #POP ZG$

    #STKSYM
  #ELSE
    #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT End_Funct/End_proc command .not. within a method
  #ENDIF

#ENDCOMMAND



// changes: 1. declare an error if not within a class
//          2. declare an error if within a procedure/function
//          3. declare an error in object (implies missing end_object)
// Note: it is possible that under advanced usage you might be
//       creating a class in a method. If this is the case you should
//       use base_end_class
#COMMAND END_CLASS .
  #IF (!b & 2)                     // must be within class or an error
    #IF (!b & 4)                   // end-class within procedure is probably wrong
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT CLASS/END_CLASS should .not. be inside a method
    #ELSE
      #IF (!b & 1) // if object must be error. Should be end object
        #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT End_object expected before End_class
      #ENDIF
      BASE_END_CLASS
    #ENDIF
  #ELSE
    #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT End_class without class
  #ENDIF
#ENDCOMMAND

// this is lower level end_class. It doesn't check that the
// command apppears in the "right" spot.
#COMMAND BASE_END_CLASS .
  #SET ZI$ (!Zi+!Zf)             //subobject count = self + superclass
  #REPLACE !$.AGG |CI!Zi         //define subobject count
  !A [] END$CLASS U_!$ |CI!Zi

  #SPOP                 // restore the old class name
  #POP X$               // reset the property index
  #POP ZI$              // reset old sub_object_count
  #POP ZF$              // reset super_class_count
  #POP ZB$              // reset current_dep
  #POP B$               // reset obj_flag
#ENDCOMMAND


// changes: declare an error if not within an object
//          if within a class, this should be inside of a method
#COMMAND END_OBJECT
  #IF (!b & 1)  // if not within an object..error
    // if within a class (2) but not within a procedure (4) we have an error
    // you should not place objects in classes outside of methods
    #IF (!b = 3) // 3 = in class and in object, not in method
      #IF (!Zl & 1)
        #REM WARNING 4391: Object/End_object within class is .NOT. in a method
      #ELSE
        #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Object/End_object within class should be in a method
      #ENDIF
    #ENDIF

    // If within method, we count number of nested objects.
    // If lt 0, declare an error, End_procedure will check for >0
    #IF ( !b & 4 )   // if object within method
      #SET ZM$ !Zm-1 // decrement count
      #IF (!Zm < 0)  // if lt 0, declare error
        #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT End_Object without Object in Method
      #ENDIF
    #ENDIF

    // if here we are within a object.
    // if we are within a class we are also within a procedure

    //
    // The following section was added 01-08-90 by SAL to support inheritable
    // end-instance macros for classes
    //
    #IFSUB '!$$SC'  //if flex-defined class
    #IFSUB '!$$EM'  //if end-instance macro defined for class,
      !$$EM !$ !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      FORWARD_END_CONSTRUCT !$ !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
    #ELSE
      DEFAULT_END_OBJECT  //else use default
    #ENDIF
    #SPOP           //restore old class name
    //
    // end of addition 01-08-90 by SAL
    //
  #ELSE
    #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT End_Object without Object
  #ENDIF
#ENDCOMMAND

// changes: declare an error if not within a procedure or function
//
#COMMAND FUNCTION_RETURN GO .
  #IF (!b & 4)              // are we within a Procedure
    #IF (!0 > 0)
      #IFSAME !1 $0
        // !A [] OBJ$HRET |CI0
        !A [] $0450 |CI0
      #ELSE
        #IFSAME !1 $1
          // !A [] OBJ$HRET |CI1
          !A [] $0450 |CI1
        #ELSE
          #CHECK !1 _U
          // !A [] OBJ$HRET !1
          !A [] $0450 !1
        #ENDIF
      #ENDIF
    #ELSE
      // !A [] OBJ$HRET |CI0
      !A [] $0450 |CI0
    #ENDIF
  #ELSE
    #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Method return .not. within a method
  #ENDIF
#ENDCOMMAND

// change: return can be used in methods or in sub-routines
// perhaps next revision
//#COMMAND RETURN
//  #IF (!b & 4)              // are we within a Procedure/function
//    #IF (!Zl & 2)
//      #REM #ERROR DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE Old Style Usage: Possible gosub return inside of method
//    #ENDIF
//    Procedure_Return !1     // we are returning from a method
//  #ELSE
//    // tells us what we need to fix.
//    #IF (!Zl & 2)
//      #REM #ERROR DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE Old Style Usage: Gosub style/Return s/b Gosub_return
//    #ENDIF
//    #IF (!Zl & 1)             // if relaxed...
//      Gosub_Return !1 !2      // we are doing an old style sub-routine return
//    #ELSE
//      Procedure_Return !1     // we are returning from a method.. will gen an error
//    #ENDIF
//  #ENDIF
//#ENDCOMMAND

// change: if within a method declare an error. Force use of
//         gosub_return. This catches errors where developer types
//         return instead of procedure_return.
//
#COMMAND RETURN
  #IF (!b & 4)                // are we within a Procedure/function
    #IF (!Zl & 1)             // if relaxed...
      #REM WARNING 4388: Old Style Usage: s/b gosub_return
      Gosub_Return !1 !2 !3 !4 !5 !6 !7 !8 !9 // we are doing an old style sub-routine return
    #ELSE
      #ERROR DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE Old Style Usage: s/b gosub_return
    #ENDIF
  #ELSE                       // we are not within method. Normal gosub/return usage
    Gosub_Return !1 !2 !3 !4 !5 !6 !7 !8 !9 // we are doing an old style sub-routine return
  #ENDIF
#ENDCOMMAND

#COMMAND Gosub_Return VFWNDE#G

  #IF !0=0
    !A [] $043 |CL0
  #ELSE
    #IFSAME !1 RETURN GOSUB_RETURN
      #SET Q$ (!a+2)
      !A [] $043 |CL!q // RETURN RETURN
      GOSUB_RETURN !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      #IFDEF !1
        #CHECK !1 _S
        #CHECK !2 .
        !A [] $043 !1
      #ELSE
        !A [] $043 |CL0
        #FREF !1 !a
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND


// if not defined as local make it local if needed
//

#COMMAND INTEGER R
  DEFINE$VARIABLE$HELP Integer !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND STRING R E#L%
  DEFINE$VARIABLE$HELP String !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND DATE R
  DEFINE$VARIABLE$HELP Date !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND NUMBER R
  DEFINE$VARIABLE$HELP Number !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND REAL R
  DEFINE$VARIABLE$HELP Real !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND ADDRESS R
  DEFINE$VARIABLE$HELP Address !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND BIGINT R
  DEFINE$VARIABLE$HELP BIGINT !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

//#COMMAND LOGICAL R
//  DEFINE$VARIABLE$HELP LOGICAL !1 !2 !3 !4 !5 !6 !7 !8 !9
//#ENDCOMMAND

#COMMAND TIME R
  DEFINE$VARIABLE$HELP TIME !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND DATETIME R
  DEFINE$VARIABLE$HELP DATETIME !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND FLOAT R
  DEFINE$VARIABLE$HELP FLOAT !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND CHAR R
  DEFINE$VARIABLE$HELP CHAR !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND UCHAR R
  DEFINE$VARIABLE$HELP UCHAR !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND SHORT R
  DEFINE$VARIABLE$HELP SHORT !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND USHORT R
  DEFINE$VARIABLE$HELP USHORT !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND UINTEGER R
  DEFINE$VARIABLE$HELP UINTEGER !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND BOOLEAN R
  DEFINE$VARIABLE$HELP BOOLEAN !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND UBIGINT R
  DEFINE$VARIABLE$HELP UBIGINT !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND CURRENCY R
  DEFINE$VARIABLE$HELP CURRENCY !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND TIMESPAN R
  DEFINE$VARIABLE$HELP TIMESPAN !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND DECIMAL R
  DEFINE$VARIABLE$HELP DECIMAL !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND VARIANT R
  DEFINE$VARIABLE$HELP VARIANT !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND ROWID R
  DEFINE$VARIABLE$HELP RowID !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND


#COMMAND DEFINE$VARIABLE$HELP
  #IFDEF __@INSIDE_STRUCT@__
    #IFADIM !2
      STRUCT_ARRAY_MEMBER !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      STRUCT_SCALAR_MEMBER  !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ELSE
    #IFDEF  __@INSIDE_FUNCTION@__
      //#IF (!Zl & 2) // warn if old style and odd
      //  #REM #ERROR DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE Old style usage: Possible global variable in method
      //#ENDIF

      // jjt - used to be "& 1" which was wrong. 2 is old style flag, 1 is strict. changed in 9.1
      // I would hope that no-one is using this feature anymore.
      #IF (!Zl & 2) // old style - force to global
        Global_Variable !1 !2 !3 !4 !5 !6 !7 !8 !9
        #REM WARNING: Global Variable defined in method
      #ELSE
        Local !1 !2 !3 !4 !5 !6 !7 !8 !9
      #ENDIF
    #ELSE
      Global_Variable !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF
#ENDCOMMAND

// Change: Check that U_!1 is not yet defined
//         Error if within class
//         Error if within a method
#COMMAND CLASS _RCDNSO "IS" "A""AN" _RDNO //_UGBO#L _UGBO#L _GBO#L .
  #IF (!b & 6)            // if within class or procedure...error
    #IF (!b & 2)          // if within class
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Classes cannot be nested within classes
    #ELSE                 // if within method
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Classes cannot be nested within methods
    #ENDIF
  #ELSE
    #CHECK U_!1 _T                      // does new class exist? If yes error
    #CHECK U_!4 _U                      // does superclass exist? if no error
    #REPLACE !1$SC !4                   //define superclass of new class
    #IFSAME !5 STARTMAC                 //if start macro specified,
      #REPLACE !1$SM !6                 //remember its name
      #IFSAME !7 ENDMAC                 //if end macro specified,
        #REPLACE !1$EM !8               //remember it
        BASE_CREATE_CLASS !1 !2 !3 !4 !9
      #ELSE
        BASE_CREATE_CLASS !1 !2 !3 !4 !7 !8 !9
      #ENDIF
    #ELSE
      #IFSAME !5 ENDMAC                 //no STARTMAC - if ENDMAC specified,
        #REPLACE !1$EM !6               //remember it
        BASE_CREATE_CLASS !1 !2 !3 !4 !7 !8 !9
      #ELSE
        BASE_CREATE_CLASS !1 !2 !3 !4 !5 !6 !7 !8 !9
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

// Change: Clear In object Flag. If a class is created within an object
//         it is not relevant.

#COMMAND BASE_CREATE_CLASS _RCDNSO "IS" "A""AN" _RDNO _UGBO#L _UGBO#L _GBO#L .
  #PUSH !b              // save obj_flag
  #PUSH !Zb             // save current_dep
  #PUSH !Zf             // save the super_class_count
  #SET B$ (!b | 2)      // set flag to in_class
  // we want to strip in in-object flag. This will get restored when
  // the class is ended. When a class is defined it is not relevant if
  // it is in an object or not.
  #SET B$ (!b & 14)     // set flag to not in_class (remove bit 0)
  #SET ZB$ 0                // based on atomic class object
  #IF ( (!b & 1) = 0 )          // are we NOT in a create_object?
    #IFDEF !4.AGG               // bump dep number by already
      #SET ZB$ !4.AGG           // defined sub objects
    #ENDIF
  #ENDIF
  #SET ZF$ !Zb              // save the super_class_count
  #PUSH !Zi             // save current sub object count
  #SET ZI$ 0                // and init for new class

  #PUSH !x                  // save old property index
  #SET X$ 0                 //init to first array index# (0)

  #SPUSH             // save the old class name
  #SET $$ !1                // retain the name of the class
  #IFDEF U_!1               // if the new class id has already
  #ELSE                 // been defined, dont bother
    Global_variable INTEGER U_!1            // else put it into a int of that name
  #ENDIF
  #DATA                 // wind up the stream
  #IFDEF !4
    #DPUSH !4
  #ELSE
    #DPUSH U_!4             // based upon
  #ENDIF
  #IF (!0<5)
    #DPUSH |CI0             // no colors defined, use default
  #ELSE
    #DPUSH !5               // else do what they say
  #ENDIF
  #IF (!0<6)
    #DPUSH |CI0             // no colors defined, use default
  #ELSE
    #DPUSH !6               // else do what they say
  #ENDIF
  #IF (!0=7)                // if parameter used, this will be
    #DPUSH |CS"!7"          // the name of a 'C' function.
  #ELSE
    #DPUSH |CS""            // else inherit one from the parent
  #ENDIF
  !A [] CREATE$CLASS U_!1 |VL       // let 'er rip
#ENDCOMMAND


// changes: 1. Allow New syntax: Property type Name {dflt} public|private is optional
//          2. Check placement as follows:
//             2.1. Must be in class or object
//             2.2. Cannot be in a child object defined by a class
//             2.3. If in class, must be in procedure (constructor)
//             2.4. If in object, must not be in procedure.
//          3. Check for Property Name conflicts (Get_name conflict)
//             3.1. If defined as object access - error
//             3.2. If defined as global method - error
//             3.3. If defined with different param list - error (already does this)


// Changes: 1. No_image is optional if windows (always provided by compiler)
//          2. If within class, s/b within a class (in df$object)
#COMMAND OBJECT R "IS" "A""AN" RVD#I
  #IFDEF IS$WINDOWS
    // If windows we can check for no_image and if it is not presented then
    // we will provide a no_image argument. Therefore you should NEVER need to use
    // No_image with windows.
    #IF (!0<5)                // if no image try to aquire one
      #IFDEF !1.N             // if image exists with object name, use that
         OBJECT !1 !2 !3 !4 !1
      #ELSE
         OBJECT !1 !2 !3 !4 NO_IMAGE // else use no_image
      #ENDIF
    #ELSE
      #IFDEF !5.N                               // if passed a valid image or
         DF$OBJECT !1 !2 !3 !4 !5 !6 !7 !8 !9   // no_image use them. Else add
      #ELSE                                     // the no_image parameter.
        #IFSAME !5 NO_IMAGE
           DF$OBJECT !1 !2 !3 !4 !5 !6 !7 !8 !9
        #ELSE
           DF$OBJECT !1 !2 !3 !4 NO_IMAGE !5 !6 !7 !8 !9
        #ENDIF
      #ENDIF
    #ENDIF
  #ELSE
    // If character mode no_image must be explicitly provided (as it has always been).
    // we cannot use the no_image replacement because it does not work with dynamic
    // visual objects (like edits).
    #IF (!0<5)                // if no image try to aquire one
      DF$OBJECT !1 !2 !3 !4 !1
    #ELSE
      DF$OBJECT !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND DF$OBJECT R "IS" "A""AN" RVD#I

  #IF (!b & 2) // if within a class
    #IF ( (!b & 4)=0 ) // should be within a method
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Objects in classes should be within a method
    #ENDIF
  #ENDIF

  // if we are within a method we will keep track of the number of
  // nested objects. When the method ends we will verify that this is 0.
  // This lets us warn about mismathed object/end-object commands
  #IF ( !b & 4)   // if object within method
    #SET ZM$ !ZM  // increment
  #ENDIF


  #DATA                   // start up the data stream
  #PUSH !Zj               // save the unique object label
  #PUSH !b                // save current definition state

  #IF (!b > 0)            // if not global..we make no guesses about
                          // dependent numbers. Let the runtime assign
                          // dependent order.
  //#IF (!b = 4)          // if in procedure and not class
    #SET ZJ$ 0            // do not inc z
  #ELSE
    #SET ZJ$ !ZB          // assign the next object id
  #ENDIF
  #PUSH !Zb               // save this level on stack
  #IFDEF !4.AGG           // was this a class with sub objects?
    #SET ZB$ !4.AGG       // sub objects will begin at the
  #ELSE                   // next object after superclass
    #SET ZB$ 0            // base classes start at 0
  #ENDIF
  #SET ZI$ !ZI            // count this object at the current level
  #PUSH !Zi               // and push the level
  #IF (!b > 0)            // if (in_object | in_class)
    #IF (!b & 2)          // obj_flag == in_class?
      #IF (!b & 1)        // obj_flag == in_Object?
      #ELSE               // No Name for Subobject in constructor
        // don't define this anymore...
        //#REPLACE !$.!1.OBJ |CI-!Zj  // object_name = -current_object
      #ENDIF
    #ENDIF
    // (LS) removed setting of ZJ; it is NOT being used.
    // (Removed when max lines increased > 32k)
    //      #SET ZJ$ (32766-!a)           // a very unique label for this object
    #DPUSH |CS".!1"           // make name from parent and child
  #ELSE               // global object name
    #DPUSH |CS"!1"            // assign an absolute name to object
  #ENDIF
  #CHECK U_!4 _U          // does class exist?
  #DPUSH U_!4             // define then class the class id
  GET$OBJ$IMAGE !5            // define the objects image
  #IF ((!b & 3) = 2)          // if in_class & !in_object
    // don't assign dep nums anymore
    //#DPUSH !$.!1.OBJ          // pick the assigned dependant number
    // New code just sets 0
    #DPUSH |CI0           // pick the next dependant number
  #ELSE               //
    #IF (!b = 0)          // A global object must assign #
      #IFDEF !1.OBJ           // Is the symbol defined, name_object?
        #DPUSH |CI0           // pick the next dependant number
      #ELSE
        #DPUSH |CI!Zj         // force the dependant number
//        #SET ZJ$ ($1000+!Zj)       // mark as global object
        #SET ZJ$ ($10000000+!Zj)   // using 32-bit ids now
        // as of 8.3 we no longer use dependent lists so we cannot create the ObjName.obj symbol anymore. This method of ussage has
        // been deprecated since early framework days and it is now no longer suppoted. The only way you can use the .obj method is to
        // use name_object, which moves this into a global integer variable. Developers are advised to change the ObjName.obj to
        // (ObjName(desktop)).
        // Also I don't think the above Zj is even needed, but for now they remain.
        //#REPLACE !1.OBJ |CI!Zj        // Assign an ID to this object
      #ENDIF
    #ELSE
      #DPUSH |CI0         // pick the next dependant number
    #ENDIF
  #ENDIF
  REGISTER_OBJECT !1
  #DPUSH GET_!1
  #SET B$ (!b | 1)            // we are in a object definition
  !A [] OBJ$CREATE |VL        // create the object now

  #IFDEF !1.OBJ
    #IFCLASS !1.OBJ V$        // does this object have a global?
      MOVE CURRENT_OBJECT TO !1.OBJ   // Move the object id to its global
    #ENDIF
  #ENDIF

  #SPUSH   //save the old class name
  #SET $$ !4
  #IFSUB '!$$SC' // if flex-defined class
    #IFSUB '!$$SM' // if begin-instance macro exists
      #IFDEF IS$WINDOWS
        // in windows we know that an image is always passed (object creates one if needed)
        // and that images are never used. Therefore replace image argument with 0.
        !$$SM !$ 0 !6 !7 !8 !9
      #ELSE
        // character might be passing an image and it might not. We must pass the value
        !$$SM !$ !5 !6 !7 !8 !9
      #ENDIF
    #ELSE
      FORWARD_BEGIN_CONSTRUCT !$ !5 !6 !7 !8 !9
    #ENDIF
  #ELSE
    ADD$IMAGE$ARGS MSG_CONSTRUCT_OBJECT !5 !6 !7 !8 !9  //else use default
  #ENDIF
#ENDCOMMAND

// Changes:  1. Methods not allowed in class child-objects
//           2. If on desktop and not Global/for..is for cDesktop (changed in 8.3, was Desktop)



#COMMAND GET$SET "GET""SET" RD#OBLG

  #IFSAME !3 OF
//    #IFSAME !5 FILE_FIELD // is the file_field keyword used?
//      #IFCLASS !6 F       // test for file element
//        #PUSH !h
//        #PUSH !g
//        #SET H$ %!6       // get the fieldnumber of parameter
//        #SET G$ !6        // get the filenumber of parameter
//        GET$SET$HELP !1 !2 !3 !4 |CI!g |CI!h !7 !8 !9
//        #POP G$
//        #POP H$
//      #ELSE
//        #ERROR DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT UNKNOWN FILE_FIELD: !6
//      #ENDIF
//    #ELSE
//      #IFSAME !5 FIELD      // is the field keyword used?
//        #IFCLASS !6 F       // test for file element
//          #PUSH !h
//          #SET H$ %!6         // get the fieldnumber of parameter
//          GET$SET$HELP !1 !2 !3 !4 |CI!h !7 !8 !9
//          #POP H$
//        #ELSE
//          #ERROR DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT UNKNOWN FIELD: !6
//        #ENDIF
//      #ELSE
        GET$SET$HELP !1 !2 !3 !4 !5 !6 !7 !8 !9
//      #ENDIF
//    #ENDIF
  #ELSE  // !3 not OF. Provide Object
    GET$SET !1 !2 OF CURRENT_OBJECT !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

#COMMAND GET$SET$HELP "GET""SET" RD#OBLG "OF" RSND#OBLG R

  #IF ( (!Zl & 1)=0)
    #IFCLASS !2 "EFWV"
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Unusual Usage: Variable or Expression used as message
    #ENDIF

    #IF (!b = 2) // within class but not in object or method
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Messages in class should be in method
    #ENDIF
  #ENDIF

  #IFSAME DFLT$!2 __X__ __F__  // is this a item type message?
    #IFSAME !5 ITEM       // is the item keyword used?
      OBJECT$PROPERTIES !1 !2 !4 !6 !7 !8 !9 // pass it on
    #ELSE
      #IFSAME !5 TO       // if no param passed create a default
        #IFSAME DFLT$!2 __F__   // is this a form type message?
          #IF (!Zl & 2)
            // if a Form_ message, and no item was passed before the TO
            // and there are two params after the two this is an old syntax.
            #IF (!0>6)
              // this one must be fixed!
              #ERROR DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE OBSOLETE SYNTAX: GET/SET FORM_XXX TO X Y
              #REM #ERROR DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE OBSOLETE SYNTAX: GET/SET FORM_XXX TO X Y
            #ENDIF
          #ENDIF
          OBJECT$PROPERTIES !1 !2 !4   0 !5 !6 !7 !8 !9  // use 0 as dflt
        #ELSE
          #IF (!Zl & 2)
            // if a item_ message, and no item was passed before the TO
            // it used to replace with current which is now changed to
            // 0. Warn that this might cause a problem in old programs.
            #REM #ERROR DFERR_COMP_OBSOLETE_UNSUPPORTED_FEATURE Old Style Usage: No ITEM keyword. Is replacement for .current. or 0
          #ENDIF
          //OBJECT$PROPERTIES !1 !2 !4 0 !5 !6 !7 !8 !9  // use 0 as dflt
          OBJECT$PROPERTIES !1 !2 !4 -99 !5 !6 !7 !8 !9  // use CURRENT as dflt
        #ENDIF
      #ELSE // params are passed. Just Use them
        OBJECT$PROPERTIES !1 !2 !4 !5 !6 !7 !8 !9 // pass it on
        //#REM ITEM KEYWORD OMITTED. USE !5
      #ENDIF
    #ENDIF
  #ELSE // not Item or Form based
    OBJECT$PROPERTIES !1 !2 !4 !5 !6 !7 !8 !9  // just supply args
  #ENDIF
#ENDCOMMAND


#COMMAND OBJECT$PROPERTIES "GET""SET" RD#OBLG RSND#OBLG R
  #DATA

  #IFDEF !2         // is message in a variable?
    #DPUSH !2           // yes, just push the value
  #ELSE
    #IFDEF !1_!2        // is this message defined?
      #DPUSH !1_!2      // yes, push the definition
    #ELSE
      // If there is no message defined, try matching with mangled symbol.
      #IFSAME !1 GET
        #MANG !1_!2 !4 !5 !6 !7 !8 !9
      #ELSE
        #MING !1_!2 !4 !5 !6 !7 !8 !9
      #ENDIF
      // Push it, if we can, or push a fref to the mangled name.
      // Fwd refs try to match without the syntactic sugar first.
      #IFDEF !?

        // Overloading does not allow File_Field, Field or Item (get only)
        #IFSAME FILE_FIELD !2 !3 !4 !5 !6 !7 !8 !9
          #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION "FILE_FIELD keyword not allowed in Overloaded messages"
        #ELSE
          #IFSAME FIELD !2 !3 !4 !5 !6 !7 !8 !9
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION "FIELD keyword not allowed in Overloaded messages"
          #ELSE
            #IFSAME !1 GET // GET's #mang does not test for ITEM so we disallow it here.
              #IFSAME ITEM !2 !3 !4 !5 !6 !7 !8 !9
                #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION "ITEM keyword not allowed or needed in GET Overloaded messages"
              #ENDIF
            #ENDIF
          #ENDIF
        #ENDIF

        #DPUSH !?
      #ELSE
        #DPUSH |CI0       // forward reference the message
        #FREF !? !a,0      // add the reference to be defined
      #ENDIF
    #ENDIF
  #ENDIF

  #PUSH !Zg
  #SET ZG$ 0

  #PUSH !Zh
  #SET ZH$ 2  // 3 unrestricted params following TO and TO is optional
  #IF (!Zl & 1)
    #SET ZH$ 3  // Its ok...no fancy checking
  #ELSE
    #IFSAME !1 GET
      #SET ZH$ 1  // 1 means 1 param following TO
    #ELSE
      #IFSAME DFLT$2$!2 __2__  // is this a complex set message? (more than 1 param)
      #ELSE
        #IFSAME DFLT$!2 __X__ __F__  // is this a item or form type message?
        //#IFSAME DFLT$!2 __F__  // is this a item or form type message?
          #SET ZH$ 1  // 1 means 1 param following TO
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF

  PROPERTY$HELP !4 !5 !6 !7 !8 !9

  #POP ZH$
  #POP ZG$

  // Precedence of Object ID resolution
  // 1. If variable (hopefully local)
  // 2. if expression
  // 3. If .obj (old style, to be avoided)
  // 4. If object access id

  #IFDEF !3 // if a variable, constant or expression...it's defined
    OBJECT$DEFINE !1 !3
  #ELSE

    // remove object.OBJ check - must explicitly add .obj if you want it
    //#IFDEF !3.OBJ   // old style: If global object or defined w/ .obj (ugh)
    //  OBJECT$DEFINE !1 !3.OBJ
    //#ELSE

      #IFDEF GET_!3 // if defined as a function
        #IF (GET_!3>$40000000) // and an object access method
          // replace simple name with expression syntax
          OBJECT$DEFINE !1 (!3(Current_object))
        #ELSE // if defined as a function but not an access method. This is an error
          #ERROR DFERR_COMP_INVALID_OBJECT_REFERENCE "Already defined as a function"
        #ENDIF
      #ELSE
        // 12.0 change:
        // !3 is not defined but we will pass this on and allow the compiler to attempt to resolve it
        OBJECT$DEFINE !1 (!3(Current_object))

        //// not yet defined. We could either forward ref as object or
        //// declare an error. For now let's just do an error.
        //#ERROR DFERR_COMP_INVALID_OBJECT_REFERENCE Object .not. yet defined
        //// here is how we would forward ref as obj
        ////Register_object !3
        ////!A [] OBJ$!1 (!3(Current_object)) |VL
      #ENDIF

    //#ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND OBJECT$DEFINE R R
   !A [] OBJ$!1 !2 |VL
#ENDCOMMAND

// this forces the param passed to be subsituted for an expression
// you can directly dpush an expression
#COMMAND DPUSH$EXP R .
    #DPUSH !1
#ENDCOMMAND




#COMMAND PROPERTY$HELP
  #IF (!0>0)
    // check that none of the params are indicators. We wrap this in an IFLOGICAL because the # test
    // also fires on other symbols like EQ
    #IFLOGICAL !1
        #CHECK !1 _#
    #ENDIF
    #IFSAME !1 FIELD
      #IFCLASS !2 F         // test for file element
        #PUSH !h
        #SET H$ %!2         // get the fieldnumber of parameter
        PROPERTY$HELP |CI!h !3 !4 !5 !6 !7 !8 !9
        #POP H$
      #ELSE
        #ERROR DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT UNKNOWN FIELD: !2
      #ENDIF
    #ELSE
      #IFSAME !1 FILE_FIELD
        #IFCLASS !2 F         // test for file element
          #PUSH !h
          #PUSH !g
          #SET H$ %!2  // get the fieldnumber of parameter
          #SET G$ !2   // get the filenumber of parameter
          PROPERTY$HELP |CI!g |CI!h !3 !4 !5 !6 !7 !8 !9
          #POP G$
          #POP H$
        #ELSE
          #ERROR DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT UNKNOWN FILE_FIELD: !2
        #ENDIF
      #ELSE

        #IFSAME !1 OF // "of" should have already been processed. This is an error
          #ERROR DFERR_COMP_INVALID_MESSAGE_SYNTAX INVALID USE OF 'OF'
          #SET ZH$ 4 // 4 means error occurred
        #ELSE

          // Check that TO is used properly.
          #IFSAME !1 TO
            #IF (!Zl & 1)
            #ELSE
              #IF (!Zh=3)  // TO already encountered. TOO many Tos
                #ERROR DFERR_COMP_INVALID_MESSAGE_SYNTAX TOO MANY 'TO'
                #SET ZH$ 4 // 4 means error occurred
              #ELSE
                #IF (!0=1) // missing param after to
                  #ERROR DFERR_COMP_INVALID_MESSAGE_SYNTAX NO VALUE FOLLOWING 'TO'
                  #SET ZH$ 4 // 4 means error occurred
                #ELSE
                  #SET ZH$ 3 // Mark as found a to. May get changed if an error
                  #IF (!Zh=1) // A GET or ITEM SET without a TO yet
                    #IF (!0>2)  // too many params after the to
                      #IFSAME !1 FIELD // if FIELD we expect another param
                      #ELSE
                        #IFSAME !1 FILE_FIELD // if FILE_FIELD we expect another param
                        #ELSE
                          #ERROR DFERR_COMP_INVALID_MESSAGE_SYNTAX TOO MANY PARAMS AFTER 'TO'
                          #SET ZH$ 4 // 4 means error occurred
                        #ENDIF
                      #ENDIF
                    #ENDIF
                  #ENDIF
                #ENDIF
              #ENDIF
            #ENDIF
          #ELSE
            #IFSAME !1 ITEM
            #ELSE
              #SET ZG$ !ZG
              #IFDEF !1
                #DPUSH !1
              #ELSE
                #IFCLASS !1 0123456789ABCDEF
                  #DPUSH !1
                #ELSE
                  //#IFDEF MSG_!1
                  //  #DPUSH MSG_!1
                  //#ELSE
                  //  #DPUSH |CI0
                  //  #FREF MSG_!1 !a,!Zg
                  //#ENDIF

                  #IFDEF GET_!1 // if defined as a function
                  // This would support passing of object names as parameters. Not supported
                  // for now.
                    #IF (GET_!1>$40000000) // and an object access method..we will help out
                      // replace simple name with expression syntax
                      DPUSH$EXP (!1(current_object))
                    #ELSE       // if defined as a function but not an access method. This is an error
                      #DPUSH !1 // will generate an Error
                    #ENDIF
                  #ELSE       // If undefined
                    // this could be msg_!1 but we will call than an error
                    //#DPUSH !1 // will generate an Error
                    #IFDEF MSG_!1
                      #DPUSH MSG_!1
                    #ELSE
                      #DPUSH |CI0
                      #FREF MSG_!1 !a,!Zg
                    #ENDIF

                  #ENDIF
                #ENDIF
              #ENDIF
            #ENDIF
          #ENDIF

        #ENDIF
        #IF (!Zh<4) // 4 indicates an error occurred
          PROPERTY$HELP !2 !3 !4 !5 !6 !7 !8 !9 // as long as there is still no error
        #ENDIF
      #ENDIF
    #ENDIF
  #ELSE
    #IF (!Zh<3) // If 1 or 2, TO was never found
      #ERROR DFERR_COMP_INVALID_MESSAGE_SYNTAX MISSING 'TO' KEYWORD
    #ENDIF
  #ENDIF
#ENDCOMMAND

//
////old
//#COMMAND PROPERTY$HELP
//  #IF (!0>0)
//    #IFSAME !1 OF // "of" should have already been processed. This is an error
//      #ERROR DFERR_COMP_INVALID_MESSAGE_SYNTAX INVALID USE OF 'OF'
//      #SET ZH$ 4 // 4 means error occurred
//    #ELSE
//      // Check that TO is used properly.
//      #IFSAME !1 TO
//        #IF (!Zl & 1)
//        #ELSE
//          #IF (!Zh=3)  // TO already encountered. TOO many Tos
//            #ERROR DFERR_COMP_INVALID_MESSAGE_SYNTAX TOO MANY 'TO'
//            #SET ZH$ 4 // 4 means error occurred
//          #ELSE
//            #IF (!0=1) // missing param after to
//              #ERROR DFERR_COMP_INVALID_MESSAGE_SYNTAX NO VALUE FOLLOWING 'TO'
//              #SET ZH$ 4 // 4 means error occurred
//            #ELSE
//              #IF (!Zh=1) // A GET or ITEM SET without a TO yet
//                #IF (!0>2)  // too many params after the to
//                  #ERROR DFERR_COMP_INVALID_MESSAGE_SYNTAX TOO MANY PARAMS AFTER 'TO'
//                  #SET ZH$ 4 // 4 means error occurred
//                #ELSE
//                  #SET ZH$ 3 // Mark as found a to
//                #ENDIF
//              #ELSE        // If here a non-item SET
//                #SET ZH$ 3 // Mark as found a to
//              #ENDIF
//            #ENDIF
//          #ENDIF
//        #ENDIF
//      #ELSE
//        #IFSAME !1 ITEM
//        #ELSE
//          #SET ZG$ !ZG
//          #IFDEF !1
//            #DPUSH !1
//          #ELSE
//            #IFCLASS !1 0123456789ABCDEF
//              #DPUSH !1
//            #ELSE
//              //#IFDEF MSG_!1
//              //  #DPUSH MSG_!1
//              //#ELSE
//              //  #DPUSH |CI0
//              //  #FREF MSG_!1 !a,!Zg
//              //#ENDIF
//
//              #IFDEF GET_!1 // if defined as a function
//              // This would support passing of object names as parameters. Not supported
//              // for now.
//                #IF (GET_!1>$40000000) // and an object access method..we will help out
//                  // replace simple name with expression syntax
//                  DPUSH$EXP (!1(current_object))
//                #ELSE       // if defined as a function but not an access method. This is an error
//                  #DPUSH !1 // will generate an Error
//                #ENDIF
//              #ELSE       // If undefined
//                // this could be msg_!1 but we will call than an error
//                //#DPUSH !1 // will generate an Error
//                #IFDEF MSG_!1
//                  #DPUSH MSG_!1
//                #ELSE
//                  #DPUSH |CI0
//                  #FREF MSG_!1 !a,!Zg
//                #ENDIF
//
//              #ENDIF
//            #ENDIF
//          #ENDIF
//        #ENDIF
//      #ENDIF
//    #ENDIF
//    #IF (!Zh<4) // 4 indicates an error occurred
//      PROPERTY$HELP !2 !3 !4 !5 !6 !7 !8 !9 // as long as there is still no error
//    #ENDIF
//  #ELSE
//    #IF (!Zh<3) // If 1 or 2, TO was never found
//      #ERROR DFERR_COMP_INVALID_MESSAGE_SYNTAX MISSING 'TO' KEYWORD
//    #ENDIF
//  #ENDIF
//#ENDCOMMAND

// Changes: 1. support "OF" as well as "TO". OF is preferred
//          2. Check location of "OF" keyword
//          3. Check for improper message type (expression)
//          4. If sent directly within class (not method)...error
#COMMAND SEND RSD#OBLG

  #IF ( (!Zl & 1)=0)
    // we expect message to be msg_xxx, constant or local var.
    // Actually locals are weird, but much more acceptable
    #IFCLASS !1 "EFWV" // if exp, file, window or global...weird
      #ERROR DFERR_COMP_INVALID_MESSAGE_SYNTAX Unusual Usage: Variable or Expression used as message
    #ENDIF

    #IF (!b = 2) // within class but not in object or method
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Messages in class should be in method
    #ENDIF
  #ENDIF

  #DATA
  #IFDEF !1
    #DPUSH !1
  #ELSE

    #IFNDEF MANGLE_NAMES

      #IFDEF MSG_!1
        #DPUSH MSG_!1
      #ELSE
        #DPUSH |CI0
        #FREF MSG_!1 !a,0
      #ENDIF

    #ELSE

      #IFSAME !2 TO OF
        #IFDEF MSG_!1
          #DPUSH MSG_!1
        #ELSE
          #MANG MSG_!1 !4 !5 !6 !7 !8 !9
          #IFDEF !?
            #IFSAME FILE_FIELD !2 !3 !4 !5 !6 !7 !8 !9
              #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION "FILE_FIELD keyword not allowed in Overloaded messages"
            #ELSE
              #IFSAME FIELD !2 !3 !4 !5 !6 !7 !8 !9
                #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION "FIELD keyword not allowed in Overloaded messages"
              #ENDIF
            #ENDIF
            #DPUSH !?
          #ELSE  // message undefined. push obj function fixup.
            #DPUSH |CI0
            #FREF !? !a,0
          #ENDIF
        #ENDIF
      #ELSE
        #IFDEF MSG_!1
          #DPUSH MSG_!1
        #ELSE
          #MANG MSG_!1 !2 !3 !4 !5 !6 !7 !8 !9
          #IFDEF !?
            #IFSAME FILE_FIELD !2 !3 !4 !5 !6 !7 !8 !9
              #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION "FILE_FIELD keyword not allowed in Overloaded messages"
            #ELSE
              #IFSAME FIELD !2 !3 !4 !5 !6 !7 !8 !9
                #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION "FIELD keyword not allowed in Overloaded messages"
              #ENDIF
            #ENDIF
            #DPUSH !?
          #ELSE
            #DPUSH |CI0   // can't tell if it's object or global. push object.
            #FREF !? !a,0
          #ENDIF
        #ENDIF
      #ENDIF

    #ENDIF  // Name Mangling Case

  #ENDIF
  #IFSAME !2 TO OF // support both OF (suggested) and TO (old)
    SEND$HELP !4 !5 !6 !7 !8 !9
    SEND$CMD TO TO !3
  #ELSE
    SEND$HELP !2 !3 !4 !5 !6 !7 !8 !9
    SEND$CMD TO TO CURRENT_OBJECT
  #ENDIF
#ENDCOMMAND

#COMMAND SEND$CMD
  #IFSAME !1 !2
    #IFDEF !3 // if a variable, constant or expression...it's defined
      OBJECT$SEND$DEFINE !3
    #ELSE
      // remove .obj resolution. must manually add this
      //#IFDEF !3.OBJ   // old style: If global object or defined w/ .obj (ugh)
      //  OBJECT$SEND$DEFINE !3.OBJ
      //#ELSE
        #IFDEF GET_!3 // if defined as a function
          #IF (GET_!3>$40000000) // and an object access method
            // replace simple name with expression syntax
            OBJECT$SEND$DEFINE (!3(Current_object))
          #ELSE // if defined as a function but not an access method. This is an error
             #ERROR DFERR_COMP_INVALID_OBJECT_REFERENCE "Already defined as a function"
          #ENDIF
        #ELSE
          // 12.0 change:
          // !3 is not defined but we will pass this on and allow the compiler to attempt to resolve it
          OBJECT$SEND$DEFINE (!3(Current_object))

          //// not yet defined. We could either forward ref as object or
          //// declare an error. For now let's just do an error.
          //#ERROR DFERR_COMP_INVALID_OBJECT_REFERENCE Object .Not. yet defined
          //// here is how we would forward ref as obj
          ////!A [] OBJ$SEND |CI0 |VL
          ////#FREF (!3(Current_object)) !a
        #ENDIF
      //#ENDIF
    #ENDIF
  #ELSE
    !A [] OBJ$SEND CURRENT_OBJECT |VL
  #ENDIF
#ENDCOMMAND

#COMMAND OBJECT$SEND$DEFINE R
   !A [] OBJ$SEND !1 |VL
#ENDCOMMAND


#COMMAND SEND$HELP
  #IF (!0>0)
    // check that none of the params are indicators. We wrap this in an IFLOGICAL because the # test
    // also fires on other symbols like EQ
    #IFLOGICAL !1
        #CHECK !1 _#
    #ENDIF
    #IFSAME !1 OF TO
      #ERROR DFERR_COMP_INVALID_MESSAGE_SYNTAX INVALID POSITION FOR '!1'
    #ELSE
      #IFSAME !1 FIELD
        #IFCLASS !2 F         // test for file element
          #PUSH !h
          #SET H$ %!2         // get the fieldnumber of parameter
          SEND$HELP |CI!h !3 !4 !5 !6 !7 !8 !9
          #POP H$
        #ELSE
          #ERROR DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT UNKNOWN FIELD: !2
        #ENDIF
      #ELSE
        #IFSAME !1 FILE_FIELD
          #IFCLASS !2 F         // test for file element
            #PUSH !h
            #PUSH !g
            #SET H$ %!2  // get the fieldnumber of parameter
            #SET G$ !2   // get the filenumber of parameter
            SEND$HELP |CI!g |CI!h !3 !4 !5 !6 !7 !8 !9
            #POP G$
            #POP H$
          #ELSE
            #ERROR DFERR_COMP_UNDEFINED_SYMBOL_IN_ARGUMENT UNKNOWN FILE_FIELD: !2
          #ENDIF
        #ELSE
          // As of 10.1 we will support passing of object names as parameters.
          #IFDEF !1   // if value is defined, just use it
            #DPUSH !1
          #ELSE
            #IFCLASS !1 0123456789ABCDEF // this allows one to pass hex constants (e.g. $C003, NOENTER)
              #DPUSH !1
            #ELSE             // not defined, see if this is an object, referecne
              #IFDEF GET_!1   // if defined as a function and is an object access, use it
                #IF (GET_!1>$40000000)
                  DPUSH$EXP (!1(current_object))
                #ELSE
                  #DPUSH !1 // will generate a symbol not defined error
                #ENDIF
              #ELSE
                #DPUSH !1 // will generate a symbol not defined error
              #ENDIF
            #ENDIF
          #ENDIF
          SEND$HELP !2 !3 !4 !5 !6 !7 !8 !9
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

// Create Move command that will move object access methods
// to a var with simple name
#COMMAND MOVE R "TO" R .
  #IFDEF !1 // if Move Var to Var...normal move.
    MoveVar !1 !2 !3
  #ELSE
    #IFDEF GET_!1   // if defined as a function
      #IF (GET_!1>$40000000) // If move Object-access to (var|property)
        MoveObj !1 !2 !3
      #ELSE
        MoveVar !1 !2 !3 // this will generate an error
      #ENDIF
    #ELSE
      MoveVar !1 !2 !3 // will gen an error
    #ENDIF
  #ENDIF
#ENDCOMMAND

//#COMMAND MOVEVAR #L "TO" #GLEURC .
//  #IFCLASS !1 "G"  // MOVE INDICATOR                // 12.0 note: this logic, which has been in fmac forever
//    #CHECK !1 _VWFC                                 // would never work.
//    !A [] $4020 !1 |GB[0] !3 IN$GLALL |3
//  #ELSE
//    // Type independent move as of 2.3
//    !A  [] $086 !1 !3
//  #ENDIF
//#ENDCOMMAND

// changed for 12.0 to support moving indicators

#COMMAND MOVEVAR GL "TO" GLEURC .
  // The ability to move to and from indicators was added to 12.0 along with the #IFLOGICAL compiler command.
  // This allows developers to treat indicators just like booleans removing the need to create
  // indicate and indicator commands. The Move command can now and should be used for all assignments.
  #IFCLASS !1 "G"  // allowing this case through hangs the compiler .. error is reported already above in argument check
  #ELSE
    #IFLOGICAL !1
      #IFLOGICAL !3
        Indicate !3 as [!1]    // Move Indicator to Indicator   becomes: Indicate Indicator as [Indicator]
      #ELSE
        Movevar (!1) to !3     // Move Indicator to Var
      #ENDIF
    #ELSE
      #IFLOGICAL !3
        // if dest is indicator, check source to decide what kind of statement to build
        #IFSAME !1 true false dftrue dffalse
          Indicate !3 !1    // Move true|false to Indicator   becomes: Indicate Indicator true|false
        #ELSE
          #IFCLASS !1 _E
            Indicate !3 as !1 // Move (exp) to Indicator      becomes: Indicate Indicator as (exp)
          #ELSE
            Indicate !3 as (!1)  // Move var to Indicator     becomes: Indicate Indicator as (var)
          #ENDIF
        #ENDIF
      #ELSE
        // if source and dest are both not indicators use the standard Move logic
        //Type independent move as of 2.3
        !A  [] $086 !1 !3
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND


#COMMAND MOVEOBJ #L "TO" #GLEURC .

  #IFDEF GET_!1   // if defined as a function
    #IF (GET_!1>$40000000) // If move Object-access to (var|property)
      MoveVar (!1(Current_object)) to !3
    #ELSE
      #ERROR DFERR_COMP_INVALID_OBJECT_REFERENCE "Already defined as a function"
    #ENDIF
  #ELSE
    #ERROR DFERR_COMP_INVALID_OBJECT_REFERENCE "Object not yet defined"
  #ENDIF

#ENDCOMMAND


// changes: Check that object name is not already a global/class function
//          Add alternate access syntax @Name
//          check that the name is not an internal function
// MG: 7/2/99 No mangling here for object access method, because no parameters.
// If we decide to mangle on return type (not likely) we can change this and
// use MARG.

#COMMAND REGISTER_OBJECT R .
  #IFDEF UI.EXISTS
  #ELSE
    USE UI
  #ENDIF

  // check for following errors
  // 1. name defined as internal function
  // 2. name defined as overloaded function
  // 3. name defined as global function
  // 4. name defined as non-overloaded class function

  #IF ( (!Zl & 1)=0)
    #IFSAME FN$!1  __F__
      #ERROR DFERR_COMP_ILLEGAL_OBJECT_DEFINTION !1 is an internal function name
    #ENDIF
  #ENDIF

  // check if name is already used for overloaded function, if so, error
  #IFDEF GET_!1_OVERLOADED
    #ERROR DFERR_COMP_ILLEGAL_OBJECT_DEFINTION !1 Already defined as a overloaded function
  #ELSE
    // Check that object name is not already a global or class function.
    #IFDEF GET_!1
      #IF (GET_!1<$40000001)
        #IF (GET_!1<0)
          #ERROR DFERR_COMP_ILLEGAL_OBJECT_DEFINTION !1 Already defined as a global function
        #ELSE
          #ERROR DFERR_COMP_ILLEGAL_OBJECT_DEFINTION !1 Already defined as a function/Property
        #ENDIF
      #ENDIF
    #ELSE
      #REPLACE GET_!1 |CI!ZH
      #FREG GET_!1 RETURNS INTEGER
      // register additional object access methods
      // #REPLACE @!1 (!1(current_object))
    #ENDIF // if Get_ defined
  #ENDIF  // if Get_ overloaded

#ENDCOMMAND

// Changes:  Check for Global error (used to check !1)
//           Check for Object access name error
//           Check that the name is not a global name

#COMMAND REGISTER_FUNCTION R
  #IFDEF UI.EXISTS
  #ELSE
    USE UI
  #ENDIF

  #IF ( (!Zl & 1)=0)
    #IFSAME FN$!1  __F__
      #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION !1 is an internal function name
    #ENDIF
  #ENDIF

  #IFSAME RETURNS !2 !3 !4 !5 !6 !7 !8 !9
  #ELSE
    #ERROR DFERR_COMP_INVALID_METHOD_SYNTAX MISSING KEYWORD RETURNS ON FUNCTION DECLARATION
  #ENDIF

  #IFSAME !2 GLOBAL
    #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION GLOBAL FUNCTIONS CANNOT BE REGISTERED
  #ELSE
    // Check if non-mangled symbol is already defined.
    // If it is, it might be an object name...error
    //           also make sure new function is not an overload..error
    #IFDEF GET_!1

      #IF (GET_!1<0)
        #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION !1 is already defined as a global function
      #ENDIF

      #IF (GET_!1>$40000000)
        #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION !1 is already defined as an object
      #ENDIF

      #IFDEF MANGLE_NAMES
        #IFSAME OVERLOADED !2 !3 !4 !5 !6 !7 !8 !9
          #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined As Non-Overloaded
        #ENDIF
      #ENDIF
      // Validate the argument list.
      CHECK$METHOD$ARGUMENT$LIST  !2 !3 !4 !5 !6 !7 !8 !9
      // We will get more chance of matching fixups (and creating fewer errors) if we just register the function anyway.
      // The parameter list could generate the right name and if it does later fixups will resolve correctly without error.
      // It's possible that the list changes the mangled name. If it does, when the function is fixed, fixup errors may
      // appear. They can be fixed then.
      MESSAGE$ADDRESS GET_!1            // Generate the constant for message identifier. Message$Address checks if it already exists.
    #ELSE
      // Verify that the argument list is syntactically correct.
      CHECK$METHOD$ARGUMENT$LIST  !2 !3 !4 !5 !6 !7 !8 !9

      // Create the constant identifier for the message if it's not already defined.
      #IFNDEF MANGLE_NAMES
        MESSAGE$ADDRESS GET_!1
      #ELSE
        #IFSAME OVERLOADED !2 !3 !4 !5 !6 !7 !8 !9
          // we don't support Byref with overloading
          #IFSAME BYREF !2 !3 !4 !5 !6 !7 !8 !9
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION "BYREF not allowed in overloaded methods"
          #ENDIF
          #MARG GET_!1 !2 !3 !4 !5 !6 !7 !8 !9    // Genearte the mangled symbol.
          MESSAGE$ADDRESS !?                      // Generate the message identifer.
          // if this is the first time we've defined this, create overloaded symbol
          #IFNDEF GET_!1_OVERLOADED
            #REPLACE GET_!1_OVERLOADED  |CI1
          #ENDIF
        #ELSE
          // We are defining a non-overload function. Make sure we have not already
          // defined it as overloaded
          #IFDEF GET_!1_OVERLOADED
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION !1 is already defined as an overloaded function
          #ELSE
            MESSAGE$ADDRESS GET_!1
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF

    // Register the function here.
    #IFNDEF MANGLE_NAMES
      #IFSAME !2 FOR
        #FREG GET_!1 !4 !5 !6 !7 !8 !9
      #ELSE
        #FREG GET_!1 !2 !3 !4 !5 !6 !7 !8 !9
      #ENDIF
    #ELSE
      #IFSAME OVERLOADED !2 !3 !4 !5 !6 !7 !8 !9
        #IFSAME !2 FOR
          #FREG !? !4 !5 !6 !7 !8 !9
        #ELSE
          #FREG !? !2 !3 !4 !5 !6 !7 !8 !9
        #ENDIF
      #ELSE
        #IFSAME !2 FOR
          #FREG GET_!1 !4 !5 !6 !7 !8 !9
        #ELSE
          #FREG GET_!1 !2 !3 !4 !5 !6 !7 !8 !9
        #ENDIF
      #ENDIF
    #ENDIF

  #ENDIF   // Not a global

#ENDCOMMAND

// Changes:  Check for Object access name error
#COMMAND FUNCTION R

  #IF ( (!Zl & 1)=0)
    #IFSAME FN$!1  __F__
      #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION !1 is an internal function name
    #ENDIF
  #ENDIF


  #IFDEF MANGLE_NAMES
    #IFDEF GET_!1
      #IF (GET_!1>$40000000)
        #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION !1 is already defined as an object
      #ENDIF
    #ENDIF
    #IFSAME RETURNS !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
       #ERROR DFERR_COMP_INVALID_METHOD_SYNTAX MISSING KEYWORD RETURNS ON FUNCTION DECLARATION
    #ENDIF
    HANDLE$MESSAGE GET !1 !2 !3 !4 !5 !6 !7 !8 !9
  #ELSE
    #IFDEF GET_!1
      #IF (GET_!1>$40000000)
        #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION !1 is already defined as an object
      #ENDIF
    #ENDIF
    HANDLE$MESSAGE GET_!1 !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF

#ENDCOMMAND

// called by Set/Get
// Changes:  1. If in object and msg_consruct_object..error
//           2. Cannot nest methods (already was there)
//           3. Methods not allowed in class child-objects
//           4. If on desktop and not Global/for..is for cDesktop
//

//#IFDEF MANGLE_NAMES
  #COMMAND HANDLE$MESSAGE$HELP RGOBL#
    #IFSAME !1 MSG
      #PREG !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      #FREG !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDCOMMAND
//#ENDIF

#COMMAND HANDLE$MESSAGE RGOBL#

  // support new 8.3 syntax for desktop methods (e.g. procedure Foo DESKTOP .....)
  #IFNDEF MANGLE_NAMES
    #IFSAME !2 DESKTOP
      #IFDEF IS$WINDOWS
        Handle$message$2 !1 For cDesktop !3 !4 !5 !6 !7 !8 !9
      #ELSE
        Handle$message$2 !1 For Desktop !3 !4 !5 !6 !7 !8 !9
      #ENDIF
    #ELSE
        Handle$message$2 !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ELSE
    #IFSAME !3 DESKTOP
      #IFDEF IS$WINDOWS
        Handle$message$2 !1 !2 For cDesktop !4 !5 !6 !7 !8 !9
      #ELSE
        Handle$message$2 !1 !2 For Desktop  !4 !5 !6 !7 !8 !9
      #ENDIF
    #ELSE
        Handle$message$2 !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND HANDLE$MESSAGE$2 RGOBL#

  #IFDEF UI.EXISTS
  #ELSE
    USE UI
  #ENDIF

  // if the publish meta-attribute is set, we want to generate the RegisterInterface command before we do anything in this new method.
  // we will also check as many things as possible to make sure this is a valid place for this. We expect this:
  // 1. to appear in classes and not objects
  // 2. cannot be global, FOR, or desktop
  // 3. cannnot be override

  // If the meta attribute Published is true, we handle special case for webapps.
  // note I am not checking for the Mangle_names ifdef - I just assume it's true (hasn't been unset for many versions).
  #IFMATTR Published true  // This is true if the Published attribute is active and its value is true
    // method must be an object method and not For, global or overloaded
    #IFSAME !3 GLOBAL FOR OVERLOADED // any of these are not allowed. Note that DESKTOP is already converted to For cDesktop at this point
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The Publish meta tag cannot be used with GLOBAL, DESKTOP, FOR, or OVERLOADED methods."
    #ELSE
      #IF (!b = 1)   // the only valid place for this is within a method within an object.
        MESSAGE$ADDRESS !1_!2  // create id symbol for this message. We do this to avoid fowward reference error in registerInterface
        #SPUSH
        #PUBLISH  //  This creates the Send RegisterInterface line and puts the result in !$, based on the original source line which is expected to be something like Function Foo Integer iArg...
        !$        //  This would then actually call Send RegisterInterface
        #REM !$
        #SPOP
       #ELSE
         #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "The Publish meta tag can only be used within methods defined directly inside of objects."
      #ENDIF
    #ENDIF
  #ENDIF



  // procedure construct_object only allowed in class
  #IF (!b & 1) // if in object
    #IFDEF MANGLE_NAMES
      #IFSAME !1 MSG
        #IFSAME !2 CONSTRUCT_OBJECT
          #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Construct_object .not. allowed in objects
        #ENDIF
      #ENDIF
    #ELSE
      #IFSAME !1 MSG_CONSTRUCT_OBJECT
        #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Construct_object .not. allowed in objects
      #ENDIF
    #ENDIF
  #ENDIF

  // not allowed to nest methods
  // Check flag to determine whether we are already in a method.
  #IF (!b & 4)
    #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Procedures and Functions may .not. be nested.
  #ELSE
    // non global methods are not allowed class child-objects

    #IFNDEF MANGLE_NAMES

      #IFSAME !2 GLOBAL
      #ELSE
        #IF ((!b & 3)=3) // if in class object
          #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Methods .not. allowed in class child-objects
        #ENDIF
      #ENDIF

    #ELSE

      #IFSAME !3 GLOBAL
      #ELSE
        #IF ((!b & 3)=3) // if in class object
          #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Methods .not. allowed in class child-objects
        #ENDIF
      #ENDIF

    #ENDIF
  #ENDIF

  // Give error if the stack symbol NUM_ARGUMENTS is defined.
  #CHECK NUM_ARGUMENTS _T

  //
  #SET ZN$ !n     // static nesting level
  #SET ZM$ 0      // # objects in method
  #PUSH !Zg
  #PUSH !Za
  #SET ZA$ !a
  #PUSH !Zu
  #DATA
  #STKSYM                      // forget all old stack symbols
  #SET B$ (!b | 4)             // set flag to in_procedure

  // This was changed to allow us to prohibit arguments with num_arguments inside the scope of a function.
  #REPLACE NUM_ARGUMENTS |SI0  // define the arg count

  #IFDEF MANGLE_NAMES
    #SREP __@INSIDE_FUNCTION@__   |CI1   // lets other commands check that they are inside a function scope.
  #ENDIF

  #IFNDEF MANGLE_NAMES


  #ELSE

  //  This is the mangling code.

    #IFSAME !3 GLOBAL
      #DPUSH |CI0         // No message
      #DPUSH |CI0         // for no class
      // Check if overloaded symbol is already defined.
      #IFSAME OVERLOADED !4 !5 !6 !7 !8 !9
        #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION Global functions/procedures cannot be overloaded
      #ELSE
        #IFDEF !1_!2_OVERLOADED
          #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined As Overloaded
        #ELSE
          #IFDEF !1_!2
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION Global method !1 !2 Already Defined
          #ELSE
            #SET ZG$ (0-!a-2)   // make it negative to distuinguish it
            #REPLACE !1_!2 |CI!Zg
          #ENDIF
        #ENDIF
      #ENDIF
      CHECK$METHOD$ARGUMENT$LIST !4 !5 !6 !7 !8 !9
      #IF (!0>1)          // do we have arguments?
        #SET ZG$ 1        // starting argument number
        DEFINE_ARGUMENTS !4 !5 !6 !7 !8 !9
      #ENDIF

      HANDLE$MESSAGE$HELP !1 !1_!2 !3 !4 !5 !6 !7 !8 !9

    #ELSE  // not global functions

      // make sure message is not already defined as a global
      #IFDEF !1_!2
        #IF (!1_!2<0)  // if defined as a global already, we have an error
          #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION !1 !2 already defined as a Global method
        #ENDIF
      #ENDIF

      // Mangling case & Using FOR
      #IFSAME !3 FOR          // are we explicit about the class?

        #IFSAME OVERLOADED !5 !6 !7 !8 !9
          #IFDEF !1_!2
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined As non-overloaded
          #ELSE
            // we don't support Byref with overloading
            #IFSAME BYREF !5 !6 !7 !8 !9
              #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION "BYREF not allowed in overloaded methods"
            #ENDIF
            // Mangle name of method.
            #MARG !1_!2 !5 !6 !7 !8 !9
            // Also lock name without parameters and sugar.
            #IFNDEF !1_!2_OVERLOADED
              #REPLACE !1_!2_OVERLOADED  |CI1
            #ENDIF
            MESSAGE$ADDRESS !?         // create id symbol for this message
            #DPUSH !?
          #ENDIF
        #ELSE   // FOR class, but not an overloaded function.

          #IFDEF !1_!2_OVERLOADED
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined As Overloaded
          #ELSE
            MESSAGE$ADDRESS  !1_!2  // create id symbol for this message
            #DPUSH !1_!2
          #ENDIF

        #ENDIF

        #IFDEF !4
          #IFSAME !4 DESKTOP
            #IFDEF IS$WINDOWS
              #DPUSH U_cObject  // Message for the desktop class
            #ELSE
              #DPUSH U_DESKTOP  // Message for the desktop class
            #ENDIF
          #ELSE
            #DPUSH !4         // Message for the named class
          #ENDIF
        #ELSE
          #CHECK U_!4 _RSDNU   // Check the class to see if it exists.
          #DPUSH U_!4         // Message for the named class
        #ENDIF

        CHECK$METHOD$ARGUMENT$LIST !5 !6 !7 !8 !9

        #IF (!0>3)
          #SET ZG$ 1                  // starting argument number
          DEFINE_ARGUMENTS !5 !6 !7 !8 !9
        #ENDIF

        #IFSAME OVERLOADED !4 !5 !6 !7 !8 !9              // Non global
          HANDLE$MESSAGE$HELP !1 !? !5 !6 !7 !8 !9
        #ELSE
          HANDLE$MESSAGE$HELP !1 !1_!2 !5 !6 !7 !8 !9
        #ENDIF

      #ELSE // Method is declared in a class or in an object
        #IF (!b & 2)              // obj_flag == in_class?
        #ELSE
          #IF (!b & 1)            // in_object, instance method
            !A [] CLONE$CLASS     // if in object, clone the class
          #ENDIF
        #ENDIF

        #IFSAME OVERLOADED !3 !4 !5 !6 !7 !8 !9
          #IFDEF !1_!2
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined As non-overloaded
          #ELSE
            // we don't support Byref with overloading
            #IFSAME BYREF !3 !4 !5 !6 !7 !8 !9
              #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION "BYREF not allowed in overloaded methods"
            #ENDIF
            #MARG !1_!2 !3 !4 !5 !6 !7 !8 !9
            MESSAGE$ADDRESS !?
            #IFNDEF !1_!2_OVERLOADED
              #REPLACE !1_!2_OVERLOADED  |CI1
            #ENDIF
            #DPUSH !?               // the message
          #ENDIF
        #ELSE
          // a non-overlaoded message
          #IFDEF !1_!2_OVERLOADED
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION This Method Was Previously Defined As Overloaded
          #ELSE
            MESSAGE$ADDRESS  !1_!2  // create id symbol for this message
            #DPUSH !1_!2
          #ENDIF
        #ENDIF

        // push the proper destination for the message
        #IF (!b & 2)             // obj_flag == in_class?
          #DPUSH U_!$            // handle msg for "current class"
        #ELSE
          #IF (!b & 1)           // in_object, instance method
            #DPUSH |CI0          // handle for objects class
          #ELSE                  // Message is out on desktop and not identfied w/ FOR Xxxxx
            #IFDEF IS$WINDOWS      // 8.3: if windows we are going to place this on the cDesktop object
                                   // which will allow all objects to delegate to it, which is probably
                                   // what people expect. Prior to 8.3, it create a "for desktop" so all classes/objects
                                   // immediately understood this. This represents a change in behavior.
              #REM Ambiguous methods on .DESKTOP. are .not. recommended (Obsolete technique)
              // this is not a real error but we can use this to look at ambiguous desktop methods to make make sure
              // that they are being used in the proper 8.3 style. This warning is controlled by the method
              // Compiler_desktop_method_warnings ON|OFF (OFF is default)
              #IF (!Zl & 4)
                 #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION Ambiguous method on .Desktop. Should be "Desktop" or "Global" or moved.
              #ENDIF
              #DPUSH U_cObject     // Message for the desktop (UI_OBJECT) class. Not advised for VDF after 8.2
            #ELSE
              #DPUSH U_DESKTOP     // Message for the desktop (UI_OBJECT) class. Not advised for VDF after 8.2
            #ENDIF
          #ENDIF   // stand alone message that gets defined as U_DESKTOP
        #ENDIF     // end of else of object method
        CHECK$METHOD$ARGUMENT$LIST !3 !4 !5 !6 !7 !8 !9
        #IF (!0>1)                // do we have arguments?
          #SET ZG$ 1                  // starting argument number
          DEFINE_ARGUMENTS !3 !4 !5 !6 !7 !8 !9
        #ENDIF

        #IFSAME OVERLOADED !3 !4 !5 !6 !7 !8 !9
          HANDLE$MESSAGE$HELP !1 !? !3 !4 !5 !6 !7 !8 !9
        #ELSE
          HANDLE$MESSAGE$HELP !1 !1_!2 !3 !4 !5 !6 !7 !8 !9
        #ENDIF

      #ENDIF       // class method
    #ENDIF
  #ENDIF  // mangling case

//  !A [] HANDLE$FOR |CI0 |VL     // handle the message
  !A [] $0454 |CI0 |VL
  #FREF OBJ$!Za$ENDPROC !a      // fref the end procedure line

  #IFDEF MANGLE_NAMES
    // MG added code here to check the parameter count.
    #IFDEF !1_!2_OVERLOADED
       // Check parameter count
      #DATA
      #DPUSH NUM_ARGUMENTS
      #DPUSH |CI!Zg
      #DPUSH !?

      #IFSAME !1 GET
        #DPUSH |CI1
      #ELSE
        #IFSAME !1 MSG
          #DPUSH |CI2
        #ELSE
          #IFSAME !1 SET
            #DPUSH |CI3
          #ENDIF
        #ENDIF
      #ENDIF
      !A [] $0467 |CI0 |VL
      #FORBID  NUM_ARGUMENTS  300 "NUM_ARGUMENTS was used in an overloaded method"
    #ENDIF
  #ENDIF
  #SET ZG$ 0                    // starting argument number for locals

  // JJT - changed in 9.1. This used to occur when the first local was created. Since this is executed at runtime
  // this created a situation where the first local might be in a block that is not executed. When moved to here
  // the local init command is always executed. We still strongly discourage the declartion of variables anywhere
  // accept the top of a method block. This simply fixes and unintended side-effect of our implementation.
  //!A [] LOCAL$ARGUMENT |CI0  // Create the command to save the local count,
  !A [] $0456 |CI0
  #FREF OBJ$!Za$LNUM !a       // and tell flex to update it later.

#ENDCOMMAND

#COMMAND ITEM_LIST .
  #PUSH !Zd
  #SET ZD$ |CI-1         // -1 means in an item list.

  #PUSH !Zg
  #PUSH !Zj
  #SET ZJ$ !a
  #PUSH !Zj
  #SET ZG$ 0              // Set the item counter to zero.  This is used to
                         // count and assign ID's to the items.
  !A [] OBJ$ILIST |CI0   // Create the command to save the item count,
  #FREF OBJ$!Zj$INUM !a    // and tell flex to update it later.
#ENDCOMMAND


#COMMAND END_ITEM_LIST .
  #POP ZJ$
  #REPLACE OBJ$!Zj$INUM |CI!Zg     // Update the count in the ITEM_LIST cmd.
  !A [] OBJ$ENDILIST OBJ$!Zj$INUM         // Tell runtime this is the end of list.
  #POP ZJ$
  #POP ZG$
  #POP ZD$    // Restore "in item list" marker
#ENDCOMMAND

#COMMAND ENTRY_ITEM R
  #IF (!Zd = -1) // if within a On_item group
    ENTRY$ITEM !1 !2 !3 !4 !5 !6 !7 !8 !9
  #ELSE
    #IF (!0>1)
      ENTRY$ITEM !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      #IFCLASS !1 "F"
        #PUSH !h
        #PUSH !g
        #SET H$ %!1  // get the fieldnumber of parameter
        #SET G$ !1   // get the filenumber of parameter
        Send Bind_Data |CI!g |CI!h
        #POP G$
        #POP H$
      #ELSE
        ENTRY$ITEM !1 !2 !3 !4 !5 !6 !7 !8 !9
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND ENTRY$ITEM R
  #SET ZG$ !ZG
  #DATA
  #IFCLASS !1 "EC"
    #ENTOPT {$C0A0=!1,$C002,$C003,!2}
  #ELSE
    #ENTOPT {$C0A0=!1,!2}
  #ENDIF
  !A [] OBJ$ENTRY$ITEM |CI0 |VL
#ENDCOMMAND

#COMMAND REPLACE_CLASS_NAME R R
   #IFDEF U_!2
       #Replace U_!1 U_!2
       #IFSUB '!2$SC'
          #Replace !1$SC !2$SC
       #ENDIF
       #IFSUB '!2$SM'
          #Replace !1$SM !2$SM
       #ENDIF
       #IFSUB '!2$EM'
          #Replace !1$EM !2$EM
       #ENDIF
   #ENDIF
#ENDCOMMAND

#COMMAND ON_KEY RULGBO#SDN "SEND" RLGBO#SDN """TO""OF""PRIVATE" _DNOB """PRIVATE" .
  #IFSAME !4 PRIVATE
    ON_KEY !1 !2 !3 TO |CI-1 PRIVATE
  #ELSE
    #DATA
    #DPUSH !1
    #IFSAME !4 TO OF
      #IFDEF !5
        #DPUSH !5
      #ELSE
        //#IFDEF !5.OBJ
        //  #DPUSH !5.OBJ
        //#ELSE
        //  #DPUSH |CI0
        //  #FREF !5.OBJ !a,1
        //#ENDIF
        #IFDEF GET_!5 // if defined as a function
          #IF (GET_!5>$40000000) // and an object access method..we will help out
            // replace simple name with expression syntax
            DPUSH$EXP (!5(current_object))
          #ELSE       // if defined as a function but not an access method. This is an error
            #DPUSH !5 // will generate an Error
          #ENDIF
        #ELSE       // If undefined
          // 12.0 change. If not defined, this will get pushed as an object expression
          // allowing one to not have to use register_object if the object is defined later
          // in the file.
          DPUSH$EXP (!5(current_object))
          //#DPUSH !5 // will generate an Error
        #ENDIF
      #ENDIF
    #ELSE
      #DPUSH |CI-1
    #ENDIF
    #IFSAME !6 PRIVATE
      #DPUSH |CI1
    #ENDIF
    #IFDEF !3
      !A [] OBJ$ONKEY !3 |VL
    #ELSE
      #IFDEF MSG_!3
        !A [] OBJ$ONKEY MSG_!3 |VL
      #ELSE             // else the command is defined in flex code
        !A [] OBJ$ONKEY |CI0 |VL        // get flex to fix the fwd ref
        #FREF MSG_!3 !a
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND ON_ITEM NDI """SEND""BEGIN_PULL_DOWN"
  #IF (!0<2)
    #IF (!0<1)
      ON_ITEM '' SEND MSG_NONE
    #ELSE
      ON_ITEM !1 SEND MSG_NONE
    #ENDIF
  #ELSE
    #IFSAME !1 SEND
      ON_ITEM '' !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      #IFSAME !2 SEND
        #SET ZG$ !ZG                   // Increment the item counter
        #IFSAME !4 TO OF
          #CHECK !6 .
          #DATA
          #IFDEF !3
            #DPUSH !3           // Push the (variable) message
          #ELSE
            #IFDEF MSG_!3
              #DPUSH MSG_!3     // Push the constant message
            #ELSE
              #DPUSH |CI0
              #FREF MSG_!3 !a,0     // Forward fef the message
            #ENDIF
          #ENDIF
          #IFDEF !5
            #DPUSH !5           // Push the (expression, var) dest object
          #ELSE
            //#IFDEF !5.OBJ
            //  #DPUSH !5.OBJ     // Push the global object
            //#ELSE
            //  #DPUSH |CI0
            //  #FREF !5.OBJ !a,1     // Forward ref the object
            //#ENDIF

            #IFDEF GET_!5 // if defined as a function
              #IF (GET_!5>$40000000) // and an object access method..we will help out
                // this is where we can get tricky and use access methods
                DPUSH$EXP (!5(current_object))
              #ELSE       // if defined as a function but not an access method. This is an error
                #DPUSH !5 // will generate an Error
              #ENDIF
            #ELSE  // If object name not defined (this is a new block for 12.0)
              // 12.0 change. If not defined, this will get pushed as an object expression
              // allowing one to not have to use register_object if the object is defined later
              // in the file.
              DPUSH$EXP (!5(current_object))
            #ENDIF
          #ENDIF

          !A [] OBJ$ITEM_EXEC !1 |VL

        #ELSE
          #IF (!0 > 3)
            #CHECK !4 "TO"
          #ENDIF
          #IFDEF MSG_!3
            !A [] OBJ$ITEM MSG_!3 !1       // Create the item passing name and value.
          #ELSE
            #IFDEF !3
              !A [] OBJ$ITEM !3 !1         // Create the item passing name and value.
            #ELSE
              !A [] OBJ$ITEM |CI0 !1       // Create the item passing name and value.
              #FREF MSG_!3 !a              // fix value later with procedure address
            #ENDIF
          #ENDIF
        #ENDIF
      #ELSE
        #IFSAME !2 BEGIN_PULL_DOWN
          #CHECK !3 _R
          REGISTER_OBJECT !3
          ON_ITEM !1 SEND ACTIVATE_PULL_DOWN TO (!3(CURRENT_OBJECT))
          #IFSUB 'END_MENU'
            CREATE_MENU !3 SUB_LOCATION !4 !5 !6 !7 !8 !9
          #ELSE
            #ERROR DFERR_COMP_INVALID_ARGUMENT "BEGIN_PULL_DOWN" REQUIRES MENU_SYSTEM PACKAGE
          #ENDIF
        #ENDIF
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

//****************************************************************************//
//                                                                            //
// Returns the field number of a fieldnumber passed.                          //
//                                                                            //
// USAGE:                                                                     //
// GET_FIELDNUMBER FlexErrs.Note to MyVar                                     //
//                                                                            //
//****************************************************************************//

#COMMAND GET_FIELDNUMBER R "TO" R .
  #PUSH !g
  #SET G$ %!1
  Move |CI!g to !3
  #POP G$
#ENDCOMMAND



//****************************************************************************//
//                                                                            //
// Returns the file number of a fieldnumber passed.                           //
//                                                                            //
// USAGE:                                                                     //
// GET_FILENUMBER FlexErrs.Note to MyVar                                      //
//                                                                            //
//****************************************************************************//

#COMMAND GET_FILENUMBER R "TO" R .
  #PUSH !g
  #SET G$ !1
  Move |CI!g to !3
  #POP G$
#ENDCOMMAND

// Private command to start event loop for web applications (added in vdf9.1)
//
#COMMAND START_WEBAPP .
  !A [] $468
#ENDCOMMAND

// Used by Web-services to properly convert data-types
// for XML/web services

// Convert from XML to VDF:
//    ConvertFromXml eType sData to sData
//
#COMMAND ConvertFromXML R R "TO" R
    #DATA
    #DPUSH !1
    #DPUSH !2
    #DPUSH !4
    !A [] $2ED |CI0 |VL
#ENDCOMMAND

// Convert to XML from VDF:
//    ConvertToXml eType sData to sData
//
#COMMAND ConvertToXML R R "TO" R
    #DATA
    #DPUSH !1
    #DPUSH !2
    #DPUSH !4
    !A [] $2EE |CI0 |VL
#ENDCOMMAND

// Used in 11.0 to handle structs/arrays in client web-services. Reads and writes from a ValueTree to the variable.
// The type of variable is determined by the variable type you use. Value tree is:
//            Struct tValueTree
//                String       sValue        // data value. Value only exists if there are no children
//                tValueTree[] children      // child values. If a struct or array, we have children and no value
//            End_Struct
//

#COMMAND ValueTreeSerializeParameter R "TO" R
    !A [] $2ef !1 !3
#ENDCOMMAND

#COMMAND ValueTreeDeserializeParameter R "TO" R
    !A [] $2f0 !1 !3
#ENDCOMMAND



// sets !q to num of dimensions. !q must be initialized before this is called
#COMMAND ARRAY_DIM_COUNT_HELPER R
  #IFADIM !1
    #SET Q$ !Q
    ARRAY_DIM_COUNT_HELPER !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

// dpushes the size of each dimension
#COMMAND ARRAY_DIM_SIZE_HELPER R
  #IFADIM !1
    #SPUSH
    #DIMSTRIP !1
    #DPUSH !$
    #SPOP
    ARRAY_DIM_SIZE_HELPER !2 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

#COMMAND ARRAY_LOCAL_VARIABLE_REPLACE_HELPER R
  #IFADIM !1
    ARRAY_LOCAL_VARIABLE_REPLACE_HELPER !2 !3 !4 !5 !6 !7 !8 !9
  #ELSE
    #IFSAME !$ K
      #REPLACE !1 |SA!ZG!$!qV!h
    #ELSE
      #REPLACE !1 |SA!ZG!$!q
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND ARRAY_GLOBAL_VARIABLE_REPLACE_HELPER R
  #IFADIM !1
    ARRAY_GLOBAL_VARIABLE_REPLACE_HELPER !2 !3 !4 !5 !6 !7 !8 !9
  #ELSE
    #IFSAME !$ K
      #REPLACE !1 |VA!v!$!qV!h
    #ELSE
      #REPLACE !1 |VA!v!$!q
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND ARRAY_ARGUMENT_REPLACE_HELPER R
  #IFADIM !1 // first skip past all []s
    ARRAY_ARGUMENT_REPLACE_HELPER !2 !3 !4 !5 !6  !7 !8 !9
  #ELSE
    // start of line is now either "BYREF VarName" or "varName"
    #IFSAME !1 BYREF
      #IFSAME !$ K
        #REPLACE !2 |RA-!ZG!$!qV!h
      #ELSE
        #REPLACE !2 |RA-!ZG!$!q
      #ENDIF
    #ELSE
      #IFSAME !$ K
        #REPLACE !1 |SA-!ZG!$!qV!h
      #ELSE
        #REPLACE !1 |SA-!ZG!$!q
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND ARRAY_INIT_HELPER R
  #IFADIM !1
    ARRAY_INIT_HELPER !2 !3 !4 !5 !6 !7 !8 !9
  #ELSE
    !A [] $088 !1 |VL
  #ENDIF
#ENDCOMMAND

#COMMAND LOCAL$ARRAY T R R
  #DATA
  #SET Q$ 0
  ARRAY_DIM_COUNT_HELPER !2 !3 !4 !5 !6 !7 !8 !9 // sets !q to num of dims
  #PUSH !q     // we need this a bit later
  #DPUSH |CI!q //Push the number of dimensions

  #PUSH !g
  #DTYPE G$ !1
  #IF (!g=19)
    #PUSH !h
    #STRG H$ !1
    #SPUSH
    #DTSYM !1  // moves datatype Letter ID into !$
    ARRAY_LOCAL_VARIABLE_REPLACE_HELPER !2 !3 !4 !5 !6 !7 !8 !9
    #SPOP
    #DPUSH |CI19
    #DPUSH |CI!h
    #POP H$
  #ELSE
    #PUSH !g
    #SPUSH
    #DTSYM !1 // moves datatype Letter ID into !$
    ARRAY_LOCAL_VARIABLE_REPLACE_HELPER !2 !3 !4 !5 !6 !7 !8 !9
    #SPOP
    #POP G$
    #DPUSH |CI!g //Push the element type
  #ENDIF
  #POP G$

  ARRAY_DIM_SIZE_HELPER !2 !3 !4 !5 !6 !7 !8 !9 //Push the size of each dimension
  ARRAY_INIT_HELPER !2 !3 !4 !5 !6 !7 !8 !9

  // at the moment only support multiple array variables with single dimension arrays
  // e.g. "integer[] i1 i2" is allowed, "integer[][] i1 i2" is not allowed.
  // this limit was created because it will be very difficult to make fmac do this and this should be a rare occurance.
  #POP Q$ // number of dimensions
  #IF (!q>1) // if more than one dimension
    #IF (!0>(!q+2)) // num of params must be num of dimensions plus 2
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT 'Multi Dimensional array variables must be defined one per line'
    #ENDIF
  #ELSE
    #IF (!0>3)
      LOCAL$ARRAY !1 !2 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF

#ENDCOMMAND

#COMMAND GLOBAL$ARRAY T R R
  #DATA

  #SET Q$ 0
  ARRAY_DIM_COUNT_HELPER !2 !3 !4 !5 !6 !7 !8 !9 // sets !q to num of dims
  #PUSH !q     // we need this a bit later
  ARRAY_DIM_SIZE_HELPER !2 !3 !4 !5 !6 !7 !8 !9 //Push the size of each dimension

  #PUSH !g
  #DTYPE G$ !1
  #IF (!g=19)
    #PUSH !h
    #STRG H$ !1
    #DPUSH |CI!h
    #DPUSH |CI19
    #DPUSH |CI!q //Push the number of dimensions
    #ARRV V$
    #SPUSH
    #DTSYM !1  // moves datatype Letter ID into !$
    ARRAY_GLOBAL_VARIABLE_REPLACE_HELPER !2 !3 !4 !5 !6 !7 !8 !9
    #SPOP
    #POP H$
  #ELSE
    #DPUSH |CI!g //Push the element type
    #DPUSH |CI!q //Push the number of dimensions
    #ARRV V$
    #SPUSH
    #DTSYM !1  // moves datatype Letter ID into !$
    ARRAY_GLOBAL_VARIABLE_REPLACE_HELPER !2 !3 !4 !5 !6 !7 !8 !9
    #SPOP
  #ENDIF
  #POP G$

  // at the moment only support multiple array variables with single dimension arrays
  // e.g. "integer[] i1 i2" is allowed, "integer[][] i1 i2" is not allowed.
  // this limit was created because it will be very difficult to make fmac do this and this should be a rare occurance.
  #POP Q$ // number of dimensions
  #IF (!q>1) // if more than one dimension
    #IF (!0>(!q+2)) // num of params must be num of dimensions plus 2
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT 'Multi Dimensional array variables must be defined one per line'
    #ENDIF
  #ELSE
    #IF (!0>3)
      Global$Array !1 !2 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF

#ENDCOMMAND

#COMMAND DEFINE_SCALAR_ARGUMENT
  #PUSH !q
  #DTYPE Q$ !1
  #IF (!q=-1) // undefined type error
      #ERROR DFERR_COMP_INVALID_DATATYPE (!1)
  #ELSE
    #IF (!q=19) // a struct
      #PUSH !h
      #STRG H$ !1
      #IFSAME !2 BYREF
        #REPLACE !3 |RK-!ZGV!h
      #ELSE
        #REPLACE !2 |SK-!ZGV!h
      #ENDIF
      #POP H$
    #ELSE // not a struct
      #SPUSH
      #DTSYM !1  // moves datatype Letter ID into !$
      #IFSAME !2 BYREF
        #REPLACE !3 |R!$-!ZG
      #ELSE
        #REPLACE !2 |S!$-!ZG
      #ENDIF
      #SPOP
    #ENDIF
  #ENDIF
  #POP Q$
#ENDCOMMAND

#COMMAND DEFINE_ARRAY_ARGUMENT T R R
  #SET Q$ 0
  ARRAY_DIM_COUNT_HELPER !2 !3 !4 !5 !6 !7 !8 !9 // sets !q to num of dims

  #PUSH !g
  #DTYPE G$ !1
  #IF (!g=-1) // undefined type error
      #ERROR DFERR_COMP_INVALID_DATATYPE (!1)
  #ELSE
    #IF (!g=19)
      #PUSH !h
      #STRG H$ !1
      #SPUSH
      #DTSYM !1  // moves datatype Letter ID into !$
      ARRAY_ARGUMENT_REPLACE_HELPER !2 !3 !4 !5 !6 !7 !8 !9
      #SPOP
      #POP H$
    #ELSE
      #SPUSH
      #DTSYM !1  // moves datatype Letter ID into !$
      ARRAY_ARGUMENT_REPLACE_HELPER !2 !3 !4 !5 !6 !7 !8 !9
      #SPOP
    #ENDIF
  #ENDIF
  #POP G$
#ENDCOMMAND

#COMMAND DEFINE_ARGUMENTS
  #IF (!0>0)
    #IFSAME !1 OVERLOADED
      DEFINE_ARGUMENTS !2 !3 !4 !5 !6 !7 !8 !9
    #ElSE
      #IFSAME !1 RETURNS
      #ELSE
        #IFADIM !2
          DEFINE_ARRAY_ARGUMENT !1 !2 !3 !4 !5 !6 !7 !8 !9
        #ELSE
          DEFINE_SCALAR_ARGUMENT !1 !2 !3 !4 !5 !6 !7 !8 !9
        #ENDIF
        DEFINE_NEXT_ARGUMENT !2 !3 !4 !5 !6 !7 !8 !9
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

// get next argument. Skip past all []s and the BYREF symbol
#COMMAND DEFINE_NEXT_ARGUMENT
  #IF (!0>0)
    #IFADIM !1
      DEFINE_NEXT_ARGUMENT !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      #IFSAME !1 BYREF
        DEFINE_ARGUMENTS !3 !4 !5 !6 !7 !8 !9
      #ELSE
        DEFINE_ARGUMENTS !2 !3 !4 !5 !6 !7 !8 !9
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND


#COMMAND SCALAR$PROPERTY R R
  #IFSAME !3 PRIVATE
    PROPERTY !1 !$.!2 PUBLIC !4
  #ELSE
    #IFSAME !3 PUBLIC

      // Check property for proper placement
      // 1. Must be in class or object
      // 2. Cannot be in a child object defined by a class
      // 3. If in class, must be in procedure (constructor)
      // 4. If in object, must not be in procedure.

      #IF ((!Zl & 1) = 0)
        #IF (!b & 3 ) // Within class or object? It should be
          #IF ((!b & 3)=3 ) // but not both....Error
            #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Property cannot be defined in an object within a class
          #ELSE
            #IF (!b & 2)        // in-class: Must be within a method (constructor)
              #IF ( (!b & 4)=0) // in-class and not in method...bad
                #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Class Property must be defined within a constructor procedure
              #ENDIF
            #ELSE // in-object: Cannot be in method
              #IF (!b & 4)  // if within object and within method...an error
                #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Object Property cannot be in a method
              #ENDIF
            #ENDIF
          #ENDIF
        #ELSE
          #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Property can only be defined within a class or object
        #ENDIF
      #ENDIF

      #IF (!b & 1 ) // if within object
        !A [] CLONE$CLASS     // Create a new class
      #ENDIF

      #IF ( (!Zl & 1)=0)
        #IFSAME FN$!2  __F__
          #ERROR DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION !2 is an internal function name
        #ENDIF
      #ENDIF

      // Check for GET_ name conflicts as follows:
      //  1. If defined as an overloaded message - error
      //  2. If defined as object access - error
      //  3. If defined as global method - error

      #IFDEF GET_!2_OVERLOADED
        #ERROR DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION This GET Method Was Previously Defined As Overloaded
      #ELSE
        #IFDEF GET_!2
          #IF (GET_!2>$40000000)
            #ERROR DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION GET !2 is already defined as an object name
          #ELSE
            #IF (GET_!2<0)
              #ERROR DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION GET !2 is already defined as a global function
            #ENDIF // note else condition...defined as proeprty or class function...this is ok
          #ENDIF
        #ELSE
          MESSAGE$ADDRESS GET_!2
        #ENDIF
      #ENDIF

      #DATA           // Start the property

      #DPUSH GET_!2       // Push the get property id
      #FREG GET_!2 RETURNS !1

      // Make sure Set message not defined as overloaded or global
      #IFDEF SET_!2_OVERLOADED
        #ERROR DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION This SET Method Was Previously Defined As Overloaded
      #ELSE
        #IFDEF SET_!2
          #IF (SET_!2<0)
            #ERROR DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION SET !2 is already defined as a global message
          #ENDIF
        #ELSE
           MESSAGE$ADDRESS SET_!2
        #ENDIF
      #ENDIF

      #DPUSH SET_!2       // Push the set property id
      #PREG SET_!2 !1
      #DTYPE Q$ !1        // get the property type in q
      #DPUSH |CI!q        // push the type
      #IF (!q=19)
        //It's a struct, so we must push the struct metadata as well
        #PUSH !h
        #STRG H$ !1
        #DPUSH |CI!h
        #POP H$
      #ENDIF
      #IF (!0 > 3)
        #DPUSH !4
      //#ELSE                // 10/30/1997: If no default param is passed force
        //SF - This has been moved to the runtime now
        //SF - We may want to change this logic and not provide a default value at all.
        //The runtime can easily be changed to handle this better.
        //#IFSAME !1 ROWID
        //  //Do nothing, RowID should not have a default value
        //  //i.e. there are no constant RowIDs, and string to RowID conversion is illegal
        //#ELSE
        //  #IFSAME !1 STRING DATETIME TIME TIMESPAN  // a default value. String types require
        //    #DPUSH |CS''     // a string, all others are numeric. This
        //  #ELSE              // fixes a problem in the runtime where
        //    #DPUSH |CI0      // dates and numbers did not initialize properly
        //  #ENDIF             // when no initial param was passed in the command
        //#ENDIF
      #ENDIF
      !A [] CREATE$PROPERTY |CI0 |VL
    #ELSE
      // this supports syntax of "property Integer Prop 10"
      PROPERTY !1 !2 PUBLIC !3
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND ARRAY_PROPERTY_NAME_HELPER2 R R
  // Check property for proper placement
  // 1. Must be in class or object
  // 2. Cannot be in a child object defined by a class
  // 3. If in class, must be in procedure (constructor)
  // 4. If in object, must not be in procedure.

  #IF ((!Zl & 1) = 0)
    #IF (!b & 3 ) // Within class or object? It should be
      #IF ((!b & 3)=3 ) // but not both....Error
        #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Property cannot be defined in an object within a class
      #ELSE
        #IF (!b & 2)        // in-class: Must be within a method (constructor)
          #IF ( (!b & 4)=0) // in-class and not in method...bad
            #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Class Property must be defined within a constructor procedure
          #ENDIF
        #ELSE // in-object: Cannot be in method
          #IF (!b & 4)  // if within object and within method...an error
            #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Object Property cannot be in a method
          #ENDIF
        #ENDIF
      #ENDIF
    #ELSE
      #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT Property can only be defined within a class or object
    #ENDIF
  #ENDIF

  #IF (!b & 1 ) // if within object
    !A [] CLONE$CLASS     // Create a new class
  #ENDIF

  #IF ( (!Zl & 1)=0)
    #IFSAME FN$!2  __F__
      #ERROR DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION !2 is an internal function name
    #ENDIF
  #ENDIF

  // Check for GET_ name conflicts as follows:
  //  1. If defined as an overloaded message - error
  //  2. If defined as object access - error
  //  3. If defined as global method - error

  #IFDEF GET_!2_OVERLOADED
    #ERROR DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION This GET Method Was Previously Defined As Overloaded
  #ELSE
    #IFDEF GET_!2
      #IF (GET_!2>$40000000)
        #ERROR DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION GET !2 is already defined as an object name
      #ELSE
        #IF (GET_!2<0)
          #ERROR DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION GET !2 is already defined as a global function
        #ENDIF // note else condition...defined as proeprty or class function...this is ok
      #ENDIF
    #ELSE
      MESSAGE$ADDRESS GET_!2
    #ENDIF
  #ENDIF

  #DPUSH GET_!2       // Push the get property id

  #FREG GET_!2 RETURNS !1 |GB[] //Make it array type by appending [], the number of dimensions are not used here

  // Make sure Set message not defined as overloaded or global
  #IFDEF SET_!2_OVERLOADED
    #ERROR DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION This SET Method Was Previously Defined As Overloaded
  #ELSE
    #IFDEF SET_!2
      #IF (SET_!2<0)
        #ERROR DFERR_COMP_ILLEGAL_PROPERTY_DEFINTION SET !2 is already defined as a global message
      #ENDIF
    #ELSE
       MESSAGE$ADDRESS SET_!2
    #ENDIF
  #ENDIF

  #DPUSH SET_!2       // Push the set property id
  #PREG SET_!2 !1 |GB[] //Make it array type by appending [], the number of dimensions are not used here
#ENDCOMMAND


#COMMAND ARRAY_PROPERTY_NAME_HELPER R R
  #IFADIM !2
    ARRAY_PROPERTY_NAME_HELPER !1 !3 !4 !5 !6 !7 !8 !9
  #ELSE
    #IFSAME !3 PRIVATE
      ARRAY_PROPERTY_NAME_HELPER !1 !$.!2 PUBLIC !4 !5 !6 !7 !8 !9
    #ELSE
      #IFSAME !3 PUBLIC
        ARRAY_PROPERTY_NAME_HELPER2 !1 !2 !3 !4 !5 !6 !7 !8 !9
      #ELSE
        ARRAY_PROPERTY_NAME_HELPER !1 !2 PUBLIC !3 !4 !5 !6 !7 !8 !9
      #ENDIF
    #ENDIF
  #ENDIF
#ENDCOMMAND

#COMMAND ARRAY$PROPERTY R R
  #DATA           // Start the property

  //Push the get and set messages
  ARRAY_PROPERTY_NAME_HELPER !1 !2 !3 !4 !5 !6 !7 !8 !9

  #DPUSH |CI21        // Push ARGARRAY
  #SET Q$ 0
  ARRAY_DIM_COUNT_HELPER !2 !3 !4 !5 !6 !7 !8 !9 // sets !q to num of dims
  #DPUSH |CI!q //Push the number of dimensions

  #DTYPE Q$ !1        // get the property type in q
  #DPUSH |CI!q        // Push the array type
  #IF (!q=19)
    //It's a struct, so we must push the struct metadata as well
    #PUSH !h
    #STRG H$ !1
    #DPUSH |CI!h
    #POP H$
  #ENDIF
  ARRAY_DIM_SIZE_HELPER !2 !3 !4 !5 !6 !7 !8 !9 //Push the size of each dimension
  !A [] CREATE$PROPERTY |CI0 |VL
#ENDCOMMAND

#COMMAND PROPERTY R R
  #PUSH !q
  #DTYPE Q$ !1        // get the property type in q
  #IF (!q=-1) // undefined type error
     #ERROR DFERR_COMP_INVALID_DATATYPE (!1)
  #ELSE
    #IFADIM !2
      ARRAY$PROPERTY !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      SCALAR$PROPERTY  !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
  #ENDIF
  #POP Q$
#ENDCOMMAND

// note that this command also creates a symbol _struct_XYZ where XYZ is the struct name. This can
// be used with #ifdef to see if a struct is defined
#COMMAND STRUCT R
  #IFDEF __@INSIDE_STRUCT@__
    #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "STRUCT command within a STRUCT. Structs cannot be Nested"
  #ELSE
    #STRU !1
    #SREP __@INSIDE_STRUCT@__   |CI1   // lets other commands check that they are inside a struct scope.
  #ENDIF
#ENDCOMMAND

#COMMAND END_STRUCT
  #IFNDEF __@INSIDE_STRUCT@__
    #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT "END_STRUCT command without STRUCT"
  #ELSE
    #STRE
    #UNDEF __@INSIDE_STRUCT@__ // Leaving struct declaration
  #ENDIF
#ENDCOMMAND

#COMMAND STRUCT_SCALAR_MEMBER R R
  #PUSH !q
  #DTYPE Q$ !1        // get the property type in q
  #IF (!q =-1)
    #ERROR DFERR_COMP_INVALID_DATATYPE (!1)
  #ELSE
    #IF (!q=19)
      #PUSH !h
      #STRG H$ !1
      #STRM STRUCT |CI!h !2
      #POP H$
    #ELSE
      #STRM SCALAR |CI!q !2
    #ENDIF
  #ENDIF
  #POP Q$
#ENDCOMMAND

#COMMAND STRUCT_ARRAY_TYPE_HELPER R
  #PUSH !q
  #DTYPE Q$ !1        // get the property type in q
  #IF (!q =-1)
    #ERROR DFERR_COMP_INVALID_DATATYPE (!1)
  #ELSE
    #IF (!q=19)
      #PUSH !h
      #STRG H$ !1
      #DPUSH |CI!h
      #DPUSH |CI19
      #POP H$
    #ELSE
      #DPUSH |CI!q
    #ENDIF
  #ENDIF
  #POP Q$
#ENDCOMMAND

#COMMAND STRUCT_ARRAY_MEMBER_HELPER R
  #IFADIM !1
    STRUCT_ARRAY_MEMBER_HELPER !2 !3 !4 !5 !6 !7 !8 !9
  #ELSE
    #STRM ARRAY !1
  #ENDIF
#ENDCOMMAND

#COMMAND STRUCT_ARRAY_MEMBER T R R
  #DATA
  ARRAY_DIM_SIZE_HELPER !2 !3 !4 !5 !6 !7 !8 !9
  STRUCT_ARRAY_TYPE_HELPER !1
  #SET Q$ 0
  ARRAY_DIM_COUNT_HELPER !2 !3 !4 !5 !6 !7 !8 !9 // sets !q to num of dims
  #DPUSH |CI!q //Push the number of dimensions
  STRUCT_ARRAY_MEMBER_HELPER !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND


#COMMAND Local$Scalar R R
  #CHECK !2 _RT
  #PUSH !q
  #DTYPE Q$ !1        // get the property type in q
  #IF (!q=19)
    //It's a struct
    #PUSH !h
    #STRG H$ !1
    #REPLACE !2 |SK!ZGV!h
    #POP H$
  #ELSE
    #SPUSH
    #DTSYM !1 // moves datatype Letter ID into !$
    #REPLACE !2 |S!$!ZG
    #SPOP
  #ENDIF
  #POP Q$

  #IF (!0>2)
    Local$Scalar !1 !3 !4 !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

#COMMAND LOCAL R R // T T
  #IFDEF __@INSIDE_FUNCTION@__
    #PUSH !q
    #DTYPE Q$ !1
    #IF (!q=-1)
      #ERROR DFERR_COMP_INVALID_DATATYPE (!1)
    #ELSE
      #IFADIM !2
        Local$Array !1 !2 !3 !4 !5 !6 !7 !8 !9
      #ELSE
        Local$Scalar  !1 !2 !3 !4 !5 !6 !7 !8 !9
      #ENDIF
    #ENDIF
    #POP Q$
  #ELSE
    #ERROR DFERR_COMP_ILLEGAL_CODE_PLACEMENT LOCAL Variables can only be defined within methods
  #ENDIF
#ENDCOMMAND


//#COMMAND GLOBAL$Scalar R R

// #CHECK !2 _RT

// #IFSAME !1 STRING
//   // strings are treated as special because they have a set of values.
//   #IF (!0>2)
//     #IFDEF !3
//       #CHECK !3 _VSWDF
//       #STR V$ !3
//       #REPLACE !2 |VS!v
//       #IF (!0>3)
//         Global$Scalar !1 !4 !5 !6 !7 !8 !9
//       #ENDIF
//     #ELSE
//       #STR V$ 80
//       #REPLACE !2 |VS!v
//       Global$Scalar !1 !3 !4 !5 !6 !7 !8 !9
//     #ENDIF
//   #ELSE
//     #STR V$ 80
//     #REPLACE !2 |VS!v
//   #ENDIF
// #ELSE
//   #PUSH !q
//   #DTYPE Q$ !1        // get the property type in q
//   #IF (!q=19)
//     //It's a struct
//     #PUSH !h
//     #STRG H$ !1
//     #STRV V$ !h
//     #REPLACE !2 |VK!vV!h
//     #POP H$
//   #ELSE
//     #SPUSH
////     #SET $$ TYPE$SYMBOL$!1
////     #REM arg is !$
////     Scalar$Variable$Help !2 TYPE$SYMBOL$G$!1 // V
////     Scalar$Variable$Help !2 !$ V
//     #DTSYM !1
//     #REPLACE !2 |V!$!v // ZG
//     #REM !2 ------------------------------------
//     #SPOP

//   #ENDIF
//   #POP Q$

//   #IF (!0>2)
//     GLOBAL$Scalar !1 !3 !4 !5 !6 !7 !8 !9
//   #ENDIF
//#ENDCOMMAND


#COMMAND GLOBAL_VARIABLE R R
  #PUSH !q
  #DTYPE Q$ !1
  #IF (!q=-1)
    #ERROR DFERR_COMP_INVALID_DATATYPE (!1)
  #ELSE
    #IFADIM !2       // if a global array, treat as such
      Global$Array !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      Global$Scalar !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF // if aDim
  #ENDIF // if (!q=-1)
  #POP Q$
#ENDCOMMAND

#COMMAND  Global$Scalar
  #IF (!0>0)
    #CHECK !2 _RT

    #IFSAME !1 STRING
      // strings are treated as special because they have a set of values.
      #IF (!0>2)
        #IFDEF !3
          #CHECK !3 _VSWDF
          #STR V$ !3
          #REPLACE !2 |VS!v
          #IF (!0>3)
             Global$Scalar !1 !4 !5 !6 !7 !8 !9
          #ENDIF
        #ELSE
          #STR V$ 80
          #REPLACE !2 |VS!v
           Global$Scalar !1 !3 !4 !5 !6 !7 !8 !9
        #ENDIF
      #ELSE
        #STR V$ 80
        #REPLACE !2 |VS!v
      #ENDIF
    #ELSE
      #IFSAME !1 INTEGER
        #REPLACE !2 |VI!D
      #ELSE
        #IFSAME !1 DATE
          #NUM V$
          #REPLACE !2 |VD!v
        #ELSE
          #IFSAME !1 NUMBER
            #NUM V$
            #REPLACE !2 |VN!v
          #ELSE
            #IFSAME !1 REAL
              #REAL V$
              #REPLACE !2 |VR!v
            #ELSE
              #IFSAME !1 ADDRESS
                #ADDRESS V$
                #REPLACE !2 |VX!v
              #ELSE
                #IFSAME !1 BIGINT
                  #BIGINT V$
                  #REPLACE !2 |VH!v
                #ELSE
                  #IFSAME !1 TIME
                    #TIME V$
                    #REPLACE !2 |VT!v
                  #ELSE
                    #IFSAME !1 DATETIME
                      #STAM V$
                      #REPLACE !2 |VM!v
                    #ELSE
                      #IFSAME !1 FLOAT
                        #FLOAT V$
                        #REPLACE !2 |VF!v
                      #ELSE
                        #IFSAME !1 CHAR
                          #CHAR V$
                          #REPLACE !2 |VY!v
                        #ELSE
                          #IFSAME !1 UCHAR
                            #UCHAR V$
                            #REPLACE !2 |VC!v
                          #ELSE
                            #IFSAME !1 SHORT
                              #SHORT V$
                              #REPLACE !2 |VW!v
                            #ELSE
                              #IFSAME !1 USHORT
                                #USHORT V$
                                #REPLACE !2 |VU!v
                              #ELSE
                                #IFSAME !1 UINTEGER
                                  #ULONG V$
                                  #REPLACE !2 |VV!v
                                #ELSE
                                  #IFSAME !1 BOOLEAN
                                    #BIT V$
                                    #REPLACE !2 |VZ!v
                                  #ELSE
                                    #IFSAME !1 UBIGINT
                                      #BIGU V$
                                      #REPLACE !2 |VG!v
                                    #ELSE
                                      #IFSAME !1 CURRENCY
                                        #CURR V$
                                        #REPLACE !2 |VO!v
                                      #ELSE
                                        #IFSAME !1 TIMESPAN
                                          #SPAN V$
                                          #REPLACE !2 |VP!v
                                        #ELSE
                                          #IFSAME !1 DECIMAL
                                            #BIGN V$
                                            #REPLACE !2 |VQ!v
                                          #ELSE
                                            #IFSAME !1 VARIANT
                                              #VRNT V$
                                              #REPLACE !2 |VJ!v
                                            #ELSE
                                              #IFSAME !1 ROWID
                                                #ROWI V$
                                                #REPLACE !2 |V@!v
                                              #ELSE
                                                #PUSH !h
                                                #STRG H$ !1
                                                #IF !h
                                                  #STRV V$ !h
                                                  #REPLACE !2 |VK!vV!h
                                                #ELSE
                                                  #ERROR DFERR_COMP_INVALID_DATATYPE (!1)
                                                #ENDIF
                                                #POP H$
                                              #ENDIF // RowID
                                            #ENDIF // Variant
                                          #ENDIF // Decimal
                                        #ENDIF // TimeSpan
                                      #ENDIF // Currenct
                                    #ENDIF // UBigInt
                                  #ENDIF // Boolean
                                #ENDIF // UInteger
                              #ENDIF // UShort
                            #ENDIF // Short
                          #ENDIF // UChar
                        #ENDIF // Char
                      #ENDIF // Float
                    #ENDIF // TimeDate
                  #ENDIF // Time
                #ENDIF // BigInt
              #ENDIF // address
            #ENDIF  // real
          #ENDIF // number
        #ENDIF // date
      #ENDIF  // integer
      #IF (!0>2)
         Global$Scalar !1 !3 !4 !5 !6 !7 !8 !9
      #ENDIF
    #ENDIF     // end of string
  #ENDIF      // if there are parameters
#ENDCOMMAND

// External function command declairs the external entry point to
// The DF system.  The compiler creates a reference to the function
// complete with return type and parameter information.  The macro
// also generates code that retains the name of the function and the
// name of the library in a runtime array.  This array is used when
// the DLL is "loaded".

#COMMAND SET_DEFAULT_CALLTYPE _R .
  #IF (!1=16)
    #SET ZK$ 1
  #ELSE
    #SET ZK$ 0
  #ENDIF
#ENDCOMMAND


//External_Function FunctionName "FunctionName" DLLName {Parameters ...} Returns DataType
#COMMAND EXTERNAL_FUNCTION
    #IF !Zk=0
      EXTERNAL$FUNCTION $54C LOAD_ON_USE GET_ !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      EXTERNAL$FUNCTION $54D LOAD_ON_USE GET_ !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
#ENDCOMMAND

#COMMAND EXTERNAL_PROCEDURE
    #IF !Zk=0
      EXTERNAL$FUNCTION $54C LOAD_ON_USE MSG_ !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ELSE
      EXTERNAL$FUNCTION $54D LOAD_ON_USE MSG_ !1 !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
#ENDCOMMAND

#COMMAND EXTERNAL_FUNCTION16
    EXTERNAL$FUNCTION $54D LOAD_ON_USE GET_ !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND EXTERNAL_PROCEDURE16
    EXTERNAL$FUNCTION $54D LOAD_ON_USE MSG_ !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND EXTERNAL_FUNCTION32
    EXTERNAL$FUNCTION $54C LOAD_ON_USE GET_ !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

#COMMAND EXTERNAL_PROCEDURE32
    EXTERNAL$FUNCTION $54C LOAD_ON_USE MSG_ !1 !2 !3 !4 !5 !6 !7 !8 !9
#ENDCOMMAND

//External$Function Command Flag GET_|MSG_ FunctionName {"FunctionName"} DLLName {Parameters ...} Returns DataType
#COMMAND EXTERNAL$FUNCTION _R _R "GET_""MSG_" TR RIDN
  #IFTYPE !5 S

    // check that the function name is not one of our reserved internal functions
    #IFSAME !3 GET_
      #IFSAME FN$!4  __F__
        #ERROR DFERR_COMP_ILLEGAL_EXTERNAL_FUNCTION_DEFINTION !4 is an internal function name
      #ENDIF
    #ENDIF

    #IFDEF !3!4 // if defined as object, function, property, external, an error
      // We have an error. This just generates more accurate information
      #IFSAME !3 GET_  // function errors can  be name already used as Object, global function, or reg function
        #IF (GET_!4>$40000000)
          #ERROR DFERR_COMP_ILLEGAL_EXTERNAL_FUNCTION_DEFINTION !4 is already defined as an object
        #ELSE
          #IF (GET_!4<0)
            #ERROR DFERR_COMP_ILLEGAL_EXTERNAL_FUNCTION_DEFINTION !4 is already defined as a global function
          #ELSE
            #ERROR DFERR_COMP_ILLEGAL_METHOD_DEFINTION !4 is already defined as a function or external_function
          #ENDIF
        #ENDIF
      #ELSE  // if procecure it can be global or regular
        #IF (MSG_!4<0)
          #ERROR DFERR_COMP_ILLEGAL_EXTERNAL_FUNCTION_DEFINTION !4 is already defined as a global procedure
        #ELSE
          #ERROR DFERR_COMP_ILLEGAL_EXTERNAL_FUNCTION_DEFINTION !4 is already defined as a procedure or external_procedure
        #ENDIF
      #ENDIF
    #ELSE
      MESSAGE$ADDRESS !3!4 // create any symbol (for global)
      CHECK$METHOD$ARGUMENT$LIST !7 !8 !9
      #DATA
      #FREG !3!4 GLOBAL !7 !8 !9
      #DPUSH !3!4      // Message ID
      #DPUSH !2        // Load Type
      #DPUSH |CS"!6"   // DLL Name
      #DPUSH !5     // Function Name
      GET$RETURN$TYPE !7 !8 !9  // Push Return Type
      !A [] !1 |CI0 |VL
    #ENDIF
  #ELSE
    EXTERNAL$FUNCTION !1 !2 !3 !4 |CS"!4" !5 !6 !7 !8 !9
  #ENDIF
#ENDCOMMAND

#COMMAND GET$RETURN$TYPE
    #IF !0=1
        #IFSAME !1 INTEGER
            #DPUSH |CI3
        #ELSE
            #IFSAME !1 UINTEGER
                #DPUSH |CI15
            #ELSE
                #IFSAME !1 STRING
                    #DPUSH |CI0
                #ELSE
                    #IFSAME !1 REAL
                        #DPUSH |CI5
                    #ELSE
                        #IFSAME !1 FLOAT
                            #DPUSH |CI10
                        #ELSE
                            #IFSAME !1 ADDRESS
                                #DPUSH |CI7
                            #ELSE
                                #IFSAME !1 SHORT
                                    #DPUSH |CI13
                                #ELSE
                                    #IFSAME !1 USHORT
                                        #DPUSH |CI14
                                    #ELSE
                                        #IFSAME !1 CHAR
                                            #DPUSH |CI11
                                        #ELSE
                                            #IFSAME !1 UCHAR
                                                #DPUSH |CI12
                                            #ELSE
                                                #IFSAME !1 BOOLEAN
                                                    #DPUSH |CI3 // Push an int for boolean return type
                                                #ELSE
                                                    #DPUSH |CI3 // Push an int return value anyway
                                                    #ERROR DFERR_COMP_ILLEGAL_RETURN_TYPE Unknown return type for external function
                                                #ENDIF
                                            #ENDIF
                                        #ENDIF
                                    #ENDIF
                                #ENDIF
                            #ENDIF
                        #ENDIF
                    #ENDIF
                #ENDIF
            #ENDIF
        #ENDIF
    #ELSE
        GET$RETURN$TYPE !2 !3 !4 !5 !6 !7 !8 !9
    #ENDIF
#ENDCOMMAND

// Commands used for active-x stuff. Moved from flexcom20_base.pkg. The Embed_activeX_resource stuff results in very
// strange long errors if this command i snot always available.
#COMMAND Include_ActiveX_Resource R R
    #BSTR V$ file storage !1 !2
    Set psResourceData to |VS!v
#ENDCOMMAND

#COMMAND EMBED_ACTIVEX_RESOURCE
    #BSTR V$ READ BASE64RESOURCE
#ENDCOMMAND

#COMMAND END_EMBED_ACTIVEX_RESOURCE
    Set psResourceData to |VS!v
#ENDCOMMAND

// for internal use only for generating the errordisplay stack dump dialog
// ErrorDisplay iErrorLine sMessage sCaption sOkText sCopyText
#COMMAND ErrorDisplay R R R R R
    #DATA
    #DPUSH !1
    #DPUSH !2
    #DPUSH !3
    #DPUSH !4
    #DPUSH !5
    !A[] $57 |VL
#ENDCOMMAND


// Low level command that can be used within error handlers (e.g. error_report) to get a string of the current call stack.
#COMMAND CALLSTACKDUMP R
    !A [] $058 !1
#ENDCOMMAND

// This forces the entire application to use the old MSXML3 parser.
// This must be used before you create any XML object. Only provided
// for backwards compatibility. Added 15.1
#COMMAND USE_LEGACY_XML_LIB
    !A [] $057c
#ENDCOMMAND


    